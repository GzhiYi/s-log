<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=client/client-87ec37cb.css rel=stylesheet><link href=client/index-8af03042.css rel=stylesheet> <title>GzhiYi's Blog</title><meta content=一枚前端工程师，编程是一份兴趣，热爱着生活。喜欢开发一些有兴趣的产品，践行程序员的乐趣。 name=description data-svelte=svelte-4iu3x1><meta content=前端开发者，web，vue，React，svelte，小程序，JavaScript，CSS，blog name=keywords data-svelte=svelte-4iu3x1> <link href=/client/client.e0961b94.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-87ec37cb.css rel=preload as=style><link href=/client/index.dd3884ff.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/config.026ad977.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/index-8af03042.css rel=preload as=style></head> <body> <div id=sapper> <nav class=svelte-1vrbr95><ul class=svelte-1vrbr95><li class=svelte-1vrbr95><a class=svelte-1vrbr95 href=blog rel=prefetch>文章列表</a></ul></nav> <div style=width:100%;height:56px;background-color:#dee2e8></div> <main class=svelte-1ca6gui style=padding:1rem> <ul class="svelte-1e9jnc1 post-list"> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_08_vue-sentry rel=prefetch>vue引入sentry上报web异常</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_08_vue-render-source rel=prefetch>理解一下vue的render方法</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_08_express-hot-reload rel=prefetch>为node应用增加hot reload</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_08_how-this-log-data rel=prefetch>vue是怎么在mounted、created等中访问到data数据的？</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_08_cssjiemi rel=prefetch>css揭秘的小笔记</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_08_vue-built-version rel=prefetch>Vue构建出来的版本</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_08_no-need-comment rel=prefetch>博客或许不需要评论系统</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_08_mouse-switch rel=prefetch>g102鼠标微动更换</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_08_git-commit-format rel=prefetch>Git提交信息格式化（规范）</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_08_lodash-array-difference rel=prefetch>lodash数组中difference方法</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_08_vue-docker-buildkit rel=prefetch>用docker构建vue项目镜像，与buildkit体积对比</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_07_Maximum-call-stack-size-exceeded-error rel=prefetch>记一次Maximum call stack size exceeded error</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_07_dockerfile rel=prefetch>Dockerfile的一些用法记录</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_07_docker-command rel=prefetch>Docker的一些需记基础命令和用法</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_07_ubuntu20 rel=prefetch>【自用】ubuntu20必须安装</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_07_yarn-global-install-not-working rel=prefetch>npm全局安装yarn不生效的问题</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_07_lodash-concat rel=prefetch>lodash数组中concat方法</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_07_npm-global-EACCES rel=prefetch>npm全局安装package出现EACCES permissions</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_07_lodash-array-chunk rel=prefetch>lodash数组中chunk、compact方法</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_06_vue-dom-not-found rel=prefetch>vue获取不到dom节点</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_06_svelte rel=prefetch>svelte语法点小记</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2021_04_ready-back rel=prefetch>预备回归写博客啦</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2020_10_apple rel=prefetch>苹果新手机发布会</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2020_07_text-ellipsis-title rel=prefetch>safari出现未设置title属性却显示ttile弹窗的问题</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2020_07_boardband rel=prefetch>最近安装宽带的问题</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2020_06_vscode-up-down-quickly rel=prefetch>Visual Studio Code快速上下滚动光标</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2020_06_valine-and-notifications rel=prefetch>博客评论更改为valine并增加评论推送</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2020_06_firebase rel=prefetch>用firebase给静态博客页面增加点赞功能</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2020_06_apple-wwdc-2020 rel=prefetch>2020年苹果开发者大会</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2020_06_sapper-github-actions rel=prefetch>使用github actions自动编译部署sapper-blog</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2020_06_eclipse rel=prefetch>日环食</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2020_06_build-blog rel=prefetch>用sapper构建一个博客</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2020_05_element-ui-table-header-sticky rel=prefetch>Element-ui table组件表头sticky</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2020_01_docker-easymock rel=prefetch>Docker安装easymock</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2019_12_docker-nuxtjs rel=prefetch>Docker部署nuxtjs应用</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2019_11_http-cache rel=prefetch>Http缓存</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2019_09_js-asset-import rel=prefetch>JS引入资源的一点总结</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2019_09_codereview rel=prefetch>CodeReview</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2019_09_mp-env-seperate rel=prefetch>分离小程序环境</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2019_08_mp-pass rel=prefetch>我想要小程序过审</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2019_06_mp-egg rel=prefetch>小程序egg后台简要文档</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2019_04_history-api rel=prefetch>修改浏览器回退历史</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2019_04_project-down rel=prefetch>项目突然跑不起来</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2019_03_hackintosh rel=prefetch>黑苹果计划</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2019_02_new-year rel=prefetch>新的一年，加油</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2019_01_chrome-provisional-header rel=prefetch>chrome出现Caution provisional headers are shown的问题</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2018_12_koa-async rel=prefetch>koa异步写文件遇到的小问题</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2018_12_es6-module rel=prefetch>ES6 Module语法小结</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2018_11_git-usage-in-work rel=prefetch>git在工作中的一些用处</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2018_11_qiniu-download-pic rel=prefetch>七牛回收测试域名后，下载图片</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2018_10_mp-countdown rel=prefetch>用小程序做个动态倒计时</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2018_10_month-pass rel=prefetch>不知不觉一个月了</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2018_10_h5-step rel=prefetch>一次h5开发踩坑记录</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2018_10_anti-theft rel=prefetch>防盗链的解析</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2018_05_mp-back rel=prefetch>微信小程序踩坑</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2018_04_ubuntu-sougou rel=prefetch>Ubuntu的搜狗输入法出现候选词乱码的问题</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2017_12_linux-mint rel=prefetch>每次重装Linux Mint减少90%时间</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2017_11_win10-ubuntu rel=prefetch>前端搭建win10-ubuntu双系统的小记</a></li> <li class=svelte-1e9jnc1><a class=svelte-1e9jnc1 href=blog/2017_11_ubuntu-shadowsocks rel=prefetch>如何在ubuntu下使用shadowsocks</a></ul> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,(function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A){return {posts:[{title:"vue引入sentry上报web异常",slug:"2021_08_vue-sentry",description:"vue引入sentry作为页面异常监控；罗列了基本的引入方式，并就过程中遇到的问题进行记录。",keywords:"vue,sentry,sourcemap,UglifyJsPlugin,node,webpack,not working,upload",labels:[f],date:"2021-08-20",path:"2021\u002F08\u002Fvue-sentry.md",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2021\u002F08\u002F20\u002FfLZgCaUNwyb5VI8.png\" alt=\"sentry\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E如果不知道sentry的，可以到官网了解一下功能。\u003Ca target='_blank'  href=\"https:\u002F\u002Fsentry.io\u002F\"\u003Esentry\u003C\u002Fa\u003E是一个错误上报，用于监控线上代码运行情况的一个工具。在对vue-cli项目引入sentry时，出现了一些问题，所以需要记录一下，也方便如果有遇到这些问题的人。\u003C\u002Fp\u003E\n\u003Ch3 id=\"引入\"\u003E引入\u003C\u002Fh3\u003E\n\u003Cp\u003E引入方式不多说，简单提一下。\u003C\u002Fp\u003E\n\u003Cp\u003E在vue实例初始化之前完成sentry的引入。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-shell\"\u003Eyarn \u003Cspan class=\"hljs-builtin-name\"\u003Eadd\u003C\u002Fspan\u003E raven-js\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E Raven \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;raven-js&#x27;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E RavenVue \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;raven-js\u002Fplugins\u002Fvue&#x27;\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F sentryDSN 需要填入\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (isProduction) Raven.config(sentryDSN, {\n  release: \u003Cspan class=\"hljs-string\"\u003E&#x27;xxxx&#x27;\u003C\u002Fspan\u003E\n}).addPlugin(RavenVue, Vue).install()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"sourcemap\"\u003EsourceMap\u003C\u002Fh3\u003E\n\u003Cp\u003E前端项目在部署到线上环境之后，都会进行代码压缩混淆。所以线上报错的异常会指向混淆的代码位置，会不容易定位问题。sourceMap不能部署到线上环境，不然会泄露代码。尽管前端代码没有秘密，但可以通过压缩混淆增加秘密的访问成本。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E所以要把sourceMap上传到sentry但不能部署到线上目录\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch4 id=\"开启构建生成sourcemap\"\u003E开启构建生成sourceMap\u003C\u002Fh4\u003E\n\u003Cp\u003E在\u003Ccode\u003Evue.config.js\u003C\u002Fcode\u003E中，开启productionSourceMap\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-attr\"\u003EproductionSourceMap:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch4 id=\"无法打包出sourcemap\"\u003E无法打包出sourceMap\u003C\u002Fh4\u003E\n\u003Cp\u003E一般而言，开启该属性会在build构建生产文件内的js目录看到对应的.map文件。\u003C\u002Fp\u003E\n\u003Cp\u003E不过我遇到就算开启了sourceMap也没有正确打包生成.map文件的问题。\n如果出现这样的问题，考虑是否有其余的插件影响到.map文件的生成。\u003C\u002Fp\u003E\n\u003Cp\u003E最后发现是webpack插件\u003Ca target='_blank'  href=\"https:\u002F\u002Fwebpack.docschina.org\u002Fplugins\u002Fuglifyjs-webpack-plugin\u002F\"\u003EUglifyjsWebpackPlugin\u003C\u002Fa\u003E导致无法打包出.map。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 就算开启了productionSourceMap也要把下面的选项开启\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E UglifyJsPlugin({\n  sourceMap: \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E,\n})\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"使用sentrycliplugin上传soucemap\"\u003E使用SentryCliPlugin上传souceMap\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (isProduction) {\n  config.plugin(\u003Cspan class=\"hljs-string\"\u003E&#x27;sentry&#x27;\u003C\u002Fspan\u003E).use(SentryPlugin, [\n    {\n      \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 指定忽略文件配置\n      ignoreFile: \u003Cspan class=\"hljs-string\"\u003E&#x27;.gitignore&#x27;\u003C\u002Fspan\u003E,\n      \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 指定上传目录\n      include: \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002Fdist&#x27;\u003C\u002Fspan\u003E,\n      \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 指定sentry上传配置\n      configFile: \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002F.sentryclirc&#x27;\u003C\u002Fspan\u003E,\n      \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 指定发布版本, 需要和raven配置的release一致\n      release: \u003Cspan class=\"hljs-string\"\u003E&#x27;xxxx&#x27;\u003C\u002Fspan\u003E,\n      \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 保持与publicPath相符\n      urlPrefix: publicPath\n    }\n  ])\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch4 id=\"上传遇到429错误\"\u003E上传遇到429错误\u003C\u002Fh4\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2021\u002F08\u002F20\u002FpicIGw19U2k4Rvj.png\" alt=\"sentry-429\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E出错原因是请求并发过大，要解决这个问题，需要改为手动通过node调用sentryapi上传souceMap。\u003C\u002Fp\u003E\n\u003Cp\u003E通过node上传，可以限制上传的并发数，以达到目的。\u003C\u002Fp\u003E\n"},{title:"理解一下vue的render方法",slug:"2021_08_vue-render-source",description:"vue的render方法",keywords:null,labels:[k],date:"2021-08-19",path:"2021\u002F08\u002Fvue-render-source.md",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2021\u002F08\u002F19\u002Fw6YcFmd1eJOA5oC.png\" alt=\"属性未定义的错误提示\" \u003E\u003C\u002Fdiv\u003E \u003C\u002Fp\u003E\n\u003Cp\u003E上面提示会出现在我们没有在vue中定义该data却在模板中提到的时候。恰好是在render执行过程中出现的，所以可以借此理解一下vue的render函数。\u003C\u002Fp\u003E\n\u003Ch3 id=\"render\"\u003Erender\u003C\u002Fh3\u003E\n\u003Cp\u003Erender函数是vue实例中的一个私有方法，作用是通过\u003Ccode\u003EcreateElement\u003C\u002Fcode\u003E创建并返回虚拟dom(vnode)。翻看源码，该方法定义在\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fvuejs\u002Fvue\u002Fblob\u002Fdev\u002Fsrc\u002Fcore\u002Finstance\u002Frender.js\"\u003Esrc\u002Fcore\u002Finstance\u002Frender.js\u003C\u002Fa\u003E中。\u003C\u002Fp\u003E\n\u003Cp\u003E位于\u003Ccode\u003EinitRender\u003C\u002Fcode\u003E函数。在这函数里面找到_render的定义：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003EVue.prototype._render = \u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (){\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E ...\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 从options中拿到render函数\n  const { render } = vm.\u003Cspan class=\"hljs-variable\"\u003E$options\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 通过call函数传入当前上下文\n  vnode = render.call(vm._renderProxy, vm.\u003Cspan class=\"hljs-variable\"\u003E$createElement\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E ...\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"createelement\"\u003EcreateElement\u003C\u002Fh3\u003E\n\u003Cp\u003Evm中的createElement在该函数上方有定义。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003Evm._c =\u003Cspan class=\"hljs-function\"\u003E (\u003Cspan class=\"hljs-params\"\u003Ea\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Eb\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ec\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ed\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E create\u003Cspan class=\"hljs-constructor\"\u003EElement(\u003Cspan class=\"hljs-params\"\u003Evm\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ea\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Eb\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ec\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ed\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Efalse\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\nvm.$createElement =\u003Cspan class=\"hljs-function\"\u003E (\u003Cspan class=\"hljs-params\"\u003Ea\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Eb\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ec\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ed\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E create\u003Cspan class=\"hljs-constructor\"\u003EElement(\u003Cspan class=\"hljs-params\"\u003Evm\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ea\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Eb\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ec\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ed\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Etrue\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E可以知道，第一个私有函数_c挂在vm上是提供给编译器编译模版生成render函数。\u003C\u002Fp\u003E\n\u003Cp\u003E第二个直接定义在实例上，提供用于手写render方法。\u003C\u002Fp\u003E\n\u003Cp\u003E我们在vue中render函数是这么写的：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Vue({\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003Erender\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003EcreateElement\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F do sth\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E createElement(\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F vnode stuff\u003C\u002Fspan\u003E\n    )\n  }\n})\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里的createElement就是在上方代码中定义的。  \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003Evnode的生成会替换render目标元素dom，所以不能把vue实例render到有内容的dom上。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"renderproxy\"\u003ErenderProxy\u003C\u002Fh3\u003E\n\u003Cp\u003Erender.call函数的第一个参数是\u003Ccode\u003Evm._renderProxy\u003C\u002Fcode\u003E，在\u003Ccode\u003Einit.js\u003C\u002Fcode\u003E中，有这两行代码在初始化周期等前执行：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (undefined !== \u003Cspan class=\"hljs-string\"\u003E&#x27;production&#x27;\u003C\u002Fspan\u003E) {\n  initProxy(\u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E)\n} \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E._renderProxy = \u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E表示如果当前是开发环境，就执行initProxy，来看看initProxy的代码。initProxy位于\u003Ccode\u003Esrc\u002Fcore\u002Finstance\u002Fproxy.js\u003C\u002Fcode\u003E中。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003EinitProxy = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EinitProxy\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(vm)\u003C\u002Fspan\u003E {\u003C\u002Fspan\u003E\n  \u002F\u002F hasProxy是用于判断当前环境是否支持proxy\u002F\n  \u002F\u002F 支持的浏览器将直接调用\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Proxy进行数据劫持\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (hasProxy) {\n    \u002F\u002F determine which proxy handler \u003Cspan class=\"hljs-keyword\"\u003Eto\u003C\u002Fspan\u003E use\n    const \u003Cspan class=\"hljs-keyword\"\u003Eoptions\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E.$\u003Cspan class=\"hljs-keyword\"\u003Eoptions\u003C\u002Fspan\u003E\n    const handlers = \u003Cspan class=\"hljs-keyword\"\u003Eoptions\u003C\u002Fspan\u003E.render &amp;&amp; \u003Cspan class=\"hljs-keyword\"\u003Eoptions\u003C\u002Fspan\u003E.render._withStripped\n      ? getHandler\n      : hasHandler\n    \u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E._renderProxy = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Proxy(\u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E, handlers)\n  } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E._renderProxy = \u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E如果在支持的浏览器中，\u003Ccode\u003Enew Proxy\u003C\u002Fcode\u003E的第二个参数会传入\u003Ccode\u003EhasHandler\u003C\u002Fcode\u003E，查看hasHandler定义:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E hasHandler = {\n  has (target, \u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E) {\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E has = \u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E in target\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E isAllowed = allowedGlobals(\u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E) ||\n      (typeof \u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E === \u003Cspan class=\"hljs-string\"\u003E&#x27;string&#x27;\u003C\u002Fspan\u003E &amp;&amp; \u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E.charAt(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E) === \u003Cspan class=\"hljs-string\"\u003E&#x27;_&#x27;\u003C\u002Fspan\u003E &amp;&amp; !(\u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E in target.$data))\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!has &amp;&amp; !isAllowed) {\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E in target.$data) warnReservedPrefix(target, \u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E)\n      \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E warnNonPresent(target, \u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E)\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E has || !isAllowed\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fzh-CN\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FProxy\"\u003EProxy\u003C\u002Fa\u003E，在这里就是对vm的data进行数据劫持，也就是代理。\u003C\u002Fp\u003E\n\u003Cp\u003Ehandler又一个has方法，这是针对 in 操作符的代理方法，has内部主要检查target中是否有key属性，如果有就继续执行，如果没有，就回到文章开头的那个错误提示啦。\u003C\u002Fp\u003E\n\u003Ch3 id=\"总结\"\u003E总结\u003C\u002Fh3\u003E\n\u003Cp\u003E在\u003Ccode\u003Einit.js\u003C\u002Fcode\u003E中定义了\u003Ccode\u003EinitRender\u003C\u002Fcode\u003E以及\u003Ccode\u003E_renderProxy\u003C\u002Fcode\u003E方法。在\u003Ccode\u003Erender.js\u003C\u002Fcode\u003E找到render函数定义，主要描述了对用户手写的render函数进行处理生成vnode，中间将vnode设置到vm实例中(vm.$vnode)，最后返回并执行后续的操作。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EVue版本：\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fvuejs\u002Fvue\u002Farchive\u002Frefs\u002Ftags\u002Fv2.6.14.zip\"\u003E2.6.14\u003C\u002Fa\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n"},{title:"为node应用增加hot reload",slug:"2021_08_express-hot-reload",description:"express或者koa增加hotreload已提高开发体验。怎么开启hotreload呢？怎么在node应用中开启hotreload？",keywords:"node,hotreload,express,koa,nodemon",labels:["node"],date:"2021-08-17",path:"2021\u002F08\u002Fexpress-hot-reload.md",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2021\u002F08\u002F17\u002F24wim8VqIhJK3kg.png\" alt=\"nodemon\" \u003E\u003C\u002Fdiv\u003E  \u003C\u002Fp\u003E\n\u003Cp\u003E起了一个express应用，初期基本上都是修改一处，随后ctrl + c后再run，等应用稍微大一些些的时候，会被反复的重启应用影响开发效率。\u003C\u002Fp\u003E\n\u003Cp\u003E上面就是热更新（hot reload）解决的最大的痛点。\u003C\u002Fp\u003E\n\u003Ch3 id=\"使用nodemon进行热更新\"\u003E使用nodemon进行热更新\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fnodemon.io\u002F\"\u003Enodemon\u003C\u002Fa\u003E可以在node应用中一旦有任何代码上的改动都会重新启动你的应用。推荐在项目内添加而不是全局使用。\u003C\u002Fp\u003E\n\u003Cp\u003E在项目中：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-shell\"\u003Eyarn \u003Cspan class=\"hljs-built_in\"\u003Eadd\u003C\u002Fspan\u003E nodemon \u003Cspan class=\"hljs-comment\"\u003E--dev\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在package中的script脚本，替换原有的node启动命令为：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-json\"\u003E{\n  \u003Cspan class=\"hljs-attr\"\u003E&quot;scripts&quot;\u003C\u002Fspan\u003E: {\n    \u003Cspan class=\"hljs-attr\"\u003E&quot;dev&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;nodemon index.js&quot;\u003C\u002Fspan\u003E\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E随后就可以通过\u003Ccode\u003Eyarn run dev\u003C\u002Fcode\u003E的方式运行带有hotreload的node应用了。\u003C\u002Fp\u003E\n"},{title:"vue是怎么在mounted、created等中访问到data数据的？",slug:"2021_08_how-this-log-data",description:"vue源码分析，为什么可以在created、mounted中通过this[key]访问vue中的data",keywords:"vue，源码，this，data，created，mounted，生命周期",labels:[k],date:"2021-08-16",path:"2021\u002F08\u002Fhow-this-log-data.md",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2021\u002F08\u002F16\u002F9wQxRlcUEeNstY8.png\" alt=\"defineProperty\" \u003E\u003C\u002Fdiv\u003E  \u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E{\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003Emounted\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.name) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F GzhiYi\u003C\u002Fspan\u003E\n  },\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003Edata\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-attr\"\u003Ename\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;GzhiYi&#x27;\u003C\u002Fspan\u003E\n    }\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E如上代码，我们可以在\u003Ccode\u003Emounted\u003C\u002Fcode\u003E的周期钩子中访问到在data中定义到name属性。为什么可以访问到呢，可以通过vue源码中找到原因。\u003C\u002Fp\u003E\n\u003Cp\u003E这涉及到了vue在new实例后处理的事情。\u003C\u002Fp\u003E\n\u003Ch3 id=\"涉及源码及相关文件\"\u003E涉及源码及相关文件\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ccode\u003Esrc\u002Fcore\u002Finstance\u002Findex.js\u003C\u002Fcode\u003E，这个文件中找到vue构造函数。其中\u003Ccode\u003EinitMixin(Vue)\u003C\u002Fcode\u003E对Vue实例进行初始化操作。该方法在\u003Ccode\u003Esrc\u002Fcore\u002Finstance\u002Finit.js\u003C\u002Fcode\u003E中进行定义。由于是查看data相关的数据处理动向，我们可以定位到\u003Ccode\u003EState\u003C\u002Fcode\u003E的初始化方法\u003Ccode\u003EinitState(vm)\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E继续定位到state的初始化方法。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F 这里表示opts中如果opts.\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E有值则初始化\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E值。\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-title\"\u003Eif\u003C\u002Fspan\u003E (opts.\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E) {\n  \u003Cspan class=\"hljs-title\"\u003EinitData\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-title\"\u003Evm\u003C\u002Fspan\u003E)\n} else {\n  \u003Cspan class=\"hljs-title\"\u003Eobserve\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-title\"\u003Evm\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title\"\u003E_data\u003C\u002Fspan\u003E = {}, true \u002F* asRootData *\u002F)\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在initData中，可以看到：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F 这里连续赋值。如果\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E是一个函数，则走getData\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E = vm._data = typeof \u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E === &#x27;function&#x27;\u003C\u002Fspan\u003E\n  ? getData(\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E, vm)\u003C\u002Fspan\u003E\n  : \u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E || {}\u003C\u002Fspan\u003E\n\n\u002F\u002F 在getData中，是这样对\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E进行处理的\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E.call(\u003Cspan class=\"hljs-title\"\u003Evm\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-title\"\u003Evm\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E最后这里调用函数原型的\u003Ca target='_blank'  href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fzh-CN\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FFunction\u002Fcall\"\u003Ecall\u003C\u002Fa\u003E方法，实际等同于\u003Ccode\u003Evm.data(vm)\u003C\u002Fcode\u003E。由于data是一个函数，那在本例中\u003Ccode\u003EgetData\u003C\u002Fcode\u003E返回的就是：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-json\"\u003E{\n  \u003Cspan class=\"hljs-built_in\"\u003Ename\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;GzhiYi&quot;\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E额外增加一个预告，我们在vue中，一般定义data都是\u003Ccode\u003Efunction\u003C\u002Fcode\u003E的形式，这是建议的，但其实也可以定义为\u003Ccode\u003Eobject\u003C\u002Fcode\u003E的方式，从源码中可以看到\u003Ccode\u003EgetData\u003C\u002Fcode\u003E这个函数存在着\u003Ccode\u003EpushTarget\u003C\u002Fcode\u003E等函数的处理，这是后续我要去看源码理解的。暂时不牵挂。\u003C\u002Fp\u003E\n\u003Ch3 id=\"在实例中对data进行代理proxy\"\u003E在实例中对data进行代理(proxy)\u003C\u002Fh3\u003E\n\u003Cp\u003E符合本内容的主要数据操作其实在这里。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003Eproxy(vm, \u003Cspan class=\"hljs-string\"\u003E`_data`\u003C\u002Fspan\u003E, key)\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 追到proxy函数中，核心的就是对象的defineProperty方法。\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F defineProperty方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eproxy\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Etarget: \u003Cspan class=\"hljs-built_in\"\u003EObject\u003C\u002Fspan\u003E, sourceKey: \u003Cspan class=\"hljs-built_in\"\u003Estring\u003C\u002Fspan\u003E, key: \u003Cspan class=\"hljs-built_in\"\u003Estring\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  sharedPropertyDefinition.get = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EproxyGetter\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EproxySetter\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Eval\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E[sourceKey][key] = val\n  }\n  \u003Cspan class=\"hljs-built_in\"\u003EObject\u003C\u002Fspan\u003E.defineProperty(target, key, sharedPropertyDefinition)\n}\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 就是要把vm实例化时通过遍历data的值并把data的key-value定义到vm中。\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E由于要把data的每一项定义到vm上，所以vue在初始化state的时候，需要检测vm对象中是否已经有了data中定义的key。如果定义重复，也就是大概使用vue的人都会遇到以下的提醒：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003Ewarn(\n  `\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003EMethod\u003C\u002Fspan\u003E &quot;$\u003Cspan class=\"hljs-comment\"\u003E{key}\u003C\u002Fspan\u003E&quot; \u003Cspan class=\"hljs-title\"\u003Ehas\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ealready\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ebeen\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Edefined\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eas\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ea\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Edata\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eproperty\u003C\u002Fspan\u003E.`,\n  \u003Cspan class=\"hljs-title\"\u003Evm\u003C\u002Fspan\u003E\n)\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E所以，在vm中，也就是vue实例中，created和mounted都是vue实例的key，就可以通过\u003Ccode\u003Ethis[key]\u003C\u002Fcode\u003E去访问data中的值了。\u003C\u002Fp\u003E\n\u003Cp\u003E当然，要注意，\u003Ccode\u003EinitState(vm)\u003C\u002Fcode\u003E是在\u003Ccode\u003EbeforeCreate\u003C\u002Fcode\u003E这个钩子之后执行，所以beforeCreate是不能通过上面的方式进行访问的。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2021\u002F08\u002F16\u002FtwNof3mjWJT7A2r.png\" alt=\"hooks\" \u003E\u003C\u002Fdiv\u003E  \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EVue版本：\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fvuejs\u002Fvue\u002Farchive\u002Frefs\u002Ftags\u002Fv2.6.14.zip\"\u003E2.6.14\u003C\u002Fa\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n"},{title:l,slug:"2021_08_cssjiemi",description:l,keywords:"css，ccs揭秘",labels:["css"],date:"2021-08-13",path:"2021\u002F08\u002Fcssjiemi.md",html:"\u003Ch3 id=\"想清楚哪些是改动多，哪些是改动少的\"\u003E想清楚哪些是改动多，哪些是改动少的\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-css\"\u003E\u003Cspan class=\"hljs-selector-class\"\u003E.btn\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-attribute\"\u003Efont-size\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E20px\u003C\u002Fspan\u003E;\n  \u003Cspan class=\"hljs-attribute\"\u003Eline-height\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E30px\u003C\u002Fspan\u003E;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E当某些值相互依赖时，应该把它们的相互关系用代码表述出来，以便于维护。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-css\"\u003E\u003Cspan class=\"hljs-selector-class\"\u003E.btn\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-attribute\"\u003Efont-size\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E20px\u003C\u002Fspan\u003E;\n  \u003Cspan class=\"hljs-attribute\"\u003Eline-height\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E1.5\u003C\u002Fspan\u003E; \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 行高是字号的1.5倍\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"代码量少--代码易维护\"\u003E代码量少 &lt; 代码易维护\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-css\"\u003E\u003Cspan class=\"hljs-attribute\"\u003Eborder-width\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E10px\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E10px\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E10px\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F better\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-attribute\"\u003Eborder-width\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E10px\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-attribute\"\u003Eborder-left\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"合理的简写\"\u003E合理的简写\u003C\u002Fh3\u003E\n\u003Cp\u003E合理的简写可以防止未来会出现的风险。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-css\"\u003E.bg-\u003Cspan class=\"hljs-built_in\"\u003Ecolor\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-built_in\"\u003Ebackground\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-built_in\"\u003Ered\u003C\u002Fspan\u003E;\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F better\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-built_in\"\u003Ebackground\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-built_in\"\u003Ecolor\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-built_in\"\u003Ered\u003C\u002Fspan\u003E;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E意思是如果在另外的地方有对\u003Ccode\u003E.bg-color\u003C\u002Fcode\u003E声明了background-image，那bg-color这个元素就可能会被背景图片干扰，从而造成影响。\u003C\u002Fp\u003E\n"},{title:"Vue构建出来的版本",slug:"2021_08_vue-built-version",description:"vue通过rollup构建工具构建出来的版本有哪些，都有什么差别",keywords:"vue源码，构建，esmodule版，commonjs版，全版本，运行时，runtime，compiler，编译器版本",labels:[f],date:"2021-08-12",path:"2021\u002F08\u002Fvue-built-version.md",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2021\u002F08\u002F12\u002FgPNOFU8ycMaV9Jh.png\" alt=\"图 2\" \u003E\u003C\u002Fdiv\u003E  \u003C\u002Fp\u003E\n\u003Ch3 id=\"vue构建版本\"\u003EVue构建版本\u003C\u002Fh3\u003E\n\u003Cp\u003Evue构建的版本好多，可以从上图看到。从源码的构建上了解vue构建的版本。\u003C\u002Fp\u003E\n\u003Cp\u003E从\u003Ccode\u003E\u002Fscripts\u002Fconfig.js\u003C\u002Fcode\u003E中看到，\u003Ccode\u003Ebuilds\u003C\u002Fcode\u003E常量定义了各个构建版本的配置。比如：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-string\"\u003E&#x27;web-runtime-cjs-dev&#x27;\u003C\u002Fspan\u003E: {\n  entry: \u003Cspan class=\"hljs-built_in\"\u003Eresolve\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&#x27;web\u002Fentry-runtime.js&#x27;\u003C\u002Fspan\u003E),\n  des\u003Cspan class=\"hljs-variable\"\u003Et:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eresolve\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&#x27;dist\u002Fvue.runtime.common.dev.js&#x27;\u003C\u002Fspan\u003E),\n  forma\u003Cspan class=\"hljs-variable\"\u003Et:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;cjs&#x27;\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-keyword\"\u003Een\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-variable\"\u003Ev:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;development&#x27;\u003C\u002Fspan\u003E,\n  banner\n},\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E表示要构建出cjs格式的vue源码。而\u003Ccode\u003Eweb-runtime\u003C\u002Fcode\u003E也表示了只构建出runtime版本的vue源码。\u003Ccode\u003E-dev\u003C\u002Fcode\u003E则表示不会进行代码压缩，构建出来的版本属于开发版本。\u003C\u002Fp\u003E\n\u003Cp\u003E除了上面列举的第一个外，还有：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-runtime-cjs-prod\u003C\u002Fcode\u003E。 构建【web平台、commonjs、runtime、生产版】源码；对应输出的文件为：\u003Ccode\u003Edist\u002Fvue.runtime.common.prod.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-full-cjs-dev\u003C\u002Fcode\u003E。 构建【web平台、commonjs、runtime、compiler、开发版】源码；对应输出的文件为：\u003Ccode\u003Edist\u002Fvue.common.dev.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-full-cjs-prod\u003C\u002Fcode\u003E。 构建【web平台、commonjs、runtime、compiler、生产版】源码；对应输出的文件为：\u003Ccode\u003Edist\u002Fvue.common.prod.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-runtime-esm\u003C\u002Fcode\u003E。 构建【web平台、esmodule、runtime】源码；对应输出的文件为：\u003Ccode\u003Edist\u002Fvue.esm.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-full-esm\u003C\u002Fcode\u003E。 构建【web平台、esmodule、runtime、compiler】源码；对应输出的文件为：\u003Ccode\u003Edist\u002Fvue.esm.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-full-esm-browser-dev\u003C\u002Fcode\u003E。 构建【web平台、esmodule、runtime、compiler、浏览器直接引入、开发版】源码；对应输出的文件为：\u003Ccode\u003Edist\u002Fvue.esm.browser.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-full-esm-browser-prod\u003C\u002Fcode\u003E。 构建【web平台、esmodule、runtime、compiler、浏览器直接引入、生产版】源码；对应输出的文件为：\u003Ccode\u003Edist\u002Fvue.esm.browser.min.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-runtime-dev\u003C\u002Fcode\u003E。 构建【web平台、runtime、umd、开发版】源码；对应输出的文件为：\u003Ccode\u003Edist\u002Fvue.runtime.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-runtime-prod\u003C\u002Fcode\u003E。 构建【web平台、runtime、umd、生产版】源码；对应输出的文件为：\u003Ccode\u003Edist\u002Fvue.runtime.min.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-full-dev\u003C\u002Fcode\u003E。 构建【web平台、runtime、umd、compiler、开发版】源码；对应输出的文件为：\u003Ccode\u003Edist\u002Fvue.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-full-prod\u003C\u002Fcode\u003E。 构建【web平台、runtime、umd、compiler、生产版】源码；对应输出的文件为：\u003Ccode\u003Edist\u002Fvue.min.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-compiler\u003C\u002Fcode\u003E。 构建【web平台、commonjs、compiler】源码；对应输出的文件为：\u003Ccode\u003Epackages\u002Fvue-template-compiler\u002Fbuild.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-compiler-browser\u003C\u002Fcode\u003E。 构建【web平台、commonjs、compiler】源码；对应输出的文件为：\u003Ccode\u003Epackages\u002Fvue-template-compiler\u002Fbrowser.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-server-renderer-dev\u003C\u002Fcode\u003E。 构建【服务端、commonjs、开发版】源码；对应输出的文件为：\u003Ccode\u003Epackages\u002Fvue-server-renderer\u002Fbuild.dev.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-server-renderer-prod\u003C\u002Fcode\u003E。 构建【服务端、commonjs、生产版】源码；对应输出的文件为：\u003Ccode\u003Epackages\u002Fvue-server-renderer\u002Fbuild.prod.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-server-renderer-basic\u003C\u002Fcode\u003E。 构建【服务端、umd、basic版】源码；对应输出的文件为：\u003Ccode\u003Epackages\u002Fvue-server-renderer\u002Fbasic.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-server-renderer-webpack-server-plugin\u003C\u002Fcode\u003E。 构建【服务端、commonjs、服务端插件版】源码；对应输出的文件为：\u003Ccode\u003Epackages\u002Fvue-server-renderer\u002Fserver-plugin.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eweb-server-renderer-webpack-client-plugin\u003C\u002Fcode\u003E。 构建【服务端、commonjs、客户端插件版】源码；对应输出的文件为：\u003Ccode\u003Epackages\u002Fvue-server-renderer\u002Fclient-plugin.js\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"版本区别\"\u003E版本区别\u003C\u002Fh2\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003E\u003C\u002Fth\u003E\n\u003Cth\u003EUMD\u003C\u002Fth\u003E\n\u003Cth\u003ECommonJS\u003C\u002Fth\u003E\n\u003Cth\u003EES Module\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\n\u003Ctd\u003E\u003Cstrong\u003E全版本\u003C\u002Fstrong\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003Evue.js\u003C\u002Ftd\u003E\n\u003Ctd\u003Evue.common.js\u003C\u002Ftd\u003E\n\u003Ctd\u003Evue.esm.js\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Cstrong\u003E只包含运行时\u003C\u002Fstrong\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003Evue.runtime.js\u003C\u002Ftd\u003E\n\u003Ctd\u003Evue.runtime.common.js\u003C\u002Ftd\u003E\n\u003Ctd\u003Evue.runtime.esm.js\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Cstrong\u003E全版本（生产版）\u003C\u002Fstrong\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003Evue.min.js\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Cstrong\u003E只包含运行时（生产版）\u003C\u002Fstrong\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003Evue.runtime.min.js\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EFull\u003C\u002Fstrong\u003E: 包含了编译器和运行时。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003ECompiler\u003C\u002Fstrong\u003E: 编译版本。可以把template字符串代码编译为javascript render函数。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003ERuntime\u003C\u002Fstrong\u003E: 用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fumdjs\u002Fumd\"\u003EUMD\u003C\u002Fa\u003E\u003C\u002Fstrong\u003E: UMD 版本可以通过\u003Ccode\u003Escript\u003C\u002Fcode\u003E标签直接用在浏览器中。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003E\u003Ca target='_blank'  href=\"http:\u002F\u002Fwiki.commonjs.org\u002Fwiki\u002FModules\u002F1.1\"\u003ECommonJS\u003C\u002Fa\u003E\u003C\u002Fstrong\u003E: CommonJS 版本用来配合老的打包工具比如 Browserify 或 webpack 1。这些打包工具的默认文件 (pkg.main) 是只包含运行时的 CommonJS 版本 (vue.runtime.common.js)。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003E\u003Ca target='_blank'  href=\"http:\u002F\u002Fexploringjs.com\u002Fes6\u002Fch_modules.html\"\u003EES Module\u003C\u002Fa\u003E\u003C\u002Fstrong\u003E: ES module版本提供给现代的打包工具，比如webpack2、rollup。为这些打包工具提供的默认文件 (pkg.module) 是只有运行时的 ES Module 构建 (vue.runtime.esm.js)\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E一般也是要用运行时的版本，运行时版本只占用全版本提及的30%。我们在使用webpack的vue-loader工具最后到网页的呈现时，用的就是运行时的版本，\u003Ccode\u003E*.vue\u003C\u002Fcode\u003E 文件内部的模板会在构建时预编译成 JavaScript render函数。\u003C\u002Fp\u003E\n"},{title:"博客或许不需要评论系统",slug:"2021_08_no-need-comment",description:"自建的博客觉得还是不需要添加评论模块",keywords:"blog，comment",labels:["杂谈"],date:"2021-08-10",path:"2021\u002F08\u002Fno-need-comment.md",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2021\u002F08\u002F10\u002FeyAvOuNDMq4WC8K.jpg\" alt=\"图 2\" \u003E\u003C\u002Fdiv\u003E  \u003C\u002Fp\u003E\n\u003Cp\u003E从开始写博客以来，就换了很多的构建静态页面的工具。期间都会遇到是否需要在自己的文章里面增加评论模块的问题。之前就用过valine还有github的issue作为评论模块，后面自建静态博客后就把评论的模块删除了。再想了一想，其实个人的博客并不需要评论。\u003C\u002Fp\u003E\n\u003Ch2 id=\"-写博客目的\"\u003E\u003Ca name=\"purpose\"\u003E\u003C\u002Fa\u003E 写博客目的\u003C\u002Fh2\u003E\n\u003Cp\u003E个人而言，主要是单方面的把自己的想法写出来，并不期待着能吸引多少阅读者前来。即使在现在或者今后文章的内容质量不高，我也是会很开心的把这种记录永远放在互联网上。当然如果能给阅读者带来一些思考或者帮助，还是能够找到一些额外的价值的。\u003C\u002Fp\u003E\n\u003Ch2 id=\"移除评论\"\u003E移除评论\u003C\u002Fh2\u003E\n\u003Cp\u003E决定还是不再需要评论模块。我想到的评论能带来的好处是可以和文章的编写者进行一些问题交流，这在个人的博客中觉得重要程度不是很大。开放的\n评论内容也不是每个人都需要的内容。而且我会在文章末尾增加个人联系的方式，如果有任何疑问还是可以进行交流的。移除评论，还可以：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E减少不必要的内容出现。\u003C\u002Fli\u003E\n\u003Cli\u003E不再需要维护评论模块存储内容和运行情况。\u003C\u002Fli\u003E\n\u003Cli\u003E增加静态页面的资源加载速度，提高访问流畅性，这在github pages上好处更大。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"},{title:"g102鼠标微动更换",slug:"2021_08_mouse-switch",description:"g102鼠标双击了，然后听说可以自己更换微动，所以就动手换了。",keywords:"g102,mouse,switch,double click",labels:["动手"],date:"2021-08-09",path:"2021\u002F08\u002Fmouse-switch.md",html:"\u003Cp\u003E不久前，办公用的鼠标g102出现双击现象。一开始还不是很明显，后面在打开文件夹和写代码的时候比较影响，最主要的可感知到的问题是双击会选中代码光标所在的整个单词。\u003C\u002Fp\u003E\n\u003Cp\u003E遂网上搜索了一下g102双击的问题，一查发现这个是通病，好的话大概会过保才会双击。不好的话没几个月就会了，（这没过保的时候坏了更好吧。。。）。同时搜索到可以自行\n更换微动的方式解决这个问题，但需要焊锡工具。\u003C\u002Fp\u003E\n\u003Cp\u003E得勒，二话不说直接买。\u003C\u002Fp\u003E\n\u003Ch3 id=\"工具\"\u003E工具\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003E螺丝刀\u003C\u002Fli\u003E\n\u003Cli\u003E微动，价格8元\u003C\u002Fli\u003E\n\u003Cli\u003E电烙铁，价格8元\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"过程\"\u003E过程\u003C\u002Fh3\u003E\n\u003Cp\u003E拆开鼠标还是很容易，注意需要小心的是不要弄坏电路板。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2021\u002F08\u002F09\u002F7vAPh1WydOteRTL.jpg\" alt=\"微动模块\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E主要的过程是需要小心翼翼的拆开微动模块，因为有三个焊锡点，所以需要细心处理。\u003C\u002Fp\u003E\n\u003Cp\u003E千万小心不要像我一样被烫伤。\u003C\u002Fp\u003E\n\u003Cp\u003E安装好后，可以先连上电脑试试可不可以再装回螺丝。\u003C\u002Fp\u003E\n"},{title:"Git提交信息格式化（规范）",slug:"2021_08_git-commit-format",description:"git信息提交规范，参考angular的提交规范去约束",keywords:"git，commit message,format,angular",labels:["git"],date:"2021-08-08",path:"2021\u002F08\u002Fgit-commit-format.md",html:"\u003Ch2 id=\"git-提交信息格式\"\u003EGit 提交信息格式\u003C\u002Fh2\u003E\n\u003Cp\u003E每一条提交的记录信息由\u003Ccode\u003Eheader\u003C\u002Fcode\u003E、\u003Ccode\u003Ebody\u003C\u002Fcode\u003E、\u003Ccode\u003Efooter\u003C\u002Fcode\u003E组成。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-section\"\u003E&lt;header&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-section\"\u003E&lt;BLANK LINE&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-section\"\u003E&lt;body&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-section\"\u003E&lt;BLANK LINE&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-section\"\u003E&lt;footer&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003Eheader是强制性的，需要符合header的规则约束。\u003C\u002Fp\u003E\n\u003Cp\u003E除了“docs”类型的提交外，所有提交都必须使用body。当正文出现时，它必须至少有20个字符长，并且必须符合提交消息正文格式。\u003C\u002Fp\u003E\n\u003Cp\u003Efooter是可选的。\u003C\u002Fp\u003E\n\u003Ch3 id=\"header\"\u003Eheader\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-variable\"\u003E&lt;type&gt;\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-variable\"\u003E&lt;scope&gt;\u003C\u002Fspan\u003E): \u003Cspan class=\"hljs-variable\"\u003E&lt;short summary&gt;\u003C\u002Fspan\u003E\n  │       │             │\n  │       │             └─⫸ 没有大写，结尾不需要句号\n  │       │\n  │       └─⫸ Commit Scope: 内定\n  │\n  └─⫸ Commit Type: build|\u003Cspan class=\"hljs-string\"\u003Eci\u003C\u002Fspan\u003E|\u003Cspan class=\"hljs-string\"\u003Edocs\u003C\u002Fspan\u003E|\u003Cspan class=\"hljs-string\"\u003Efeat\u003C\u002Fspan\u003E|\u003Cspan class=\"hljs-string\"\u003Efix\u003C\u002Fspan\u003E|\u003Cspan class=\"hljs-string\"\u003Eperf\u003C\u002Fspan\u003E|\u003Cspan class=\"hljs-string\"\u003Erefactor\u003C\u002Fspan\u003E|test\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E⚠️ type、summary是强制性要求，scope是可选的。\u003C\u002Fp\u003E\n\u003Ch4 id=\"type\"\u003Etype\u003C\u002Fh4\u003E\n\u003Cp\u003E必须是取下面之一:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003Ebuild\u003C\u002Fstrong\u003E: 修改的内容影响构建功能或者外部的依赖（例如：gulp、broccoli、npm）\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003Eci\u003C\u002Fstrong\u003E: 修改了CI配置和脚本（例如：Circle、BrowserStack、GitlabCI）\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003Edocs\u003C\u002Fstrong\u003E: 文档修改\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003Efeat\u003C\u002Fstrong\u003E: 新增功能\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003Efix\u003C\u002Fstrong\u003E: bug修复\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003Eperf\u003C\u002Fstrong\u003E: 用于性能提升的修改\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003Erefactor\u003C\u002Fstrong\u003E: 此修改既不是bug修复，也不是功能的新增\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003Etest\u003C\u002Fstrong\u003E: 关乎测试相关的内容修改\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch4 id=\"scope\"\u003Escope\u003C\u002Fh4\u003E\n\u003Cp\u003E可以理解为修改的作用范围，这一项是根据当前项目所决定的。可以自行确定。确定的规则是思考当前的修改到底影响的是哪一些模块。\u003C\u002Fp\u003E\n\u003Ch4 id=\"summary\"\u003Esummary\u003C\u002Fh4\u003E\n\u003Cp\u003E简要概述。注意\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E使用的是现在时的语法，例如是“修改”，而不是“修改了”。\u003C\u002Fli\u003E\n\u003Cli\u003E首字母不要大写，适用于英文。\u003C\u002Fli\u003E\n\u003Cli\u003E句末不需要增加分号（\u003Ccode\u003E。\u003C\u002Fcode\u003E\u002F\u003Ccode\u003E.\u003C\u002Fcode\u003E）。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"body\"\u003Ebody\u003C\u002Fh3\u003E\n\u003Cp\u003E和summary一样，使用的是现在时的语法，例如是“修改”，而不是“修改了”。\u003C\u002Fp\u003E\n\u003Cp\u003E在提交消息体中解释更改的原因。提交消息应该解释为什么要进行这个更改。可以包含旧内容和新内容的比较，用于辅助解释修改的影响。\u003C\u002Fp\u003E\n\u003Ch3 id=\"footer\"\u003Efooter\u003C\u002Fh3\u003E\n\u003Cp\u003E页脚可以包含关于重大更新的内容，也是引用GitHub issue、Jira和其他链接。\u003C\u002Fp\u003E\n\u003Ch3 id=\"例子\"\u003E例子\u003C\u002Fh3\u003E\n\u003Cp\u003E查看\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fangular\u002Fangular\"\u003EAngular\u003C\u002Fa\u003E源代码仓库，使用的提交规则清一色的符合上述情况。\u003C\u002Fp\u003E\n\u003Cp\u003E可以看到，提交信息的内容基本都是以动词开始。\u003C\u002Fp\u003E\n"},{title:"lodash数组中difference方法",slug:"2021_08_lodash-array-difference",description:"lodash中difference、differenceBy、differenceWith方法的使用以及分析",keywords:"lodash，difference，differenceBy，differenceWith，数组，源码分析,每天一个lodash函数",labels:[g],date:"2021-08-06",path:"2021\u002F08\u002Flodash-array-difference.md",html:"\u003Ch2 id=\"difference\"\u003EDifference\u003C\u002Fh2\u003E\n\u003Cp\u003E创建一个具有唯一array值的数组，每个值不包含在其他给定的数组中。（注：即创建一个新数组，这个数组中的值，为第一个数字（array 参数）排除了给定数组中的值。）该方法使用SameValueZero做相等比较。结果值的顺序是由第一个数组中的顺序确定。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-attribute\"\u003E_\u003C\u002Fspan\u003E.difference([\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E],\u003Cspan class=\"hljs-meta\"\u003E [4, 2])\n\u002F\u002F [3, 1]\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"理解\"\u003E理解\u003C\u002Fh3\u003E\n\u003Cp\u003E对这个用法，可以理解为抽出属于第一个参数而不属于第二个参数的值。\u003C\u002Fp\u003E\n\u003Cp\u003E其中有一个SamealueZero的匹配规则，大致的规则如下：\n例如比较x、y\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E如果x与y不同，返回false\u003C\u002Fli\u003E\n\u003Cli\u003E如果x为数值，则\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cul\u003E\n\u003Cli\u003E如果x是NaN，y也是NaN，返回true\u003C\u002Fli\u003E\n\u003Cli\u003E如果x是-0，y是+0，返回true\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"源码\"\u003E源码\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Edifference\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(array, \u003Cspan class=\"hljs-rest_arg\"\u003E...values\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E isArrayLikeObject(array)\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F baseFlatten用于拍平数组\u003C\u002Fspan\u003E\n    ? baseDifference(array, baseFlatten(values, \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, isArrayLikeObject, \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E))\n    : []\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这函数调用的起飞阿，我分析lodash函数的代码，还得刨到底。\u003C\u002Fp\u003E\n\u003Ch4 id=\"isarraylikeobject\"\u003EisArrayLikeObject\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这个函数和isArrayLike差不多，但它会另外的检查传入的value是否为object\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 总之可以模糊的说用于判断是否是可迭代的类型\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E is\u003Cspan class=\"hljs-constructor\"\u003EArrayLikeObject(\u003Cspan class=\"hljs-params\"\u003Evalue\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n  return is\u003Cspan class=\"hljs-constructor\"\u003EObjectLike(\u003Cspan class=\"hljs-params\"\u003Evalue\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-operator\"\u003E &amp;&amp; \u003C\u002Fspan\u003Eis\u003Cspan class=\"hljs-constructor\"\u003EArrayLike(\u003Cspan class=\"hljs-params\"\u003Evalue\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n}\n\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 1 \u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 用以判断传入的值是否为对象类型，因为typeof null === &#x27;object&#x27;，所以要增加一个判断\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E is\u003Cspan class=\"hljs-constructor\"\u003EObjectLike(\u003Cspan class=\"hljs-params\"\u003Evalue\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n  return typeof value\u003Cspan class=\"hljs-operator\"\u003E === \u003C\u002Fspan\u003E&#x27;\u003Cspan class=\"hljs-keyword\"\u003Eobject\u003C\u002Fspan\u003E&#x27;\u003Cspan class=\"hljs-operator\"\u003E &amp;&amp; \u003C\u002Fspan\u003Evalue !== null\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 2\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 由isLength判断value长度的方式来判断传入的value是否为ArrayLike\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E is\u003Cspan class=\"hljs-constructor\"\u003EArrayLike(\u003Cspan class=\"hljs-params\"\u003Evalue\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n  return value != null\u003Cspan class=\"hljs-operator\"\u003E &amp;&amp; \u003C\u002Fspan\u003Etypeof value !== &#x27;\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E&#x27;\u003Cspan class=\"hljs-operator\"\u003E &amp;&amp; \u003C\u002Fspan\u003Eis\u003Cspan class=\"hljs-constructor\"\u003ELength(\u003Cspan class=\"hljs-params\"\u003Evalue\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-params\"\u003Elength\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 3\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 判断传入的长度值是否有效！\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 有效的条件：大于-1 并且 任意整数 并且是安全整数（能够准确区分两个不相同的值）\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E is\u003Cspan class=\"hljs-constructor\"\u003ELength(\u003Cspan class=\"hljs-params\"\u003Evalue\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n  return typeof value\u003Cspan class=\"hljs-operator\"\u003E === \u003C\u002Fspan\u003E&#x27;number&#x27;\u003Cspan class=\"hljs-operator\"\u003E &amp;&amp;\n    \u003C\u002Fspan\u003Evalue &gt; -\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-operator\"\u003E &amp;&amp; \u003C\u002Fspan\u003Evalue % \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-operator\"\u003E == \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-operator\"\u003E &amp;&amp; \u003C\u002Fspan\u003Evalue &lt;= MAX_SAFE_INTEGER\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch4 id=\"basedifference\"\u003EbaseDifference\u003C\u002Fh4\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F iteratee在此（difference函数）调用默认为\u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E\nfunction baseDifference(\u003Cspan class=\"hljs-built_in\"\u003Earray\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-built_in\"\u003Evalues\u003C\u002Fspan\u003E, iteratee, comparator) {\n  \u002F\u002F arrayIncludes(\u003Cspan class=\"hljs-built_in\"\u003Earray\u003C\u002Fspan\u003E, value)\n  \u002F\u002F 判断value是否在\u003Cspan class=\"hljs-built_in\"\u003Earray\u003C\u002Fspan\u003E中\n  \u003Cspan class=\"hljs-built_in\"\u003Elet\u003C\u002Fspan\u003E includes = arrayIncludes\n  \u003Cspan class=\"hljs-built_in\"\u003Elet\u003C\u002Fspan\u003E isCommon = \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E\n  const result = []\n  const valuesLength = \u003Cspan class=\"hljs-built_in\"\u003Evalues\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-built_in\"\u003Elength\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!\u003Cspan class=\"hljs-built_in\"\u003Earray\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-built_in\"\u003Elength\u003C\u002Fspan\u003E) {\n    \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E result\n  }\n  \u002F\u002F 这几处暂时不需要理解\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (iteratee) {\n    \u003Cspan class=\"hljs-built_in\"\u003Evalues\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-built_in\"\u003Emap\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-built_in\"\u003Evalues\u003C\u002Fspan\u003E, (value) =&gt; iteratee(value))\n  }\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (comparator) {\n    includes = arrayIncludesWith\n    isCommon = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E\n  }\n  \u002F\u002F lodash中该值定义为LARGE_ARRAY_SIZE = \u003Cspan class=\"hljs-number\"\u003E200\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-built_in\"\u003Evalues\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-built_in\"\u003Elength\u003C\u002Fspan\u003E &gt;= LARGE_ARRAY_SIZE) {\n    \u002F\u002F cacheHas这个函数用于判断某个\u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E是否在cache中\n    includes = cacheHas\n    isCommon = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-built_in\"\u003Evalues\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E SetCache(\u003Cspan class=\"hljs-built_in\"\u003Evalues\u003C\u002Fspan\u003E)\n  }\n\n  \u002F\u002F labeled statement\n  \u002F\u002F 严格模式下不能使用 https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FStatements\u002F\u003Cspan class=\"hljs-built_in\"\u003Elabel\u003C\u002Fspan\u003E\n  \u002F\u002F 用于跳过某些遍历\n\n  outer:\n  \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-built_in\"\u003Elet\u003C\u002Fspan\u003E value of \u003Cspan class=\"hljs-built_in\"\u003Earray\u003C\u002Fspan\u003E) {\n    const computed = iteratee == null ? value : iteratee(value)\n\n    value = (comparator || value !== \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E) ? value : \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (isCommon &amp;&amp; computed === computed) {\n      \u003Cspan class=\"hljs-built_in\"\u003Elet\u003C\u002Fspan\u003E valuesIndex = valuesLength\n      \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E (valuesIndex--) {\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-built_in\"\u003Evalues\u003C\u002Fspan\u003E[valuesIndex] === computed) {\n          continue outer\n        }\n      }\n      result.\u003Cspan class=\"hljs-built_in\"\u003Epush\u003C\u002Fspan\u003E(value)\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!includes(\u003Cspan class=\"hljs-built_in\"\u003Evalues\u003C\u002Fspan\u003E, computed, comparator)) {\n      result.\u003Cspan class=\"hljs-built_in\"\u003Epush\u003C\u002Fspan\u003E(value)\n    }\n  }\n  \u003Cspan class=\"hljs-built_in\"\u003Ereturn\u003C\u002Fspan\u003E result\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"},{title:m,slug:"2021_08_vue-docker-buildkit",description:m,keywords:"docker，vue，buildkit，体积，缓存",labels:[h],date:"2021-08-03",path:"2021\u002F08\u002Fvue-docker-buildkit.md",html:"\u003Ch2 id=\"使用dockerfile去打包一个vue项目镜像\"\u003E使用Dockerfile去打包一个vue项目镜像\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Evue \u003Cspan class=\"hljs-meta\"\u003Ecreate\u003C\u002Fspan\u003E hello-world\ncd hello-world \u003Cspan class=\"hljs-variable\"\u003E&amp;&amp;\u003C\u002Fspan\u003E touch Dockerfile\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EDockerfile内容\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-keyword\"\u003EFROM\u003C\u002Fspan\u003E node:lts-alpine\n\u003Cspan class=\"hljs-keyword\"\u003ERUN\u003C\u002Fspan\u003E\u003Cspan class=\"bash\"\u003E npm install -g http-server\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003EWORKDIR\u003C\u002Fspan\u003E\u003Cspan class=\"bash\"\u003E \u002Fapp\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003ECOPY\u003C\u002Fspan\u003E\u003Cspan class=\"bash\"\u003E package*.json .\u002F\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003ERUN\u003C\u002Fspan\u003E\u003Cspan class=\"bash\"\u003E npm install \u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003ECOPY\u003C\u002Fspan\u003E\u003Cspan class=\"bash\"\u003E . .\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003ERUN\u003C\u002Fspan\u003E\u003Cspan class=\"bash\"\u003E npm run build\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003EEXPOSE\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E8080\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003ECMD\u003C\u002Fspan\u003E\u003Cspan class=\"bash\"\u003E [\u003Cspan class=\"hljs-string\"\u003E&quot;http-server&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E&quot;dist&quot;\u003C\u002Fspan\u003E]\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"镜像构建与容器运行\"\u003E镜像构建与容器运行\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker build -t vue:demo . \u003Cspan class=\"hljs-comment\"\u003E# 构建镜像\u003C\u002Fspan\u003E\ndocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-keyword\"\u003Eit\u003C\u002Fspan\u003E -d -P vue:demo\ndocker container ls \u003Cspan class=\"hljs-comment\"\u003E# 查看映射的端口\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E查看生成的镜像大小为：287MB。\u003C\u002Fp\u003E\n\u003Ch3 id=\"使用buildkit优化镜像体积\"\u003E使用buildkit优化镜像体积\u003C\u002Fh3\u003E\n\u003Cp\u003E新的Dockerfile\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-comment\"\u003E# systax = docker\u002Fdockerfile:experimental\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003EFROM\u003C\u002Fspan\u003E node:lts-alpine\n\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E npm install -g http-server\nWORKDIR \u002Fapp\nCOPY package*.json .\u002F\n\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attribute\"\u003E--mount\u003C\u002Fspan\u003E=type=cache,target=\u002Fapp\u002Fnode_modules,id=my_app_npm_module,sharing=locked\\\n    \u003Cspan class=\"hljs-attribute\"\u003E--mount\u003C\u002Fspan\u003E=type=cache,target=\u002Froot\u002F.npm,id=npm_cache \\\n    npm install \nCOPY . .\n\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attribute\"\u003E--mount\u003C\u002Fspan\u003E=type=cache,target=\u002Fapp\u002Fnode_modules,id=my_app_npm_module,sharing=locked \\\n    # \u003Cspan class=\"hljs-attribute\"\u003E--mount\u003C\u002Fspan\u003E=type=cache,target=\u002Fapp\u002Fdist,id=my_app_dist,sharing=locked \\\n    npm \u003Cspan class=\"hljs-builtin-name\"\u003Erun\u003C\u002Fspan\u003E build\nEXPOSE 8080\nCMD [\u003Cspan class=\"hljs-string\"\u003E&quot;http-server&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E&quot;dist&quot;\u003C\u002Fspan\u003E]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"构建镜像\"\u003E构建镜像\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-attribute\"\u003EDOCKER_BUILDKIT\u003C\u002Fspan\u003E=1 docker build -t vue:buildx .\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E对比查看，tag为buildx的镜像体积为：124MB。\u003C\u002Fp\u003E\n\u003Cp\u003E体积减少了一半，是用buildkit对node_modules进行缓存处理。\u003C\u002Fp\u003E\n"},{title:"记一次Maximum call stack size exceeded error",slug:"2021_07_Maximum-call-stack-size-exceeded-error",description:"vue开发项目中出现Maximum call stack size exceeded error错误，仔细看了错误信息，查找了一些资料都没有解决。",keywords:"Maximu-call-stack-size-exceeded-error，vue，prettier，cicd，local，production",labels:[f],date:"2021-07-31",path:"2021\u002F07\u002FMaximum-call-stack-size-exceeded-error.md",html:"\u003Cp\u003E一次在ci打包编译vue项目，上线到测试环境后出现了Maximum call stack size exceeded error错误。\u003C\u002Fp\u003E\n\u003Cp\u003E这个错误意思是堆栈溢出。本地环境无任何这样的问题，但经过ci跑完之后就出现这个问题。\n错误提示指向了打包后的js文件，由于代码压缩uglifyjs，所以直接是看不到错误根源的。在搜索了相关的资料后，有提到是vue单页面组件中存在重复定义的变量。但我有引用lint工具，如果出现这样但情况git提交是无法顺利进行的。\u003C\u002Fp\u003E\n\u003Ch2 id=\"切换部署代码\"\u003E切换部署代码\u003C\u002Fh2\u003E\n\u003Cp\u003E把部署到测试环境的代码回退到上一个tag，意在排除是代码的问题。结果回退到上一个tag后，经过ci部署，线上仍旧出现这个情况。\u003C\u002Fp\u003E\n\u003Cp\u003E经过一步步推测，觉得就是在打包编译的过程中出现了问题。\u003C\u002Fp\u003E\n\u003Ch2 id=\"问题原因\"\u003E问题原因\u003C\u002Fh2\u003E\n\u003Cp\u003E在ci到log日志中，发现代码在build的过程中，prettier出现了不少的错误。所以根源就在于本地和docker镜像中的项目build所需要的某个package出现异常。\n而异常就应该出现在prettier上。\u003C\u002Fp\u003E\n\u003Ch2 id=\"问题处理\"\u003E问题处理\u003C\u002Fh2\u003E\n\u003Cp\u003E要是出自某个package上，只能是package的版本不一致导致的。在package.json中，看到版本：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-json\"\u003E\u003Cspan class=\"hljs-string\"\u003E&quot;prettier&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;^2.0.2&quot;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这个版本符号&quot;^&quot;是插入符号，这会安装当前的主要版本，例如上面的版本的话，会更新到2.x.x最新的版本。这就会可能引起版本的不一致。\u003C\u002Fp\u003E\n\u003Cp\u003E把这个符号移除掉，固定版本号之后，ci也不会出现问题，上线就恢复正常了。\u003C\u002Fp\u003E\n\u003Ch2 id=\"packagejson版本总结\"\u003Epackage.json版本总结\u003C\u002Fh2\u003E\n\u003Cp\u003Epackage.json中的版本号有3个位。例如：\u003Ccode\u003E1.12.2\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E从左到右，第一个数字为主版本号（marjor version），第二个数字为次版本号（minor version），第三个数字为补丁版本号（patch version）。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003E~\u003C\u002Fcode\u003E: 更新中间数字的最新版本。如\u003Ccode\u003E~1.3.1\u003C\u002Fcode\u003E会更新1.3.x最新版本。\n\u003Ccode\u003E^\u003C\u002Fcode\u003E: 更新第一个数字但最新版本。如\u003Ccode\u003E^1.3.1\u003C\u002Fcode\u003E会更新1.x.x最新版本。\u003C\u002Fp\u003E\n"},{title:"Dockerfile的一些用法记录",slug:"2021_07_dockerfile",description:"Dockerfile的作用，怎么用Dockerfile构建镜像，docker使用",keywords:"Dockerfile，FROM，RUN，COPY，ADD，CMD，ENTRYPOINT，ENV，ARG，VOLUME，EXPOSE，WORKDIR",labels:[h],date:n,path:"2021\u002F07\u002Fdockerfile.md",html:"\u003Cp\u003E对于docker镜像的制作和compose的使用等就在这进行记录，便于学习理解和记忆使用。\u003C\u002Fp\u003E\n\u003Ch2 id=\"定制镜像\"\u003E定制镜像\u003C\u002Fh2\u003E\n\u003Ch2 id=\"dockerfile\"\u003EDockerfile\u003C\u002Fh2\u003E\n\u003Cp\u003EDockerfile就当作是一个脚本文件，包含了一系列的指令用于构建每一层镜像。\u003C\u002Fp\u003E\n\u003Cp\u003E举例一个定制nginx镜像:\u003C\u002Fp\u003E\n\u003Cp\u003E新建一个Dockerfile文件，内容：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-keyword\"\u003EFROM\u003C\u002Fspan\u003E nginx\nRUN echo \u003Cspan class=\"hljs-string\"\u003E&#x27;&lt;h1&gt;Hello, Docker!&lt;\u002Fh1&gt;&#x27;\u003C\u002Fspan\u003E &gt; \u003Cspan class=\"hljs-regexp\"\u003E\u002Fusr\u002F\u003C\u002Fspan\u003Eshare\u003Cspan class=\"hljs-regexp\"\u003E\u002Fnginx\u002F\u003C\u002Fspan\u003Ehtml\u002Findex.html\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"from\"\u003EFROM\u003C\u002Fh3\u003E\n\u003Cp\u003E指定基础镜像，在这个基础镜像的基础上进行定制。上面的基础镜像就是nginx。如果不以任何镜像为基础进行定制，则可以指定一个空白镜像\u003Ccode\u003Escratch\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-selector-tag\"\u003EFROM\u003C\u002Fspan\u003E scratch\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"run\"\u003ERUN\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003Eshell格式，直接RUN + 命令的方式。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Eexec格式，RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E由于每一个RUN指令都会建立一层镜像，所以具有同一个目的的命令应该写在一个RUN里。不要用RUN当作shell命令去写。\u003C\u002Fp\u003E\n\u003Cp\u003E如：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E yarn install\n\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E yarn build\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E可以修改为：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E yarn install &amp;&amp; yarn build\n\u003Cspan class=\"hljs-comment\"\u003E# 如果指令长，可以换行和缩进\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E yarn install \\\n    &amp;&amp; yarn build\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E最后也是需要记住的重要的事情是需要在每一层的构建后需要清理掉与镜像无关的文件内容。\u003C\u002Fp\u003E\n\u003Ch3 id=\"构建镜像\"\u003E构建镜像\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker build -t nginx:v3 .\n\nSending build context \u003Cspan class=\"hljs-keyword\"\u003Eto\u003C\u002Fspan\u003E Docker daemon  \u003Cspan class=\"hljs-number\"\u003E2.048\u003C\u002Fspan\u003EkB # 发送构建的上下文到docker引擎（上下文为命令中的 .）\nStep \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\u002F\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E : FROM nginx\nlates\u003Cspan class=\"hljs-variable\"\u003Et:\u003C\u002Fspan\u003E Pulling from library\u002Fnginx\n\u003Cspan class=\"hljs-number\"\u003E33847\u003C\u002Fspan\u003Ef680f63: Pull \u003Cspan class=\"hljs-built_in\"\u003Ecomplete\u003C\u002Fspan\u003E \ndbb907d5159d: Pull \u003Cspan class=\"hljs-built_in\"\u003Ecomplete\u003C\u002Fspan\u003E \n\u003Cspan class=\"hljs-number\"\u003E8\u003C\u002Fspan\u003Ea268f30c42\u003Cspan class=\"hljs-variable\"\u003Ea:\u003C\u002Fspan\u003E Pull \u003Cspan class=\"hljs-built_in\"\u003Ecomplete\u003C\u002Fspan\u003E \nb10cf527a02d: Pull \u003Cspan class=\"hljs-built_in\"\u003Ecomplete\u003C\u002Fspan\u003E \nc90b090c213\u003Cspan class=\"hljs-variable\"\u003Eb:\u003C\u002Fspan\u003E Pull \u003Cspan class=\"hljs-built_in\"\u003Ecomplete\u003C\u002Fspan\u003E \n\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003Ef41b2f2bf94: Pull \u003Cspan class=\"hljs-built_in\"\u003Ecomplete\u003C\u002Fspan\u003E \nDiges\u003Cspan class=\"hljs-variable\"\u003Et:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Esha256\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-number\"\u003E8\u003C\u002Fspan\u003Ef335768880da6baf72b70c701002b45f4932acae8d574dedfddaf967fc3ac90\nStatu\u003Cspan class=\"hljs-variable\"\u003Es:\u003C\u002Fspan\u003E Downloaded newer image \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E nginx:latest\n ---&gt; \u003Cspan class=\"hljs-number\"\u003E08\u003C\u002Fspan\u003Eb152afcfae\nStep \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E\u002F\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E : RUN \u003Cspan class=\"hljs-keyword\"\u003Eecho\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;&lt;h1&gt;Hello, Docker!&lt;\u002Fh1&gt;&#x27;\u003C\u002Fspan\u003E &gt; \u002Fusr\u002Fshare\u002Fnginx\u002Fhtml\u002F\u003Cspan class=\"hljs-built_in\"\u003Eindex\u003C\u002Fspan\u003E.html\n ---&gt; Running in \u003Cspan class=\"hljs-number\"\u003E24875\u003C\u002Fspan\u003Ed44bcc4\nRemoving intermediate container \u003Cspan class=\"hljs-number\"\u003E24875\u003C\u002Fspan\u003Ed44bcc4\n ---&gt; a79570bc2fc7\nSuccessfully built a79570bc2fc7\nSuccessfully tagged nginx:v3\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E构建完成之后，可以通过\u003Ccode\u003Edocker image ls\u003C\u002Fcode\u003E查看构建好的镜像\u003C\u002Fp\u003E\n\u003Cp\u003E运行构建的镜像：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-builtin-name\"\u003Erun\u003C\u002Fspan\u003E -d -P nginx:v3\n\u003Cspan class=\"hljs-comment\"\u003E# 查看ip+端口就可以看到Hello, Docker!\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"镜像构建上下文（context）\"\u003E镜像构建上下文（context）\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ccode\u003Edocker build -t nginx:v3 .\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E上面这条命令，最后的这个\u003Ccode\u003E.\u003C\u002Fcode\u003E就是构建此次镜像的上下文。指定这个上下文的作用是让其他的指令，如COPY、ADD等可以正确的处理文件内容。\u003C\u002Fp\u003E\n\u003Cp\u003Edocker build命令执行时，会将这个上下文路径内的所有内容进行打包，上传到docker引擎中，docker引擎在后续就可以得到处理构建镜像过程的所有文件内容。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-keyword\"\u003ECOPY\u003C\u002Fspan\u003E .\u003Cspan class=\"hljs-regexp\"\u003E\u002Fpackage.json \u002F\u003C\u002Fspan\u003Eapp\u002F\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这个命令不是复制文件的命令，意在复制上下文（\u002FAPP\u002F）目录下的package.json文件。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E.dockerignore\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E如果在上下文中的一些文件不需要\u002F不想被发送到docker引擎，可以使用\u003Ccode\u003E.dockerignore\u003C\u002Fcode\u003E忽略。\u003C\u002Fp\u003E\n\u003Ch3 id=\"docker-build-使用\"\u003Edocker build 使用\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E从git仓库进行构建\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker build -t \u003Cspan class=\"hljs-selector-attr\"\u003E[IMAGE NAME]\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-attr\"\u003E[REPO URL]\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"dockerfile-指令\"\u003EDockerfile 指令\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003ECOPY 文件复制\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003ECOPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件\u002F目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-keyword\"\u003ECOPY\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Epackage\u003C\u002Fspan\u003E.json \u003Cspan class=\"hljs-regexp\"\u003E\u002Fusr\u002F\u003C\u002Fspan\u003Esrc\u003Cspan class=\"hljs-regexp\"\u003E\u002Fapp # 从构建上下文目录中的package.json复制到\u002Fu\u003C\u002Fspan\u003Esr\u003Cspan class=\"hljs-regexp\"\u003E\u002Fsrc\u002F\u003C\u002Fspan\u003Eapp中\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003EADD 高级的文件复制\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E和COPY差不多的一致，在COPY的基础上增加了自动解压缩等的功能。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ECMD 容器启动命令，用于指定默认的容器主进程的启动命令的。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E一般推荐使用exec格式，注意要使用双引号。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003EENTRYPOINT 目的和CMD一样，都是在指定容器启动程序及参数。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003EENV 用于设置环境变量。无论后面的其他指令还是运行时的应用，都可以直接使用这里定义的环境变量。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003EENV \u003Cspan class=\"hljs-attribute\"\u003EVERSION\u003C\u002Fspan\u003E=1.0\n\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E curl \u003Cspan class=\"hljs-string\"\u003E&quot;https:\u002F\u002F\u003Cspan class=\"hljs-variable\"\u003E$VERSION\u003C\u002Fspan\u003E&quot;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003EARG 构建参数 = 默认值\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E构建参数和ENV的效果是一样的，都是设置环境变量。不过ARG设置的构建环境变量在将来容器运行时是不会存在的。ARG指令有生效范围，在FORM指令前指定，只能用于FORM指令中。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EVOLUME 匿名卷\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-type\"\u003EVOLUME\u003C\u002Fspan\u003E \u002F\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在容器运行时自动挂载匿名卷，任何向\u002Fdata中写入的信息都不会记录进容器的存储层，保证容器存储层无状态化。\u003C\u002Fp\u003E\n\u003Cp\u003E覆盖挂载：可以在运行容器时覆盖该挂载设置：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-title\"\u003Edocker\u003C\u002Fspan\u003E run -d -v mydata:\u002F\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E xxxx\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在这行命令中，就使用了 mydata 这个命名卷挂载到了 \u002Fdata 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EEXPOSE 暴露端口\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E只作端口声明。作用：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E帮助镜像使用者理解镜像所需要的配置端口。\u003C\u002Fli\u003E\n\u003Cli\u003E运行时会自动随机映射EXPOSE端口。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-builtin-name\"\u003Erun\u003C\u002Fspan\u003E -P\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003EWORKDIR 指定工作目录\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E在两条RUN指令中，都是完全不同的容器，如果第二条RUN指令用到第一条指令的内容，可能会出现错误。\u003C\u002Fp\u003E\n\u003Cp\u003E例如目录：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003EDockerfile\napp\n  - \u003Cspan class=\"hljs-keyword\"\u003Epackage\u003C\u002Fspan\u003E.json\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在Dockerfile中\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E cd app\n\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E yarn install\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E以上指令会出现错误，因为第一条RUN和第二条RUN完全没有关联。如果需要关联，可能需要用到WORKDIR指令。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-keyword\"\u003EWORKDIR\u003C\u002Fspan\u003E\u003Cspan class=\"bash\"\u003E \u002Fapp\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003ERUN\u003C\u002Fspan\u003E\u003Cspan class=\"bash\"\u003E yarn install\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"},{title:"Docker的一些需记基础命令和用法",slug:"2021_07_docker-command",description:"docker的基础命令快速查询，方便记忆和翻阅使用。",keywords:"docker，基础命令，基本使用，容器，镜像",labels:[h],date:n,path:"2021\u002F07\u002Fdocker-command.md",html:"\u003Cp\u003E由于docker目前在项目中用的比较少，慢慢在写项目的过程中，有一些命令会被我遗忘掉。所以我把一些基础常用的docker命令列下来，方便自己在回顾docker或者重新使用的时候快速运用上。在后续的时间里，也会尽可能的将docker应用到能用上的项目中。\u003C\u002Fp\u003E\n\u003Ch2 id=\"安装\"\u003E安装\u003C\u002Fh2\u003E\n\u003Cp\u003E我用linux比较多，所以只记录在linux下的安装步骤。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E如果有旧版本的docker，需要先卸载旧版本。旧版本为docker或者docker-engine。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo apt-\u003Cspan class=\"hljs-builtin-name\"\u003Eget\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-builtin-name\"\u003Eremove\u003C\u002Fspan\u003E docker docker-engine docker.io\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E用脚本安装。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-string\"\u003Ecurl\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-string\"\u003EfsSL\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Eget\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-string\"\u003Edocker\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-string\"\u003Ecom\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-string\"\u003Eo\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eget-docker.sh\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-string\"\u003Esudo\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Esh\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eget-docker.sh\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003E--mirror\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003EAliyun\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E启动docker\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo systemctl \u003Cspan class=\"hljs-keyword\"\u003Eenable\u003C\u002Fspan\u003E docker\nsudo systemctl \u003Cspan class=\"hljs-keyword\"\u003Estart\u003C\u002Fspan\u003E docker\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"4\"\u003E\n\u003Cli\u003E建立docker用户组\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo groupadd docker\nsudo usermod -aG docker $USER\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"5\"\u003E\n\u003Cli\u003E测试是否安装好\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E--rm hello-world\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"常用命令\"\u003E常用命令\u003C\u002Fh2\u003E\n\u003Cp\u003E注意-t之类的命令是用于修饰动作的，比如\u003Ccode\u003Erun -t-d\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"镜像使用\"\u003E镜像使用\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E拉取\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-attribute\"\u003Edocker\u003C\u002Fspan\u003E pull ubuntu:\u003Cspan class=\"hljs-number\"\u003E18\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-number\"\u003E04\u003C\u002Fspan\u003E # 拉取ubuntu镜像，对应版本（tag）为\u003Cspan class=\"hljs-number\"\u003E18\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-number\"\u003E04\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E运行（这个镜像为基础启动并运行一个容器）\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-keyword\"\u003Eit\u003C\u002Fspan\u003E ubuntu:\u003Cspan class=\"hljs-number\"\u003E18.04\u003C\u002Fspan\u003E bash \u003Cspan class=\"hljs-comment\"\u003E# -ℹ交互式操作，-t终端\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E列出\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker image \u003Cspan class=\"hljs-keyword\"\u003Els\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E# ls后跟具名可以过滤该名的镜像； -a列出所有镜像\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E删除\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker image \u003Cspan class=\"hljs-built_in\"\u003Erm\u003C\u002Fspan\u003E [\u003Cspan class=\"hljs-type\"\u003EIMAGE\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-type\"\u003EID\u003C\u002Fspan\u003E \u002F 仓库名：标签] \u003Cspan class=\"hljs-comment\"\u003E# id不需要全部打完，输入前3个就可以定位到\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# 例如删除ubuntu\u003C\u002Fspan\u003E\ndocker image \u003Cspan class=\"hljs-built_in\"\u003Erm\u003C\u002Fspan\u003E ubuntu:\u003Cspan class=\"hljs-number\"\u003E18.04\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"容器使用\"\u003E容器使用\u003C\u002Fh3\u003E\n\u003Cp\u003E容器是独立运行的一个或一组应用，以及它们的运行态环境。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E列出\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-keyword\"\u003Econtainer\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Els\u003C\u002Fspan\u003E # \u003Cspan class=\"hljs-keyword\"\u003Els\u003C\u002Fspan\u003E只列出当前运行的容器，\u003Cspan class=\"hljs-keyword\"\u003Els\u003C\u002Fspan\u003E -a列出所有容器，包含了已经停止运行的\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E启动（这个镜像为基础启动并运行一个容器）\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E创建一个新的容器\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-keyword\"\u003Eit\u003C\u002Fspan\u003E ubuntu:\u003Cspan class=\"hljs-number\"\u003E18.04\u003C\u002Fspan\u003E bash \u003Cspan class=\"hljs-comment\"\u003E# -ℹ交互式操作，-t终端\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E启动一个已经停止的容器\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Econtainer\u003C\u002Fspan\u003E start [CONTAINER ID] \u003Cspan class=\"hljs-meta\"\u003E# id不需要全部打完，输入前3个就可以定位到\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E守护态运行\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-keyword\"\u003Eit\u003C\u002Fspan\u003E -d ubuntu:\u003Cspan class=\"hljs-number\"\u003E18.04\u003C\u002Fspan\u003E bash \u003Cspan class=\"hljs-comment\"\u003E# -ℹ交互式操作，-t终端\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E如果需要查看守护态容器的日志信息，可以使用：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-attribute\"\u003Edocker\u003C\u002Fspan\u003E logs [CONTAINER ID] \u003Cspan class=\"hljs-comment\"\u003E# id不需要全部打完，输入前3个就可以定位到\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E停止\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-keyword\"\u003Econtainer\u003C\u002Fspan\u003E stop \u003Cspan class=\"hljs-comment\"\u003E[CONTAINER ID]\u003C\u002Fspan\u003E \n# 如果需要重新启动，可以restart\ndocker \u003Cspan class=\"hljs-keyword\"\u003Econtainer\u003C\u002Fspan\u003E restart \u003Cspan class=\"hljs-comment\"\u003E[CONTAINER ID]\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E进入容器\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E一般来说，都是需要一个可交互的终端进入容器\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-keyword\"\u003Eexec\u003C\u002Fspan\u003E -it [CONTAINER ID] bash # \u003Cspan class=\"hljs-keyword\"\u003Eexec\u003C\u002Fspan\u003E进入容器，使用\u003Cspan class=\"hljs-keyword\"\u003Eexit\u003C\u002Fspan\u003E并不会停止容器的运行，这和attach不一样\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E删除\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Econtainer\u003C\u002Fspan\u003E rm [CONTAINER ID]\n\n\u003Cspan class=\"hljs-meta\"\u003E# 如果想清理所有停止运行的容器\u003C\u002Fspan\u003E\ndocker \u003Cspan class=\"hljs-built_in\"\u003Econtainer\u003C\u002Fspan\u003E prune\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"docker-hub\"\u003EDocker Hub\u003C\u002Fh2\u003E\n\u003Ch3 id=\"登陆和退出docker-hub\"\u003E登陆和退出docker hub\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode\u003Edocker login\ndocker logout\n``\n\n### 镜像的搜索\n\n```bash\ndocker search ubuntu # 可以看到搜索出来的镜像\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"数据卷volume\"\u003E数据卷Volume\u003C\u002Fh2\u003E\n\u003Cp\u003E数据卷 可以在容器之间共享和重用\n对 数据卷 的修改会立马生效\n对 数据卷 的更新，不会影响镜像\n数据卷 默认会一直存在，即使容器被删除\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E创建\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Evolume\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ecreate\u003C\u002Fspan\u003E my-vol\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E查看\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Evolume\u003C\u002Fspan\u003E ls \u003Cspan class=\"hljs-meta\"\u003E# 查看所有的数据卷\u003C\u002Fspan\u003E\ndocker \u003Cspan class=\"hljs-built_in\"\u003Evolume\u003C\u002Fspan\u003E inspect [\u003Cspan class=\"hljs-built_in\"\u003EVOLUME\u003C\u002Fspan\u003E NAME] \u003Cspan class=\"hljs-meta\"\u003E# 查看某个数据卷的信息\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E启动\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E在使用docker run命令的时候，带上\u003Ccode\u003E--mount\u003C\u002Fcode\u003E将数据卷挂载到容器中\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker run -d -P --name web --mount source=my-vol,target=\u003Cspan class=\"hljs-regexp\"\u003E\u002Fusr\u002F\u003C\u002Fspan\u003Eshare\u003Cspan class=\"hljs-regexp\"\u003E\u002Fnginx\u002F\u003C\u002Fspan\u003Ehtml nginx:alpine \u003Cspan class=\"hljs-comment\"\u003E# --name 定义容器的名称\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E以上命令。创建一个名为\u003Ccode\u003Eweb\u003C\u002Fcode\u003E的容器，家在一个数据卷到容器web的\u003Ccode\u003E\u002Fusr\u002Fshare\u002Fnginx\u002Fhtml\u003C\u002Fcode\u003E目录。\u003C\u002Fp\u003E\n\u003Cp\u003E查看数据卷的具体信息\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-attribute\"\u003Edocker inspect web\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E结果：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-json\"\u003E\u003Cspan class=\"hljs-string\"\u003E&quot;Mounts&quot;\u003C\u002Fspan\u003E: [\n  {\n    \u003Cspan class=\"hljs-string\"\u003E&quot;Type&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;volume&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;Name&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;my-vol&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;Source&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;\u002Fvar\u002Flib\u002Fdocker\u002Fvolumes\u002Fmy-vol\u002F_data&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;Destination&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;\u002Fusr\u002Fshare\u002Fnginx\u002Fhtml&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;Driver&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;local&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;Mode&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;RW&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;Propagation&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;&quot;\u003C\u002Fspan\u003E\n  }\n],\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E删除\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Evolume\u003C\u002Fspan\u003E rm [\u003Cspan class=\"hljs-built_in\"\u003EVOLUME\u003C\u002Fspan\u003E NAME] \u003Cspan class=\"hljs-meta\"\u003E# 删除指定的数据卷\u003C\u002Fspan\u003E\ndocker \u003Cspan class=\"hljs-built_in\"\u003Evolume\u003C\u002Fspan\u003E prune \u003Cspan class=\"hljs-meta\"\u003E# 删除无主的数据卷\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E挂载目录\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E$ docker run -d -P --name web --mount type=bind,\u003Cspan class=\"hljs-keyword\"\u003Esource\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-regexp\"\u003E\u002Fsrc\u002F\u003C\u002Fspan\u003Ewebapp,target=\u003Cspan class=\"hljs-regexp\"\u003E\u002Fusr\u002F\u003C\u002Fspan\u003Eshare\u003Cspan class=\"hljs-regexp\"\u003E\u002Fnginx\u002F\u003C\u002Fspan\u003Ehtml nginx:alpine\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E如果source为绝对路径，则为挂载主机的目录。\u003C\u002Fp\u003E\n\u003Ch2 id=\"网络\"\u003E网络\u003C\u002Fh2\u003E\n\u003Ch3 id=\"外部访问容器\"\u003E外部访问容器\u003C\u002Fh3\u003E\n\u003Cp\u003E通过-P或-p参数指定或者不制定端口的方式让外部访问容器内部的网络应用。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E -d -P nginx:alpine \u003Cspan class=\"hljs-comment\"\u003E# 启动一个容器\u003C\u002Fspan\u003E\ndocker container ls\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在PORTS那一列，可以看到：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-number\"\u003E0.0.0.0:32768\u003C\u002Fspan\u003E-&gt;\u003Cspan class=\"hljs-number\"\u003E80\u003C\u002Fspan\u003E\u002Ftcp\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里表示着本机的32768端口被映射到了容器的80端口，意味着在本机上访问32768端口就可以访问到容器的nginx默认页面。访问方式为本机ip + 端口（32768）。\u003C\u002Fp\u003E\n\u003Ch3 id=\"容器互联\"\u003E容器互联\u003C\u002Fh3\u003E\n\u003Cp\u003E通过docker网络的方式让连接到创建的网络上实现容器之间的互联。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E创建网络\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker network \u003Cspan class=\"hljs-keyword\"\u003Ecreate\u003C\u002Fspan\u003E -d bridge [NETWORK \u003Cspan class=\"hljs-type\"\u003ENAME\u003C\u002Fspan\u003E]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E运行第一个容器并连接到网络[NETWORK NAME]\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-keyword\"\u003Eit\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E--rm --name busybox1 --network [NETWORK NAME] busybox sh\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E运行第一个容器并连接到网络[NETWORK NAME]\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-keyword\"\u003Eit\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E--rm --name busybox2 --network [NETWORK NAME] busybox sh\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E以上两个容器连接到了同一个网络[NETWORK NAME]，某一个容器都可以ping通与之连载在同一个网络下的容器。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u002F #\u003Cspan class=\"hljs-built_in\"\u003E ping \u003C\u002Fspan\u003Ebusybox2\u003Cspan class=\"hljs-built_in\"\u003E\nPING \u003C\u002Fspan\u003Ebusybox2 (172.19.0.3): 56 data bytes\n64 bytes \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E 172.19.0.3: \u003Cspan class=\"hljs-attribute\"\u003Eseq\u003C\u002Fspan\u003E=0 \u003Cspan class=\"hljs-attribute\"\u003Ettl\u003C\u002Fspan\u003E=64 \u003Cspan class=\"hljs-attribute\"\u003Etime\u003C\u002Fspan\u003E=0.072 ms\n64 bytes \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E 172.19.0.3: \u003Cspan class=\"hljs-attribute\"\u003Eseq\u003C\u002Fspan\u003E=1 \u003Cspan class=\"hljs-attribute\"\u003Ettl\u003C\u002Fspan\u003E=64 \u003Cspan class=\"hljs-attribute\"\u003Etime\u003C\u002Fspan\u003E=0.118 ms\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"},{title:"【自用】ubuntu20必须安装",slug:"2021_07_ubuntu20",description:"ubuntu新系统需要安装的一些软件，偏前端开发向。",keywords:"ubuntu",labels:["系统"],date:"2021-07-23",path:"2021\u002F07\u002Fubuntu20.md",html:"\u003Ch2 id=\"前言\"\u003E前言\u003C\u002Fh2\u003E\n\u003Cp\u003E最近系统出问题比较多，短短几周我就重装了两回ubuntu。从1804到20，在这里记录一些安装的一些工具，后续快速进行配置开发环境。\u003C\u002Fp\u003E\n\u003Ch2 id=\"chrome\"\u003Echrome\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fwww.google.com\u002Fchrome\u002F\"\u003Ehttps:\u002F\u002Fwww.google.com\u002Fchrome\u002F\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo dpkg -i \u003Cspan class=\"hljs-strong\"\u003E***\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"clash\"\u003Eclash\u003C\u002Fh2\u003E\n\u003Cp\u003E位于home目录\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Emkdir clash &amp;&amp; cd clash\n\u003Cspan class=\"hljs-comment\"\u003E# 到 https:\u002F\u002Fgithub.com\u002FDreamacro\u002Fclash\u002Freleases 查看最新的clash-linux-amd64版本并替换下面的链接\u003C\u002Fspan\u003E\nwget -N --no-check-certificate https:\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002Fgi\u003C\u002Fspan\u003Ethub.com\u003Cspan class=\"hljs-regexp\"\u003E\u002FDreamacro\u002F\u003C\u002Fspan\u003Eclash\u003Cspan class=\"hljs-regexp\"\u003E\u002Freleases\u002F\u003C\u002Fspan\u003Edownload\u003Cspan class=\"hljs-regexp\"\u003E\u002Fv1.6.5\u002F\u003C\u002Fspan\u003Eclash-linux-amd64-v1.\u003Cspan class=\"hljs-number\"\u003E6.5\u003C\u002Fspan\u003E.gz\ngunzip clash-linux-amd64-v1.\u003Cspan class=\"hljs-number\"\u003E6.5\u003C\u002Fspan\u003E.gz \u003Cspan class=\"hljs-comment\"\u003E# 解压.gz文件\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# 将解压出来的clash-linux-amd64-v1.6.5重命名为clash\u003C\u002Fspan\u003E\nchmod +x clash\nwget -O config.yaml 【clash托管链接】\n\u003Cspan class=\"hljs-comment\"\u003E# 启动\u003C\u002Fspan\u003E\n.\u002Fclash -d .\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E打开网络代理设置-有线设置，网络代理-选择手动，填写 HTTP 和 HTTPS 代理为 127.0.0.1:7890 ，填写Socks主机为 127.0.0.1:7891 ，即可启用系统代理。\u003C\u002Fp\u003E\n\u003Ch2 id=\"vscode\"\u003Evscode\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fcode.visualstudio.com\u002F\"\u003Ehttps:\u002F\u002Fcode.visualstudio.com\u002F\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo dpkg -i \u003Cspan class=\"hljs-strong\"\u003E***\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E同步github的账号。\u003C\u002Fp\u003E\n\u003Ch3 id=\"firacode安装\"\u003EFiraCode安装\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo apt \u003Cspan class=\"hljs-keyword\"\u003Einstall\u003C\u002Fspan\u003E fonts-firacode\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"git\"\u003Egit\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo apt \u003Cspan class=\"hljs-keyword\"\u003Einstall\u003C\u002Fspan\u003E git \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"nodejs--npm--yarn\"\u003Enodejs &amp;&amp; npm &amp;&amp; yarn\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo apt \u003Cspan class=\"hljs-keyword\"\u003Einstall\u003C\u002Fspan\u003E nodejs npm\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E全局安装n用于node的版本管理，如果遇到EACCES问题，参考这个解决办法\u003Ca target='_blank'  href=\"https:\u002F\u002Fgzhiyi.top\u002Fblog\u002F2021_07_npm-global-EACCES\"\u003E2021_07_npm-global-EACCES\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Enpm \u003Cspan class=\"hljs-keyword\"\u003Einstall\u003C\u002Fspan\u003E -g n\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E需要安装yarn，参考这个\n\u003Ca target='_blank'  href=\"https:\u002F\u002Fgzhiyi.top\u002Fblog\u002F2021_07_yarn-global-install-not-working\"\u003E2021_07_yarn-global-install-not-working\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch2 id=\"oh-my-zsh\"\u003Eoh my zsh\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo apt \u003Cspan class=\"hljs-keyword\"\u003Einstall \u003C\u002Fspan\u003Ezsh\n\u003Cspan class=\"hljs-keyword\"\u003Esh \u003C\u002Fspan\u003E-c \u003Cspan class=\"hljs-string\"\u003E&quot;$(curl -fsSL https:\u002F\u002Fraw.github.com\u002Fohmyzsh\u002Fohmyzsh\u002Fmaster\u002Ftools\u002Finstall.sh)&quot;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"git-flow\"\u003Egit flow\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo apt-\u003Cspan class=\"hljs-builtin-name\"\u003Eget\u003C\u002Fspan\u003E install -y git-flow\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"},{title:"npm全局安装yarn不生效的问题",slug:"2021_07_yarn-global-install-not-working",description:"通过npm安装yarn，安装没有提示错误，但yarn还是无法使用",keywords:"npm,yarn,gloabl,install",labels:[i],date:o,path:"2021\u002F07\u002Fyarn-global-install-not-working.md",html:"\u003Cp\u003E在ubuntu上安装了node和npm，命令行上都可以看到node以及npm的版本号。但通过npm全局安装yarn却不能用的问题。\n官网也是建议通过npm进行全局安装。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-built_in\"\u003Enpm\u003C\u002Fspan\u003E install --\u003Cspan class=\"hljs-built_in\"\u003Eglobal\u003C\u002Fspan\u003E yarn\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"解决\"\u003E解决\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Ecurl -sS https:\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003Edl.yarnpkg.com\u003Cspan class=\"hljs-regexp\"\u003E\u002Fdebian\u002F\u003C\u002Fspan\u003Epubkey.gpg | sudo apt-key add -\necho \u003Cspan class=\"hljs-string\"\u003E&quot;deb https:\u002F\u002Fdl.yarnpkg.com\u002Fdebian\u002F stable main&quot;\u003C\u002Fspan\u003E | sudo tee \u003Cspan class=\"hljs-regexp\"\u003E\u002Fetc\u002F\u003C\u002Fspan\u003Eapt\u003Cspan class=\"hljs-regexp\"\u003E\u002Fsources.list.d\u002Fy\u003C\u002Fspan\u003Earn.list\nsudo apt-get update\nsudo apt-get install yarn\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E注意不要直接安装yarn，否则会出现以下问题：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E00h00m00s 0\u002F0: : \u003Cspan class=\"hljs-keyword\"\u003EERROR\u003C\u002Fspan\u003E: There are \u003Cspan class=\"hljs-keyword\"\u003Eno\u003C\u002Fspan\u003E scenarios; must have at least \u003Cspan class=\"hljs-keyword\"\u003Eone\u003C\u002Fspan\u003E.\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E是因为安装错了，如果出现上面的提示的问题。可以把安装的yarn移除了：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo apt \u003Cspan class=\"hljs-builtin-name\"\u003Eremove\u003C\u002Fspan\u003E yarn\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"},{title:"lodash数组中concat方法",slug:"2021_07_lodash-concat",description:"lodash concat, array method",keywords:"lodash,concat,array,arrayPush,copyArray,baseFlatten",labels:[g],date:o,path:"2021\u002F07\u002Flodash-concat.md",html:"\u003Ch2 id=\"concat\"\u003EConcat\u003C\u002Fh2\u003E\n\u003Cp\u003E创建一个用任何数组或值拼接的新数组。\u003C\u002Fp\u003E\n\u003Ch3 id=\"使用\"\u003E使用\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Evar\u003Cspan class=\"hljs-built_in\"\u003E array \u003C\u002Fspan\u003E= [1]\nvar other = _.concat(array, 2, [3], [[4]])\n \nconsole.log(other)\n\u002F\u002F =&gt; [1, 2, 3, [4]]\n \nconsole.log(array)\n\u002F\u002F =&gt; [1]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E返回的是一个全新的数组；调用并不会改变原本的数组。传入的拼接参数可以为数字、一维数组，甚至是二维数组，这有点意思了来看看源代码的实现。\u003C\u002Fp\u003E\n\u003Ch3 id=\"源码\"\u003E源码\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F**\n* @static\n* @memberOf _\n* @since 4.0.0\n* @category Array\n* @param {Array}\u003Cspan class=\"hljs-built_in\"\u003E array \u003C\u002Fspan\u003EThe\u003Cspan class=\"hljs-built_in\"\u003E array \u003C\u002Fspan\u003Eto concatenate.\n* @param {...*} [values] The values to concatenate.\n* @returns {Array} Returns the\u003Cspan class=\"hljs-built_in\"\u003E new \u003C\u002Fspan\u003Econcatenated array.\n* @example\n*\n*\u002F\nfunction concat() {\n  \u002F\u002F 在定义concat时就不需要指定传入的参数有什么，直接读argruments。\n  var length = arguments.length; \u002F\u002F 传入参数的长度，用于创建包含length - 1长度的args数组\n \u003Cspan class=\"hljs-built_in\"\u003E if \u003C\u002Fspan\u003E(!length) {\n   \u003Cspan class=\"hljs-built_in\"\u003E return \u003C\u002Fspan\u003E[];\n  }\n  var args = Array(length - 1),\n     \u003Cspan class=\"hljs-built_in\"\u003E array \u003C\u002Fspan\u003E= arguments[0], \u002F\u002F 这里默认了第一个参数就是要拼接的“原数组”\n      index = length;\n  \u002F\u002F 这里使用while(index--)就是直接遍历index + 1次，index从index - 1开始，最后index = 0作为遍历的结束\n  \u002F\u002F 如果while(--index)则只会遍历index次，index为0不会被执行\n  while (index--) {\n    args[index - 1] = arguments[index];\n  }\n \u003Cspan class=\"hljs-built_in\"\u003E return \u003C\u002Fspan\u003EarrayPush(isArray(array) ? copyArray(array)\u003Cspan class=\"hljs-keyword\"\u003E :\u003C\u002Fspan\u003E [array], baseFlatten(args, 1));\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E由于lodash代码中会存在多处调用（套娃），所以copyArray和baseFlatten在这一页中只作一些使用上的解释，之后也会对代码进行解释理解。\u003C\u002Fp\u003E\n\u003Cp\u003E其余函数作用：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003EcopyArray(source, array)\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E将source的值复制为array。结果是source和array在数值上是一样的，只是遍历了source，逐个下标赋值到array中。\u003C\u002Fp\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003EbaseFlatten(array, depth, predicate, isStrict, result)\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E将数组array铺平。depth为铺平的深度。该函数有递归，后续再详细了解。\u003C\u002Fp\u003E\n\u003Cp\u003E其中一个可以学习到的用法：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E index = \u003Cspan class=\"hljs-number\"\u003E-1\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eend\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-number\"\u003E6\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E(++index &lt; \u003Cspan class=\"hljs-keyword\"\u003Eend\u003C\u002Fspan\u003E){}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这样的遍历等价于\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; \u003Cspan class=\"hljs-keyword\"\u003Eend\u003C\u002Fspan\u003E; i++) {}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003EarrayPush(array, values)\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E将两个数组合并。\n!!这个方法会修改原传入array的数组！！这和数组展开方式进行合并是有一些区别的。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E arr = [\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E]\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E arr2 = [\u003Cspan class=\"hljs-string\"\u003E&#x27;a&#x27;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E&#x27;b&#x27;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E&#x27;c&#x27;\u003C\u002Fspan\u003E]\n[\u003Cspan class=\"hljs-meta\"\u003E...arr, ...arr2\u003C\u002Fspan\u003E] \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这个结果并不会改变arr和arr2\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"总结\"\u003E总结\u003C\u002Fh3\u003E\n\u003Cp\u003E这个函数可以对数组进行拼接，即便后续的参数包含有数字，字符串或者数组，和一般的数组拼接有一些额外的不同，但开发中感觉用的比较少。\u003C\u002Fp\u003E\n"},{title:"npm全局安装package出现EACCES permissions",slug:"2021_07_npm-global-EACCES",description:"npm全局安装包的时候有权限问题，提示permissions denied，尝试修改用户权限并未生效",keywords:[i,"linux","global","全局安装","权限","permission","denied","用户"],labels:i,date:"2021-07-16",path:"2021\u002F07\u002Fnpm-global-EACCES.md",html:"\u003Cp\u003E如果在使用npm安装全局package的时候出现EACCES错误，可以这样解决：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E重新安装npm（推荐）。\u003C\u002Fli\u003E\n\u003Cli\u003E手动修改npm的默认目录。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"重新安装npm\"\u003E重新安装npm\u003C\u002Fh3\u003E\n\u003Cp\u003E重新安装是最好的解决这个问题的办法。可以点击\u003Ca target='_blank'  href=\"https:\u002F\u002Fdocs.npmjs.com\u002Fdownloading-and-installing-node-js-and-npm\"\u003E这里\u003C\u002Fa\u003E看看重新安装的步骤。在安装node版本管理工具之前是不需要删除在你设备的当前的npm或者nodejs。\u003C\u002Fp\u003E\n\u003Ch3 id=\"手动修改npm的默认目录\"\u003E手动修改npm的默认目录\u003C\u002Fh3\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E这种方法不适用于windows平台。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Col\u003E\n\u003Cli\u003E在终端中创建一个用于npm全局安装的目录.npm-global\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Emkdir ~\u002F.\u003Cspan class=\"hljs-built_in\"\u003Enpm\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-built_in\"\u003Eglobal\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E配置npm为一个新的文件目录路径\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Enpm\u003Cspan class=\"hljs-built_in\"\u003E config \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-builtin-name\"\u003Eset\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-built_in\"\u003E prefix \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-string\"\u003E&#x27;~\u002F.npm-global&#x27;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E在~\u002F.profile中增加下面这一行，没有这个文件的可以新建一个。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-builtin-name\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attribute\"\u003EPATH\u003C\u002Fspan\u003E=~\u002F.npm-global\u002Fbin:$PATH\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"4\"\u003E\n\u003Cli\u003E更新系统变量。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Esource\u003C\u002Fspan\u003E ~\u002F.\u003Cspan class=\"hljs-keyword\"\u003Eprofile\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"5\"\u003E\n\u003Cli\u003E测试看看还有没有权限报错。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Enpm \u003Cspan class=\"hljs-keyword\"\u003Einstall\u003C\u002Fspan\u003E -g jshint\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"},{title:"lodash数组中chunk、compact方法",slug:"2021_07_lodash-array-chunk",description:"lodash中chunk、compac方法的使用，在业务中用到多少呢，怎么对数组使用chunk进行切割",keywords:"lodash,chunk,compact,array,数组,切割,源码分析,每天一个lodash函数",labels:[g],date:"2021-07-15",path:"2021\u002F07\u002Flodash-array-chunk.md",html:"\u003Ch2 id=\"chunk\"\u003EChunk\u003C\u002Fh2\u003E\n\u003Cp\u003Elodash的chunk方法用于对数组进行按size切割。如果最后数组不满足size的长度，则剩余的部分会放到最后一个数组上。\u003C\u002Fp\u003E\n\u003Ch3 id=\"使用\"\u003E使用\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Econst arr = \u003Cspan class=\"hljs-comment\"\u003E[1, 2, 3, 4, 5]\u003C\u002Fspan\u003E\n_.chunk(arr, 2) \u002F\u002F \u003Cspan class=\"hljs-comment\"\u003E[\u003Cspan class=\"hljs-comment\"\u003E[1, 2]\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-comment\"\u003E[3, 4]\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-comment\"\u003E[5]\u003C\u002Fspan\u003E]\u003C\u002Fspan\u003E \n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E结果返回的是一个二维数组。开发了这么久，想了下这个函数所实现的功能需求貌似少之又少。\u003C\u002Fp\u003E\n\u003Ch3 id=\"源码\"\u003E源码\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-function\"\u003Efunction \u003Cspan class=\"hljs-title\"\u003Echunk\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(array, size = \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{ \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 存在参数默认\u003C\u002Fspan\u003E\n  size = Math.\u003Cspan class=\"hljs-built_in\"\u003Emax\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-built_in\"\u003EtoInteger\u003C\u002Fspan\u003E(size), \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E)     \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 【验证输入参数的合法性】toInteger会把传入的size转为整数\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E length = array == null ? \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E : array.length   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F  【验证输入参数的合法性】计算传入数组的长度\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!length || size &lt; \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E []\n  }\n  let index = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n  let resIndex = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E result = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EArray\u003C\u002Fspan\u003E(Math.\u003Cspan class=\"hljs-built_in\"\u003Eceil\u003C\u002Fspan\u003E(length \u002F size)) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F   这里新建一个包含切割结果个数的空数组，如[, , , ]\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-keyword\"\u003Ewhile\u003C\u002Fspan\u003E (index &lt; length) {\n    result[resIndex++] = \u003Cspan class=\"hljs-built_in\"\u003Eslice\u003C\u002Fspan\u003E(array, index, (index += size)) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F    slice是封装的函数，可以切割回数组的第二个参数到第三个参数的值\u003C\u002Fspan\u003E\n  }\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E result\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"compact\"\u003Ecompact\u003C\u002Fh2\u003E\n\u003Cp\u003Ecompact在字面上的意思是紧凑的，在lodash中，就是把一个数组中值为 \u003Ccode\u003Efalse\u003C\u002Fcode\u003E, \u003Ccode\u003Enull\u003C\u002Fcode\u003E, \u003Ccode\u003E0\u003C\u002Fcode\u003E, \u003Ccode\u003E&quot;&quot;\u003C\u002Fcode\u003E, \u003Ccode\u003Eundefined\u003C\u002Fcode\u003E, \u003Ccode\u003ENaN\u003C\u002Fcode\u003E的都剔除。\u003C\u002Fp\u003E\n\u003Ch3 id=\"使用-1\"\u003E使用\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-attribute\"\u003E_\u003C\u002Fspan\u003E.compact([\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, false, \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, &#x27;&#x27;, \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E]) \u002F\u002F =&gt;\u003Cspan class=\"hljs-meta\"\u003E [1, 2, 3]\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E业务中使用的也比较少。\u003C\u002Fp\u003E\n\u003Ch3 id=\"源码-1\"\u003E源码\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ecompact\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(\u003Cspan class=\"hljs-keyword\"\u003Earray\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E resIndex = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F   貌似都喜欢把下标定位resIndex这个变量名。。\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E result = []\n\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Earray\u003C\u002Fspan\u003E == \u003Cspan class=\"hljs-keyword\"\u003Enull\u003C\u002Fspan\u003E) {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E result\n  }\n\n  \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E value of \u003Cspan class=\"hljs-keyword\"\u003Earray\u003C\u002Fspan\u003E) { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F   这里用for of对数组进行遍历\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (value) { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F   核心的过滤就是这里，在if下，falsy的参数会被过滤掉。\u003C\u002Fspan\u003E\n      result[resIndex++] = value\n    }\n  }\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E result\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003ELodash 源码理解 1\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n"},{title:"vue获取不到dom节点",slug:"2021_06_vue-dom-not-found",description:"开发中出现拿不到dom节点的问题，在mounted后也读取不到节点",keywords:"vue，dom节点，node，获取不到，loading，echarts，渲染，图表",labels:[a],date:"2021-06-29",path:"2021\u002F06\u002Fvue-dom-not-found.md",html:"\u003Cp\u003E在vue开发中，出现拿不到dom节点的问题，具体的场景是页面需要对echarts进行实例化，画布需要挂在到某个id的dom上，图表的数据需要从接口上获取，大致的代码如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Etemplate\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Elang\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;pug&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n  div#render-id\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Etemplate\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Edefault\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003Emounted\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.getChartData()\n    },\n    \u003Cspan class=\"hljs-attr\"\u003Emethods\u003C\u002Fspan\u003E: {\n      \u003Cspan class=\"hljs-keyword\"\u003Easync\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003EgetChartData\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F do fetch chart data\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.renderChart()\n      },\n      \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003ErenderChart\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E node = \u003Cspan class=\"hljs-built_in\"\u003Edocument\u003C\u002Fspan\u003E.querySelector(\u003Cspan class=\"hljs-string\"\u003E&#x27;#render-id&#x27;\u003C\u002Fspan\u003E)\n        \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(node) \n      }\n    }\n  }\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E出现的异常：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E Cannot \u003Cspan class=\"hljs-keyword\"\u003Eread\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eproperty\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-title\"\u003E \u003C\u002Fspan\u003E&#x27;getAttribute&#x27; of undefined\u003Cspan class=\"hljs-string\"\u003E&quot;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E打印node节点发现为null。\u003C\u002Fp\u003E\n\u003Ch3 id=\"问题解决\"\u003E问题解决\u003C\u002Fh3\u003E\n\u003Cp\u003E解决这个问题需要知道的是，获取不到节点的直接原因就是在query节点的时候render-id还没挂载到dom上。但会问，不是在mounted后才读这个节点吗？按照上面的代码逻辑，想法是正确的，即便是接口数据大，获取数据的时间长，也会在render-id这个元素挂载到dom后才会执行query操作。理论是不会出现读取不到该节点的问题。\u003C\u002Fp\u003E\n\u003Cp\u003E处理思路应该聚集在渲染dom有什么另外的操作会影响。总结无外乎就是：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E优先确认query节点的操作要在dom渲染完成后操作（这是核心思路）。\u003C\u002Fli\u003E\n\u003Cli\u003E检查有无异步的操作产生影响。比如元素需要在接口获取到之后写入到document，但写入前读取是会出现这样的问题的。\u003C\u002Fli\u003E\n\u003Cli\u003E检查获取的元素或者元素的外层是否有loading的操作。\u003C\u002Fli\u003E\n\u003Cli\u003E$nextTick(f)有时候会解决此类问题。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"},{title:"svelte语法点小记",slug:"2021_06_svelte",description:"svelte和vue、react不同，在构建页面的时候语法需要和其余框架区别开，记录官方文档有助于理解使用。",keywords:"svelte, vue, react, 文档",labels:[a,"svelte"],date:"2021-06-24",path:"2021\u002F06\u002Fsvelte.md",html:"\u003Cp\u003E计划重写原本由sapper编写的博客，需要移除sapper，只用svelte和一般的构建即可。在此之前，需要花点时间学习（回顾）一下svelte的一下语法点，会和vue进行对比，暂不深入理解内部原理，单纯建立在官方文档的基础上。\u003C\u002Fp\u003E\n\u003Cp\u003E记录并不是所有细节都要兼顾。遇到和vue理念比较大，或者说这个语法并没有让我那么容易记住的知识点，我都会记录下来，并在后续闲暇的时间下进行回顾复习，有点类似于做一下错题本。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E变量和代码块都只需要放在一个花括号里面就好了。在vue里面是\u003Ccode\u003E{{}}\u003C\u002Fcode\u003E包裹，有点不同。不要有带入vue语法的惯性思维。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E和vue类似，一个\u003Ccode\u003E.svelte\u003C\u002Fcode\u003E文件就是一个组件，包含了script、html、还有css。可以在另一个svelte组件中引入svelte组件。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E{@html 字符串}，包裹的字符串会被转化为不信任来源的html代码，注意防止xss攻击。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E当组件中的变量更新的时候，svelte会自动更新对应的dom。类似于vue中的计算属性，svelte是这么处理的：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Econst \u003Cspan class=\"hljs-attr\"\u003Evarable\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n$: \u003Cspan class=\"hljs-attr\"\u003EvarableName\u003C\u002Fspan\u003E = varable + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E其中\u003Ccode\u003E$:\u003C\u002Fcode\u003E就是可以标识变量为“计算属性”，其中varable变化的话，对应的varableName也会跟着变化。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003E$:\u003C\u002Fcode\u003E不仅仅是标识变量为计算属性，还可以是一串代码块，在该代码块中的变量一旦发生变化，就会执行这个代码块，而如果没有变量变化，这一个代码块就不会执行。所以把这个符号理解为响应式定义符更好，官网提到的名词就叫响应式声明。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E对于一般变量，直接赋值就可以产生响应式的效果，但如果是对象类型就不可以，比如数组的push等操作，就不会更新dom。svelte的解决方式有\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E在数组操作之后，将结果数组赋值给原数组。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003Elet num = [\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E]\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EaddNum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-type\"\u003ENum\u003C\u002Fspan\u003E) {\n  num.push(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-type\"\u003ENum\u003C\u002Fspan\u003E)\n}\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 直接在html上调用这个addNum函数，是不会对num进行更新的，需要改为\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EaddNum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-type\"\u003ENum\u003C\u002Fspan\u003E) {\n  num.push(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-type\"\u003ENum\u003C\u002Fspan\u003E)\n  num = num\n}\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 抑或者\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EaddNum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-type\"\u003ENum\u003C\u002Fspan\u003E) {\n  num = [...num, \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-type\"\u003ENum\u003C\u002Fspan\u003E]\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E对于对象属性的更新，可以直接赋值。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E obj = {\n \u003Cspan class=\"hljs-built_in\"\u003E name\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;cat&#x27;\u003C\u002Fspan\u003E\n}\n\u002F\u002F 可以直接更新obj上\u003Cspan class=\"hljs-built_in\"\u003E的name\u003C\u002Fspan\u003E属性\n\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E changeName(newName) {\n  obj\u003Cspan class=\"hljs-built_in\"\u003E.name\u003C\u002Fspan\u003E = newName\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E6.组件参数传递。和vue不一样，vue在一个组件中对传入参数是直接在props上进行声明的。而svelte是直接在组件内export参数。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u002F\u002F 组件displayName.svelte\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E name = \u003Cspan class=\"hljs-string\"\u003E&quot;name参数的默认值&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这里就直接表示组件a具有一个name的参数，外部可以传递进来\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\n\u002F\u002F 组件b.svelte\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E DisplayName \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002FdisplayName.svelte&#x27;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E myName = \u003Cspan class=\"hljs-string\"\u003E&#x27;cat&#x27;\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003EDisplayName\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ename\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E{myName}\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003EDisplayName\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"7\"\u003E\n\u003Cli\u003E\u003Cp\u003Eif块。初次感受肯定是没有vue方便快捷，但写多几遍之后，发现还是可以接受这样的一个语法糖。注意#号不能遗漏掉。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E{\u003Cspan class=\"hljs-comment\"\u003E#if isTrue}\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 执行为isTrue的html\n{:\u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E 条件} \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 这个是额外可能出现的条件\n{:\u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E}\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 执行isTrue为false的html\n{\u002F\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E循环块。类比vue中的v-for。其中（）内的数值表示为id，可以有效更新dom。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"xml\"\u003Elet arr = [\n    \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{\n        id: 1,\n        name: &#x27;cat&#x27;\n    }\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E,\n    \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{\n        id: 2,\n        name: &#x27;dog&#x27;\n    }\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n]\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-tag\"\u003E{#\u003Cspan class=\"hljs-name\"\u003Eeach\u003C\u002Fspan\u003E arr as item, index(item.id)}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{index}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E: \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{item.name}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-tag\"\u003E{\u002F\u003Cspan class=\"hljs-name\"\u003Eeach\u003C\u002Fspan\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n\u002F\u002F 用上解构，会更加简洁明了\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-tag\"\u003E{#\u003Cspan class=\"hljs-name\"\u003Eeach\u003C\u002Fspan\u003E arr as {id, name}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E, index(id)}\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{index}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E: \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{id}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{name}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Eawait块。没想到真的有这个东西，可以直接拿来判断一个promise在多个状态下的表现，这可以说不用写那一堆loading了，大致的代码如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E promise = getDataFromUrl()\n  \u003Cspan class=\"hljs-keyword\"\u003Easync\u003C\u002Fspan\u003E getDataFromUrl() \u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u002F\u002F 直接拿promise就像是一个promise一样在html中await\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-tag\"\u003E{#\u003Cspan class=\"hljs-name\"\u003Eawait\u003C\u002Fspan\u003E promise}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E正在请求中...\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{:then res}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E返回的内容\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{res}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{:catch error}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E请求出现异常\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-tag\"\u003E{\u002F\u003Cspan class=\"hljs-name\"\u003Eawait\u003C\u002Fspan\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n\n\u002F\u002F 抑或者，你不需要展示loading以及catch错误的话，可以直接then出来\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-tag\"\u003E{#\u003Cspan class=\"hljs-name\"\u003Eawait\u003C\u002Fspan\u003E promise then res}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E返回的内容\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{res}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-tag\"\u003E{\u002F\u003Cspan class=\"hljs-name\"\u003Eawait\u003C\u002Fspan\u003E}\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E事件处理。通过on定义符进行事件绑定。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E&lt;\u003Cspan class=\"hljs-keyword\"\u003Ebutton\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eon\u003C\u002Fspan\u003E:click={事件名}&gt;点击&lt;\u002F\u003Cspan class=\"hljs-keyword\"\u003Ebutton\u003C\u002Fspan\u003E&gt;\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F on后面接上原生的事件就好了，比如click、mousemove等\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 事件名可以替换为代码块，如\u003C\u002Fspan\u003E\n&lt;\u003Cspan class=\"hljs-keyword\"\u003Ebutton\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eon\u003C\u002Fspan\u003E:click={e =&gt; {\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 对变量进行操作}&gt;点击&lt;\u002Fbutton&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E有些框架由于性能的原因建议不要用行内的方式写事件，尤其是在循环里面。但svelte并没有这个问题，你可以直接用而不用担心那些琐碎，svelte总会做到最好。\u003C\u002Fp\u003E\n\u003Cp\u003E事件修饰符，可以对事件进行几个有用的修饰。以previewDefault举例：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eon:click\u003C\u002Fspan\u003E|\u003Cspan class=\"hljs-attr\"\u003EpreventDefault\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E{事件名}\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E点击\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col\u003E\n\u003Cli\u003EpreventDefault 阻止默认事件。\u003C\u002Fli\u003E\n\u003Cli\u003EstopPropagation 阻止事件冒泡。\u003C\u002Fli\u003E\n\u003Cli\u003Epassive 优化对touch、wheel事件的滚动表现。\u003C\u002Fli\u003E\n\u003Cli\u003Ecapture 在 \u003Cem\u003Ecapture\u003C\u002Fem\u003E 阶段而不是\u003Cem\u003Ebubbling\u003C\u002Fem\u003E 阶段触发事件处理程序。\u003C\u002Fli\u003E\n\u003Cli\u003Eonce 事件只运行一次就删除绑定。\u003C\u002Fli\u003E\n\u003Cli\u003Eself 仅当 event.target 是其本身时才执行。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E以上修饰符可以串联使用。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E组件通信。老生常谈，业务中遇到的太多了。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 父组件 parent.svelte\u003C\u002Fspan\u003E\n&lt;script&gt;\n    \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E child \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002Fchild.svelte&#x27;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EsayHello\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Ename\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\u003Cspan class=\"hljs-string\"\u003E`Hi, \u003Cspan class=\"hljs-subst\"\u003E${name}\u003C\u002Fspan\u003E`\u003C\u002Fspan\u003E)\n  }\n&lt;\u002Fscript&gt;\n\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Echild\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eon:say\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E{sayHello}\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Echild\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 子组件 child.svelte\u003C\u002Fspan\u003E\n\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 子组件要调用父组件的事件，需要用到事件派发器\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E { createEventDispatcher } \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;svelte&#x27;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E dispatch = createEventDispatcher()\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EsayHello\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这里的话有些类似vue中的$emit\u003C\u002Fspan\u003E\n    dispatch(\u003Cspan class=\"hljs-string\"\u003E&#x27;say&#x27;\u003C\u002Fspan\u003E, {\n      \u003Cspan class=\"hljs-attr\"\u003Ename\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;我&#x27;\u003C\u002Fspan\u003E\n    })\n  }\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eon:click\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E{sayHello}\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E点击\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果是dom事件，那么子组件只要不具名，就可以直接调用父组件的事件\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 父组件事件定义\u003C\u002Fspan\u003E\n\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eon:click\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E{eventName}\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E点击\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果子组件想直接调用dom事件eventName，则\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 子组件\u003C\u002Fspan\u003E\n\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eon:click\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E点击\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E如果组件嵌套，需要多次转发事件的话，可以把中间的组件都加一个on:eventName，那么事件名为eventName的事件就会一直转发到目标组件上。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cem\u003E2021-06-01 23:20\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E12.双向绑定。和vue原理对比TODO。在svelte中的双向绑定，只需要通过bind修饰就可以。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E name = \u003Cspan class=\"hljs-string\"\u003E&#x27;cat&#x27;\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Einput\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ebind:value\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E{name}\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Einput\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E表单元素都可以通过bind进行双向绑定，比如checkbox等。\u003C\u002Fp\u003E\n\u003Cp\u003E对数组对象，可以直接对值进行循环绑定，这个和vue类似。\u003C\u002Fp\u003E\n\u003Cp\u003E每个块级标签都可以对\u003Ccode\u003EclientWidth\u003C\u002Fcode\u003E、\u003Ccode\u003EclientHeight\u003C\u002Fcode\u003E、\u003Ccode\u003EoffsetWidth\u003C\u002Fcode\u003E、\u003Ccode\u003EoffsetHeight\u003C\u002Fcode\u003E进行绑定。但绑定值只是可读，直接赋值不会进行更新。可以用在读取块元素的尺寸后用于展示等业务上。\u003C\u002Fp\u003E\n\u003Col start=\"13\"\u003E\n\u003Cli\u003E\u003Cp\u003E组件绑定。这个有点意思，我觉得像是vue中的.sync修饰。可以做到在父组件中直接读取子组件export的值。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E生命周期。类比vue的生命周期，svelte的生命周期钩子还是很容易理解的。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E在svelte中，每一个组件都有其完整的生命周期，周期的函数需要从svelte中引入。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EonMount\u003C\u002Fcode\u003E。使用最多的应该是\u003Ccode\u003EonMount\u003C\u002Fcode\u003E钩子，它在组件渲染到dom后执行。可以在这个周期内进行数据的请求操作，这是svelte所推荐的，如果把请求操作放到script内则不好，因为如果需要服务端渲染的话，生命周期函数是没法在服务端渲染过程中执行的。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EonDestroy\u003C\u002Fcode\u003E。组件销毁的时候调用，可以对计时器进行清除等操作。文档中有一个有意思的封装，可以把计数器的操作和组件销毁时销毁计时器一起封装。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 比如封装到util.js中\u003C\u002Fspan\u003E\nimoprt { onDestroy } from &#x27;svelte&#x27;\nexport \u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E on\u003Cspan class=\"hljs-constructor\"\u003EInterval(\u003Cspan class=\"hljs-params\"\u003Ecallback\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Etime\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n  const interval = set\u003Cspan class=\"hljs-constructor\"\u003EInterval(\u003Cspan class=\"hljs-params\"\u003Ecallback\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Etime\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n  on\u003Cspan class=\"hljs-constructor\"\u003EDestroy(()\u003C\u002Fspan\u003E =&gt; {\n    clear\u003Cspan class=\"hljs-constructor\"\u003EInterval(\u003Cspan class=\"hljs-params\"\u003Einterval\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n  })\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E那么在组件中就可以直接引入onInterval并调用，那就不需要关切组件销毁的时候有没有把计时器进行销毁。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{ onInterval }\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"javascript\"\u003E \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002Futil.js&#x27;\u003C\u002Fspan\u003E\n  onInterval(\u003Cspan class=\"hljs-function\"\u003E() =&gt;\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E, 1000)\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EbeforeUpdate\u003C\u002Fcode\u003E、\u003Ccode\u003EafterUpdate\u003C\u002Fcode\u003E。该钩子在DOM渲染完成前执行。场景例如：渲染标签的滚动位置。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Etick\u003C\u002Fcode\u003E。可以随时调用，是一个带有resolve方法的promise，解释是每当组件pendding状态变化就会立即提现到DOM中，类似于vue的\u003Ccode\u003E$nextTick()\u003C\u002Fcode\u003E?\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Col start=\"15\"\u003E\n\u003Cli\u003E\u003Cp\u003Estore。svelte自带了壮态管理，由引入自svelte\u002Fstore的writable定义：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E可写store\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Eimoprt { writable } \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;svelte\u002Fstore&#x27;\u003C\u002Fspan\u003E\n\nexport \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ecount\u003C\u002Fspan\u003E = writable(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 默认值为0，这里注意可以使用const进行定义，即便count是一个数值\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在组件中，count具备update、set方法，分别表示更新和重置值。\u003C\u002Fp\u003E\n\u003Cp\u003E在store创建后，开启的事件订阅，需要在不使用的时候销毁。我们可以在组件的onDestroy周期中取消订阅，避免内存溢出。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{ onDestroy }\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"javascript\"\u003E \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;svelte&#x27;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{ count }\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"javascript\"\u003E \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002Fstore.js&#x27;\u003C\u002Fspan\u003E\n  \n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E countValue\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E unsubscribe = count.subscribe(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Evalue\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{ \u002F\u002F 手动订阅\n    count_value = value\n  }\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"javascript\"\u003E)\n  onDestroy(unsubscribe) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 在组件销毁的时候取消订阅\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E那如果每一个状态都需要这么订阅和销毁的话，就太冗余了，svelte提供一个$符。可以对状态自动进行订阅和取消订阅。yyds。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escirpt\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    imoprt \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{ count }\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E from &#x27;.\u002Fstore.js&#x27;\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escirpt\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{$count}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E \u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E只读store\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E只需在定义的时候，由writable改为readable就可以定义一个只读的store。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E防止暴露set、update方法的自定义store\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Eimport { writable } from \u003Cspan class=\"hljs-string\"\u003E&#x27;svelte\u002Fstore&#x27;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EcreateCount\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  const { subscribe, set, update } = writable(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E {\n    subscribe,\n    \u003Cspan class=\"hljs-attr\"\u003Eincrement\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E update(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003En\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E n + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E),\n    \u003Cspan class=\"hljs-attr\"\u003Edecrement\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E update(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003En\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E n - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E),\n    \u003Cspan class=\"hljs-attr\"\u003Ereset\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E set(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E)\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Eclass指令。在svelte中动态设置class或者说其余的dom属性，会和vue有一些不一样。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E&lt;\u003Cspan class=\"hljs-keyword\"\u003Ediv\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;{isTrue ? &#x27;true-class&#x27; : &#x27;false-class&#x27;}&quot;\u003C\u002Fspan\u003E&gt;\n  name\n&lt;\u002F\u003Cspan class=\"hljs-keyword\"\u003Ediv\u003C\u002Fspan\u003E&gt;\n&lt;\u003Cspan class=\"hljs-keyword\"\u003Ediv\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E:selected=\u003Cspan class=\"hljs-string\"\u003E&quot;{isTrue}&quot;\u003C\u002Fspan\u003E&gt; \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 之后留意如何设置camel-case的class名\u003C\u002Fspan\u003E\n  name\n&lt;\u002F\u003Cspan class=\"hljs-keyword\"\u003Ediv\u003C\u002Fspan\u003E&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E组件插槽，和vue的思想一样，这里看文档注意多个插槽怎么具名。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u002F\u002F 例如slot.svelte\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Eslot\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ename\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;slot-a&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Eslot\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\n\u002F\u002F 调用的组件\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003ESlot\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ediv\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eslot\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;slot-a&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    这里是一个具名插槽\n  \u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ediv\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003ESlot\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E18.context API。通过context api，可以跨越组件进行通信。具备setContext和getContext两个api。如果在一个组件中调用了setContext(key, context)，那么，在所有该子组件中都可以调用该context。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 父组件中\u003C\u002Fspan\u003E\nset\u003Cspan class=\"hljs-constructor\"\u003EContext(\u003Cspan class=\"hljs-params\"\u003Ekey\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Econtext\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 任意的子组件中\u003C\u002Fspan\u003E\nconst context = get\u003Cspan class=\"hljs-constructor\"\u003EContext(\u003Cspan class=\"hljs-params\"\u003Ekey\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"19\"\u003E\n\u003Cli\u003E\u003Cp\u003E特殊标签。svelte具备一些特殊的标签。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003Esvelte:self。允许组件递归的去包含自己本身。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Esvelte:component。动态组件，与vue类似的用法，通过传入this的组件名，动态挂在组件。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Esvelte:component\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ethis\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E{compnentName}\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Esvelte:component\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Esvelte:window。把它当作是一个window对象，可以在该标签上进行事件的监听等操作。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Esvelte:body。和window的标签一样，可以在document.body上添加事件监听。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Esvelte:head。允许你在页面的\u003Chead\u003E标签内插入内容。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E\u003Cspan class=\"hljs-section\"\u003E&lt;svelte:head&gt;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-section\"\u003E&lt;link&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-section\"\u003E&lt;\u002Flink&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-section\"\u003E&lt;\u002Fsvelte:head&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E需要注意的是，在服务端渲染下，这个标签的内容将会单独返回到html中。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"},{title:"预备回归写博客啦",slug:"2021_04_ready-back",description:"回归博客，整理项目代码结构",keywords:"sapper，blog，return，回归，整理",labels:[],date:"2021-04-24",path:"2021\u002F04\u002Fready-back.md",html:"\u003Cp\u003E日子趋于平稳，技术栈也比较稳定，外加自己有一些些懒惰，所以博客停更蛮久了。在github查看了这个项目，发现还有几个人star了，所以我决定需要好好整理一下这个项目。\u003C\u002Fp\u003E\n\u003Ch2 id=\"计划\"\u003E计划\u003C\u002Fh2\u003E\n\u003Cp\u003E更新博客内容次于整理sapper-blog这个项目。看了下是去年写的代码，问题主要存在有：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E项目结构混论。\u003C\u002Fli\u003E\n\u003Cli\u003E代码布局和提示性差。\u003C\u002Fli\u003E\n\u003Cli\u003E生成的静态内容样式差。\u003C\u002Fli\u003E\n\u003Cli\u003E存在一些不必要的内容。\u003C\u002Fli\u003E\n\u003Cli\u003E编写体验不够完善。\u003C\u002Fli\u003E\n\u003Cli\u003E。。。。。。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E后续主要的计划有：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E好好认真了解和熟悉svelte以及sapper的语法。\u003C\u002Fli\u003E\n\u003Cli\u003E整理项目结构和代码。\u003C\u002Fli\u003E\n\u003Cli\u003E移除ts支持。\u003C\u002Fli\u003E\n\u003Cli\u003E优化静态博客样式。\u003C\u002Fli\u003E\n\u003Cli\u003E优化博客编写的体验，现在有些一头雾水。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"整理内容\"\u003E整理内容\u003C\u002Fh2\u003E\n\u003Cp\u003E在优化项目的过程中，整理一下相关知识点的代码，如果有必要的内容，我会整理到博客之中。\u003C\u002Fp\u003E\n"},{title:"苹果新手机发布会",slug:"2020_10_apple",description:"围观10月14日苹果发布会，我对此有什么看法。",keywords:"Apple，iphone 12，homepod",labels:[],date:"2020-10-14",path:"2020\u002F10\u002Fapple.md",html:"\u003Cp\u003E好久没更新博客内容了。懒了些，加之最近公司项目迭代很多，虽然可以把控但要写的代码还是挺多的。  \u003C\u002Fp\u003E\n\u003Cp\u003E今天凌晨苹果开了一个线上的发布会，我特意晚一些睡觉，在1点的时候看了会直播，当时有个小疑问：为啥B站要屏蔽up主的苹果发布会转播呢？因为屏蔽了，加上内容和wb上讨论的几乎无差，所以我就关闭手机乖乖睡觉去了【实在是困】。\u003C\u002Fp\u003E\n\u003Ch2 id=\"新产品的看法\"\u003E新产品的看法\u003C\u002Fh2\u003E\n\u003Cp\u003Eiphone系列。由于我没有换机的需求，对于新的手机，第一我觉得外观虽然延续了4s那一代，但我觉得配合全面屏的iphone有不错的视觉体验。第二是12是走量，颜色多，但就个人而言，我会选择尺寸较小的mini。当然，如果对拍照需求大的，直接上pro。\u003C\u002Fp\u003E\n\u003Cp\u003Ehomepod。发布会首先发布的就是homepod，个人很喜欢，已经考虑以后会在房间设备和家里添加多个homepod。外观喜欢，小巧玲珑。放家里感觉挺好看。【吃灰神器】\u003C\u002Fp\u003E\n\u003Ch2 id=\"吐槽\"\u003E吐槽\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E没有双卡。\u003C\u002Fli\u003E\n\u003Cli\u003E为了低碳和环保，苹果决定iphone13不再附赠手机。\u003C\u002Fli\u003E\n\u003Cli\u003E个人不喜oled屏幕，lcd真香。\u003C\u002Fli\u003E\n\u003Cli\u003E5g貌似国行有阉割。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"},{title:"safari出现未设置title属性却显示ttile弹窗的问题",slug:"2020_07_text-ellipsis-title",description:"在safari浏览器下，出现dom未设置title属性，但hover过去会显示一个title的问题。",keywords:"css, text ellipsis, title popover, no title attribute，safari",labels:[a],date:"2020-07-06",path:"2020\u002F07\u002Ftext-ellipsis-title.md",html:"\u003Cp\u003E在safari浏览器下，出现dom未设置title属性，但hover过去会显示一个title的问题。如图：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F86565425-634bc400-bf9a-11ea-8daf-76cba18e2936.jpg\" alt=\"Xnip2020-07-06_14-08-29\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E一开始一直往title属性上找问题，但dom的属性结构光溜溜的，并没有任何title有关的属性。这个问题在chrome和firefox都没有，只有在safari上出现。\u003C\u002Fp\u003E\n\u003Ch2 id=\"问题所在\"\u003E问题所在\u003C\u002Fh2\u003E\n\u003Cp\u003E经过一顿排查，发现是css设置为文本超出省略显示后才会有这个问题。\u003C\u002Fp\u003E\n\u003Cp\u003E我们常用到文本超出省略的设置，如：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-css\"\u003E\u003Cspan class=\"hljs-selector-class\"\u003E.text-ellipsis\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-attribute\"\u003Eoverflow\u003C\u002Fspan\u003E: hidden;\n  \u003Cspan class=\"hljs-attribute\"\u003Etext-overflow\u003C\u002Fspan\u003E: ellipsis;\n  \u003Cspan class=\"hljs-attribute\"\u003Eword-break\u003C\u002Fspan\u003E: keep-all;\n  \u003Cspan class=\"hljs-attribute\"\u003Ewhite-space\u003C\u002Fspan\u003E: nowrap;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"解决办法\"\u003E解决办法\u003C\u002Fh2\u003E\n\u003Cp\u003E在\u003Ccode\u003Etext-ellipsis\u003C\u002Fcode\u003E包裹的元素中添加一个空的block元素。如：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ediv\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eclass\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;text-ellipsis ...&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Espan\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Espan\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    this is a long text!!!!!!!!\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ediv\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Estyle\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"css\"\u003E\n\u003Cspan class=\"hljs-selector-class\"\u003E.text-ellipsis\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-attribute\"\u003Eoverflow\u003C\u002Fspan\u003E: hidden;\n    \u003Cspan class=\"hljs-attribute\"\u003Etext-overflow\u003C\u002Fspan\u003E: ellipsis;\n    \u003Cspan class=\"hljs-attribute\"\u003Eword-break\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-attribute\"\u003Ewhite-space\u003C\u002Fspan\u003E: nowrap;\n}\n\u003Cspan class=\"hljs-selector-class\"\u003E.text-ellipsis\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-tag\"\u003Espan\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-attribute\"\u003Edisplay\u003C\u002Fspan\u003E: block;\n}\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Estyle\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"},{title:"最近安装宽带的问题",slug:"2020_07_boardband",description:"在外漂泊，定居之后的宽带怎么处理？经过一小阵子的了解，觉得开通宽带虽然简单，但利益还是有好多。",keywords:"宽带，租房，光纤，小区",labels:["随想"],date:"2020-07-04",path:"2020\u002F07\u002Fboardband.md",html:"\u003Cp\u003E上一个租客留给我大概有3个月的免费宽带【白嫖】。入住新地已经过去好几个月，前天起床发现WIFI无法上网，小爱同学也没有了声音。我也趁着这次宽带安装的机会，了解下一些有关租房网络的实践。\u003C\u002Fp\u003E\n\u003Ch2 id=\"能不能用4g代替宽带？\"\u003E能不能用4G代替宽带？\u003C\u002Fh2\u003E\n\u003Cp\u003E4g有非常好的便携性，不需要安装，不需要人工。直接买4g卡以及4g移动路由器插上就可以直接上网。在2020年，我第一时间就想到这个方案，因为我目前用的是联通卡，带有一些app免流的功能，一个月下来费用基本不会超过30元。况且呆在家的时间很少，大部分在家的时间都在睡觉，而在上班的地方有WIFI。\u003C\u002Fp\u003E\n\u003Cp\u003E另外的一些原因：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E不玩游戏，也就是不需要很低的延迟。\u003C\u002Fli\u003E\n\u003Cli\u003E房子不会很大，如果4g信号不好，再不济也可以通过桥接方式扩大信号。\u003C\u002Fli\u003E\n\u003Cli\u003E没有麻烦的服务，开通后自由使用，不用有退宽带的问题。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E那4g流量卡代替宽带是不是就非常完美了呢？\u003C\u002Fp\u003E\n\u003Cp\u003E😯，找了相关的资料，发现并不是这样。\u003C\u002Fp\u003E\n\u003Cp\u003E \u003Cstrong\u003E其实4g卡配4g路由是可以达到在租房内上网的条件的\u003C\u002Fstrong\u003E。但问题就出在流量上。如果是所谓的物联网卡，很容易出现跑路而不能用的问题。当然更大的问题是限速，达到某个流量值之后会出现令人恶心的限速。而我个人的需求，很大可能会有看剧看电影，下载体积大的安装包，比如xCode就有5g以上。所以我最后慢慢放弃这个方案，乖乖的去新报装宽带。\u003C\u002Fp\u003E\n\u003Ch2 id=\"宽带\"\u003E宽带\u003C\u002Fh2\u003E\n\u003Cp\u003E通过网上和手机wx公众号的一些运营商的咨询，发现三大运营商在100M的宽带费用上都普遍较高。而对于这些宽带提供商，在新报装的时候都会有让我难以理解的上门安装费和调试费。我所在小区内已经有可以直接连接上网的端口，甚至上家租客已留下一些上网的设备，也就是说，只需要关联一个账号，将上网的端口和我本地的端口能关联就好了。这看起来简直就完全不需要人工，如果需要，我想也是基本的在电脑上动动配置就好了。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E但看到各种宽带的套餐上，全都包含了比较高的宽带安装和调试费。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E我觉得难以理解，但综合更方面的因素之后，还是选择宽带的报装，😠。\u003C\u002Fp\u003E\n"},{title:"Visual Studio Code快速上下滚动光标",slug:"2020_06_vscode-up-down-quickly",description:"默认上下按键滚动光标是在太慢，有方法可以加快滚动速度。",keywords:"vs code, scroll,speed up, up,down,cursor",labels:[b],date:"2020-06-30",path:"2020\u002F06\u002Fvscode-up-down-quickly.md",html:"\u003Cp\u003E设置光标快速滚动，可以在少动鼠标的情况下快速滚动到目标代码处，结合常用的快捷键，可以提高编码效率。\u003C\u002Fp\u003E\n\u003Ch2 id=\"设置\"\u003E设置\u003C\u002Fh2\u003E\n\u003Cp\u003E在vscode，打开设置-键盘快捷方式，点击下图打开\u003Ca target='_blank'  href=\"https:\u002F\u002Fcode.visualstudio.com\u002Fdocs\u002Fgetstarted\u002Fkeybindings#_advanced-customization\"\u003Ekeybindings.json\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F30\u002F5IA78WnLfSpmeJP.jpg\" alt=\"Xnip2020-06-30_17-21-04.jpg\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E在json底部添加：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-json\"\u003E  {\n    \u003Cspan class=\"hljs-string\"\u003E&quot;key&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;cmd+up&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;command&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;cursorMove&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;args&quot;\u003C\u002Fspan\u003E: {\n      \u003Cspan class=\"hljs-string\"\u003E&quot;to&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;up&quot;\u003C\u002Fspan\u003E,\n      \u003Cspan class=\"hljs-string\"\u003E&quot;by&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;line&quot;\u003C\u002Fspan\u003E,\n      \u003Cspan class=\"hljs-string\"\u003E&quot;value&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E\n    },\n    \u003Cspan class=\"hljs-string\"\u003E&quot;when&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;editorTextFocus&quot;\u003C\u002Fspan\u003E\n  },\n  {\n    \u003Cspan class=\"hljs-string\"\u003E&quot;key&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;cmd+down&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;command&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;cursorMove&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;args&quot;\u003C\u002Fspan\u003E: {\n      \u003Cspan class=\"hljs-string\"\u003E&quot;to&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;down&quot;\u003C\u002Fspan\u003E,\n      \u003Cspan class=\"hljs-string\"\u003E&quot;by&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;line&quot;\u003C\u002Fspan\u003E,\n      \u003Cspan class=\"hljs-string\"\u003E&quot;value&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E\n    },\n    \u003Cspan class=\"hljs-string\"\u003E&quot;when&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;editorTextFocus&quot;\u003C\u002Fspan\u003E\n  }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E可以将cmd更改为未占用或者舒服的按键。\u003C\u002Fp\u003E\n\u003Cp\u003E可以将value更改为自己舒适的一次按键滚动行数。\u003C\u002Fp\u003E\n\u003Cp\u003E找了好久的办法，就想实现快速滚动，因为平时如果键盘和鼠标切换多了，总有种\u003Cstrong\u003E代码输出伤害溢出大\u003C\u002Fstrong\u003E的感觉。\u003C\u002Fp\u003E\n"},{title:"博客评论更改为valine并增加评论推送",slug:"2020_06_valine-and-notifications",description:"评论模块由gitalk转为valine，通过techulus的push进行评论推送",keywords:"sapper,blog,techulus push,valine,comments",labels:[a],date:"2020-06-29",path:"2020\u002F06\u002Fvaline-and-notifications.md",html:"\u003Cp\u003E通过一点时间的使用，发现gitalk可以解决静态博客评论问题，是挺方便的，但综合考虑下，存在以下两个缺点：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E需要github账号登录。\u003C\u002Fli\u003E\n\u003Cli\u003E访问非常慢。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E有意间，发现一个评论插件很适合静态博客植入：\u003Ca target='_blank'  href=\"https:\u002F\u002Fvaline.js.org\u002F\"\u003EValine\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E新样式\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F29\u002FRiSBpcyAQD1kXCN.jpg\" alt=\"style\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E新评论模块默认很清新，和我当前的样式较为符合，只做了一点点的样式覆盖。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-css\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F* valine 样式覆盖 *\u002F\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-selector-class\"\u003E.v\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-selector-attr\"\u003E[data-class=v]\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.vwrap\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-attribute\"\u003Eborder\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E1px\u003C\u002Fspan\u003E solid rgba(\u003Cspan class=\"hljs-number\"\u003E255\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E62\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E0.1\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-meta\"\u003E!important\u003C\u002Fspan\u003E;\n}\n\u003Cspan class=\"hljs-selector-class\"\u003E.v\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-selector-attr\"\u003E[data-class=v]\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.vwrap\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.vheader\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.vinput\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-attribute\"\u003Eborder-bottom\u003C\u002Fspan\u003E: none \u003Cspan class=\"hljs-meta\"\u003E!important\u003C\u002Fspan\u003E;\n}\n\u003Cspan class=\"hljs-selector-class\"\u003E.v\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-selector-attr\"\u003E[data-class=v]\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.txt-right\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-attribute\"\u003Edisplay\u003C\u002Fspan\u003E: none \u003Cspan class=\"hljs-meta\"\u003E!important\u003C\u002Fspan\u003E;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"推送\"\u003E推送\u003C\u002Fh2\u003E\n\u003Cp\u003E在valine的文档中，有提到可以用一个扩展的valine-admin以实现评论通知功能。我在leancloud尝试了发现比较麻烦。外加之前使用GitHub Actions用到了一个推送服务实现了在action成功之后推送部署成功的通知到手机上。那是不是可以通过下面的思路去实现评论推送呢？\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fpush.techulus.com\u002F\"\u003EPUSH注册\u003C\u002Fa\u003E注册后使用免费的plan，可以每月100条推送限额。要推送到手机，只需要调用提供的接口还有下载一个手机APP就好了。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E要知道，做到推送到手机，只需要POST下面的接口：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Ehttps:\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003Epush.techulus.com\u003Cspan class=\"hljs-regexp\"\u003E\u002Fapi\u002F\u003C\u002Fspan\u003Ev1\u003Cspan class=\"hljs-regexp\"\u003E\u002Fnotify\u002F\u003C\u002Fspan\u003E{YOU API KEY}?title=Push by Techulus&amp;body=This is your first push notification\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col\u003E\n\u003Cli\u003E在评论接口POST请求之后，在lean端通过类似拦截\u002F触发的方法调用推送接口。\u003C\u002Fli\u003E\n\u003Cli\u003E在网页端拦截POST请求，在评论发出之后，在调用推送接口。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E在查看对应文档之后，第一种方式我找不到可行的入口。我想确定数据库入库的逻辑在哪处理的也找不到，所以采用第二种方法。\u003C\u002Fp\u003E\n\u003Ch2 id=\"拦截评论请求\"\u003E拦截评论请求\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E博客引入ajax-hook全局拦截请求\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;https:\u002F\u002Funpkg.com\u002Fajax-hook@2.0.3\u002Fdist\u002Fajaxhook.min.js&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E\u003Cp\u003E在ajax-hook实例上，处理onRequest钩子。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Eah.proxy({\n         \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E请求发起前进入\n         onRequest: (config, handler) =&gt; {\n             \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (config.url.includes(\u003Cspan class=\"hljs-string\"\u003E&#x27;classes\u002FComment&#x27;\u003C\u002Fspan\u003E) &amp;&amp; config.method === \u003Cspan class=\"hljs-string\"\u003E&#x27;POST&#x27;\u003C\u002Fspan\u003E) {\n                 console.log(\u003Cspan class=\"hljs-string\"\u003E&#x27;请求发起前&#x27;\u003C\u002Fspan\u003E, config.body)\n                 fetch(\n                     `https:\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003Epush.techulus.com\u003Cspan class=\"hljs-regexp\"\u003E\u002Fapi\u002F\u003C\u002Fspan\u003Ev1\u003Cspan class=\"hljs-regexp\"\u003E\u002Fnotify\u002F\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-variable\"\u003E${YOU API KEY}\u003C\u002Fspan\u003E?title=\u003Cspan class=\"hljs-variable\"\u003E${location.pathname || &#x27;文章&#x27;}\u003C\u002Fspan\u003E有新回复&amp;body=\u003Cspan class=\"hljs-variable\"\u003E${config.body.substr(12, 30)}\u003C\u002Fspan\u003E`,\n                     {\n                         method: \u003Cspan class=\"hljs-string\"\u003E&#x27;POST&#x27;\u003C\u002Fspan\u003E,\n                         mode: \u003Cspan class=\"hljs-string\"\u003E&#x27;cors&#x27;\u003C\u002Fspan\u003E,\n                         headers: new Headers({\n                             \u003Cspan class=\"hljs-string\"\u003E&#x27;Content-Type&#x27;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;application\u002Fjson&#x27;\u003C\u002Fspan\u003E\n                         })\n                     }\n                 )\n             }\n             handler.\u003Cspan class=\"hljs-keyword\"\u003Enext\u003C\u002Fspan\u003E(config);\n         },\n         \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E请求发生错误时进入，比如超时；注意，不包括http状态码错误，如\u003Cspan class=\"hljs-number\"\u003E404\u003C\u002Fspan\u003E仍然会认为请求成功\n         onError: (err, handler) =&gt; {\n                 handler.\u003Cspan class=\"hljs-keyword\"\u003Enext\u003C\u002Fspan\u003E(err)\n         },\n         \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E请求成功后进入\n         onResponse: (response, handler) =&gt; {\n                 handler.\u003Cspan class=\"hljs-keyword\"\u003Enext\u003C\u002Fspan\u003E(response)\n         }\n     })\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E更多关于ajax-hook的文档，参阅：\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fwendux\u002FAjax-hook\"\u003Eajax-hook\u003C\u002Fa\u003E    \u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"缺点提示\"\u003E缺点提示\u003C\u002Fh2\u003E\n\u003Cp\u003E第一种方式可以很好的保护推送的API KEY，因为有限额，暴露后可以随意调用。第二种比较简单易行。不过，反正push服务免费的话，也不会有损失。如果push服务付费就不要用第二种方法了。\u003C\u002Fp\u003E\n\u003Cp\u003E完成以上操作就可以收到评论推送啦，还是很方便的。如果有更好的免费push服务提供的，可以评论留言，我会很快看到的。\u003C\u002Fp\u003E\n"},{title:p,slug:"2020_06_firebase",description:p,keywords:"firebase,like",labels:[a],date:"2020-06-28",path:"2020\u002F06\u002Ffirebase.md",html:"\u003Cp\u003E想给博客增加一个点赞功能。最后，看起来就是这样：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F28\u002FEj9in7gr5uNHIJO.jpg\" alt=\"like\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E实现这个功能要考虑几个问题：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E没有服务器，接口怎么编写部署？\u003C\u002Fli\u003E\n\u003Cli\u003E博客没有登录，数据库设计的时候怎么识别用户唯一性。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"firebase\"\u003EFirebase\u003C\u002Fh2\u003E\n\u003Cp\u003E对于firebase的介绍，最好是直接进入\u003Ca target='_blank'  href=\"https:\u002F\u002Ffirebase.google.com\"\u003E主站\u003C\u002Fa\u003E开通spark版尝试。\u003C\u002Fp\u003E\n\u003Cp\u003E使用firebase，就可以很好的解决第一个问题。spark方案提供免费的空间支持，对于博客这种量级小，交互少的页面来说再适合不过了。\u003C\u002Fp\u003E\n\u003Cp\u003E如果用过tx云的云开发，就可以知道，其实概念有些相似，甚至在云函数的编写上也有几分相似。\u003C\u002Fp\u003E\n\u003Ch2 id=\"fingerprintjs2\"\u003Efingerprintjs2\u003C\u002Fh2\u003E\n\u003Cp\u003E利用\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Ffingerprintjs\u002Ffingerprintjs2\"\u003Efingerprintjs2\u003C\u002Fa\u003E，可以通过user agent等信息生成用户唯一的一个ID，虽然不能100%保证用户唯一性，但对于无需登录的博客而言，已经足够了。\n生成指纹的主要用法：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-attribute\"\u003EFingerprint2\u003C\u002Fspan\u003E.x\u003Cspan class=\"hljs-number\"\u003E64\u003C\u002Fspan\u003Ehash\u003Cspan class=\"hljs-number\"\u003E128\u003C\u002Fspan\u003E(values.join(&#x27;&#x27;), \u003Cspan class=\"hljs-number\"\u003E31\u003C\u002Fspan\u003E)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"过程\"\u003E过程\u003C\u002Fh2\u003E\n\u003Cp\u003E整个过程，时间大部分花在云函数执行数据库操作语法上。以下前提是开通了firebase的spark方案，开通方式直接明了就不赘述啦。\u003C\u002Fp\u003E\n\u003Ch3 id=\"控制台\"\u003E控制台\u003C\u002Fh3\u003E\n\u003Cp\u003E需要在控制台创建你的一个项目，创建好项目之后再执行下面的步骤。\u003C\u002Fp\u003E\n\u003Ch3 id=\"函数（functions）编写\"\u003E函数（functions）编写\u003C\u002Fh3\u003E\n\u003Cp\u003E相关代码可以查看：\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002FGzhiYi\u002Fblog-like\u002Fblob\u002Fmaster\u002Ffunctions\u002Findex.js\"\u003Eblog-like\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E安装Firebase CLI工具以初始化函数仓库。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Enpm \u003Cspan class=\"hljs-keyword\"\u003Einstall\u003C\u002Fspan\u003E -g firebase-tools\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E登录\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-attribute\"\u003Efirebase login\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E创建一个空目录，然后初始化这个目录，例如目录名为blog-like\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Emkdir blog-\u003Cspan class=\"hljs-meta\"\u003Elike\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-variable\"\u003E&amp;&amp;\u003C\u002Fspan\u003E cd blog-\u003Cspan class=\"hljs-meta\"\u003Elike\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-variable\"\u003E&amp;&amp;\u003C\u002Fspan\u003E firebase init\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E执行init命令后会提示选择新建项目的一些规则。（以下是规则过程）\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Eq: Which Firebase CLI features do you want to set up for this folder? Press Space to select features, then Enter to confirm your choices.\u003C\u002Fcode\u003E\n\u003Ccode\u003Ea: 选择Firestore: Deploy rules and create indexes for Firestore以及Functions: Configure and deploy Cloud Functions\u003C\u002Fcode\u003E  \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Eq: Please select an option:\u003C\u002Fcode\u003E\n\u003Ccode\u003Ea: Use an existing project，随后选择在控制台创建的项目。\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E随后几个按enter就好了。\u003C\u002Fp\u003E\n\u003Col start=\"4\"\u003E\n\u003Cli\u003E函数编写。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E需要两个接口，一个是新增点赞接口，路由为：\u003Ccode\u003E\u002FnewLike\u003C\u002Fcode\u003E，一个是获取点赞数据的接口，路由为：\u003Ccode\u003E\u002FgetLikes\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EnewLike。先判断该用户是否已经点过赞。需要存储的数据：文章标题、点赞时间、用户指纹。\u003C\u002Fli\u003E\n\u003Cli\u003EgetLikes。先获取该文章点赞总数，在判断用户是否已经点过赞。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E有了以下基本代码：\u003C\u002Fp\u003E\n\u003Cp\u003E点赞数据表：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-json\"\u003E{\n    \u003Cspan class=\"hljs-attribute\"\u003Eid:\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-string\"\u003E 用户指纹，\n    likeTime\u003C\u002Fspan\u003E：点赞时间，\n    postTitle：文章标题\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EnewLike，创建点赞数据：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Edb\u003Cspan class=\"hljs-built_in\"\u003E.collection\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&#x27;like&#x27;\u003C\u002Fspan\u003E)\n  .\u003Cspan class=\"hljs-keyword\"\u003Ewhere\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;postTitle&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E&quot;==&quot;\u003C\u002Fspan\u003E, request.body.title)\n  .get()\n  .\u003Cspan class=\"hljs-keyword\"\u003Ethen\u003C\u002Fspan\u003E(res =&gt; {\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E isLike =\u003Cspan class=\"hljs-built_in\"\u003E false\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Etry\u003C\u002Fspan\u003E {\n    \u002F\u002F 判断是否已经点赞过\n    res.forEach\u003Cspan class=\"hljs-built_in\"\u003E(doc\u003C\u002Fspan\u003E =&gt; {\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003E(doc\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-built_in\"\u003E.id\u003C\u002Fspan\u003E === request.body\u003Cspan class=\"hljs-built_in\"\u003E.id\u003C\u002Fspan\u003E &amp;&amp; !isLike) {\n        isLike =\u003Cspan class=\"hljs-built_in\"\u003E true\u003C\u002Fspan\u003E\n      }\n    })\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!isLike) {\n      \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E docRef = db\u003Cspan class=\"hljs-built_in\"\u003E.collection\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&#x27;like&#x27;\u003C\u002Fspan\u003E)\u003Cspan class=\"hljs-built_in\"\u003E.doc\u003C\u002Fspan\u003E(params\u003Cspan class=\"hljs-built_in\"\u003E.id\u003C\u002Fspan\u003E);\n      docRef.set({\n        postTitle: params.title,\n        likeTime: new Date().toLocaleString()\n      });\n      response.send({\n        data: \u003Cspan class=\"hljs-string\"\u003E&#x27;like success!&#x27;\u003C\u002Fspan\u003E,\n        code: \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n      })\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n      response.send({\n        data: \u003Cspan class=\"hljs-string\"\u003E&#x27;&#x27;\u003C\u002Fspan\u003E,\n        message: \u003Cspan class=\"hljs-string\"\u003E&#x27;like 过啦&#x27;\u003C\u002Fspan\u003E,\n        code: \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\n      })\n    }\n  } \u003Cspan class=\"hljs-keyword\"\u003Ecatch\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003E(error\u003C\u002Fspan\u003E) {\n    console.log(\u003Cspan class=\"hljs-string\"\u003E&#x27;error&#x27;\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-built_in\"\u003E error\u003C\u002Fspan\u003E)\n  }\n})\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EgetLikes，获取点赞数据：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Edb\u003Cspan class=\"hljs-built_in\"\u003E.collection\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&#x27;like&#x27;\u003C\u002Fspan\u003E)\n  .\u003Cspan class=\"hljs-keyword\"\u003Ewhere\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&quot;postTitle&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E&quot;==&quot;\u003C\u002Fspan\u003E, title)\n  .get()\n  .\u003Cspan class=\"hljs-keyword\"\u003Ethen\u003C\u002Fspan\u003E(res =&gt; {\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E isLike =\u003Cspan class=\"hljs-built_in\"\u003E false\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Etry\u003C\u002Fspan\u003E {\n    res.forEach\u003Cspan class=\"hljs-built_in\"\u003E(doc\u003C\u002Fspan\u003E =&gt; {\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003E(doc\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-built_in\"\u003E.id\u003C\u002Fspan\u003E ===\u003Cspan class=\"hljs-built_in\"\u003E id\u003C\u002Fspan\u003E &amp;&amp; !isLike) {\n        isLike =\u003Cspan class=\"hljs-built_in\"\u003E true\u003C\u002Fspan\u003E\n      }\n    })\n  } \u003Cspan class=\"hljs-keyword\"\u003Ecatch\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003E(error\u003C\u002Fspan\u003E) {\n    console.log(\u003Cspan class=\"hljs-string\"\u003E&#x27;error&#x27;\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-built_in\"\u003E error\u003C\u002Fspan\u003E)\n  }\n  response.send({\n    data: res.size,\n    isLike,\n    message: \u003Cspan class=\"hljs-string\"\u003E&#x27;oooooooook&#x27;\u003C\u002Fspan\u003E,\n    code: \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n  })\n})\n  .\u003Cspan class=\"hljs-keyword\"\u003Ecatch\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-built_in\"\u003E(error\u003C\u002Fspan\u003E =&gt; {\n  response.send({\n    data:\u003Cspan class=\"hljs-built_in\"\u003E error\u003C\u002Fspan\u003E,\n    message: request.body,\n    code: \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\n  })\n})\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在函数编写之后，执行命令就可以部署到云端啦。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Efirebase \u003Cspan class=\"hljs-keyword\"\u003Edeploy\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E--only\u003C\u002Fspan\u003E functions\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"用户端\"\u003E用户端\u003C\u002Fh2\u003E\n\u003Cp\u003E在博客页面上生成用户唯一ID后用fetch请求点赞接口就可以了。\u003C\u002Fp\u003E\n\u003Cp\u003E另外，跨域问题需要函数端用上cors处理。详细的都可以在\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002FGzhiYi\u002Fblog-like\"\u003E仓库\u003C\u002Fa\u003E看到。\u003C\u002Fp\u003E\n\u003Ch2 id=\"体验\"\u003E体验\u003C\u002Fh2\u003E\n\u003Cp\u003E最后说一下体验。整个开发过程比较愉快，花了点点时间查阅数据库操作语法。上线尝试访问，发现google的果然访问好慢！\u003C\u002Fp\u003E\n\u003Cp\u003E你可以点击下面clap按钮试试，如果没有，说明网络问题，unreachable。\u003C\u002Fp\u003E\n"},{title:"2020年苹果开发者大会",slug:"2020_06_apple-wwdc-2020",description:"2020 Apple Worldwide Developers Conference",keywords:"apple,2020,wwdc",labels:[d],date:"2020-06-23",path:"2020\u002F06\u002Fapple-wwdc-2020.md",html:"\u003Cp\u003E昨晚苹果线上直播了2020年开发者大会。本次大会给了不少的东西出来。其中最引瞩目的就是宣布自研Mac ARM芯片，从Intel中跳出来。\u003C\u002Fp\u003E\n\u003Cp\u003E这是苹果想统一多平台下的一个大棋。在会之前就有不少的人分析arm架构的处理器会给市场带来什么影响。用户无需考虑太多，而开发者倒会更多的考虑开发兼容性的问题。\u003C\u002Fp\u003E\n\u003Ch2 id=\"苹果生态\"\u003E苹果生态\u003C\u002Fh2\u003E\n\u003Cp\u003E毫无疑问，苹果在生态上走的越来越靠拢，强化多平台优秀的体验拉拢了越来越多的用户。我个人觉得iOS很流畅，能稳定的运行不会忽然卡顿就已经很满足了。但也非常不喜欢苹果的一些缺失的功能。拿着超前的体验做着安卓好几年前就有的功能，不知道iOS开发的执行力是不是不够，但个别地方的体验真的不尽人意。短信不能未读提示，电量不足20%还强制弹窗提示...有好多地方在产品的设计上就有问题。\u003C\u002Fp\u003E\n\u003Cp\u003E后面接触了macOS，我常将它比作是ui更精致，系统更稳定的linux。开发体验非常好，从此告别了windows。windows在开发过程总会遇到不明不白的卡顿问题，terminal也总是让人觉得帧数很低不顺畅。还有一个很重要的优点就是macOS没有广告弹窗，这点就不得不吐槽windows下国产应用肆意妄为弹窗、捆绑了。未来会一直用macOS开发，总结一个词就是相见恨晚。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F23\u002FAgv9hHwZI4eMyqT.jpg\" alt=\"007S8ZIlgy1gg24hxohtfj31c00u07wn.jpg\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E新的macOS ui有了更新，图标改为了圆角矩形，和ipadOS、iOS越来越相似。个人觉得改动并不会丑，大概率又会是真香体验。\u003C\u002Fp\u003E\n"},{title:"使用github actions自动编译部署sapper-blog",slug:"2020_06_sapper-github-actions",description:"使用github actions打包部署sapper项目并部署到github pages。",keywords:"github actions,sapper,github pages",labels:[a],date:"2020-06-22",path:"2020\u002F06\u002Fsapper-github-actions.md",html:"\u003Cp\u003E之前构建好了的\u003Ca target='_blank'  href=\"\u002Fblog\u002F2020-06_build-blog\"\u003E博客\u003C\u002Fa\u003E，通过编写一个脚本实现本地自动化部署。脚本实现的功能就是在本地处理项目的打包并将静态文件推送到远端的\u003Ccode\u003Egh-pages\u003C\u002Fcode\u003E分支以实现静态文件部署。在了解github actions之后，决定增加一个自动化打包部署的workflow。这样就可以将编译打包的操作完全放置在”云端“。\u003C\u002Fp\u003E\n\u003Ch2 id=\"编写workflow配置文件\"\u003E编写workflow配置文件\u003C\u002Fh2\u003E\n\u003Cp\u003E在项目根目录创建\u003Ccode\u003E.github\u002Fworkflows\u002Fmain.yml\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-yaml\"\u003E\u003Cspan class=\"hljs-attr\"\u003Ename:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003EDeploy\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003EGitHub\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003EPages\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-attr\"\u003Eon:\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-attr\"\u003Epush:\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E# push钩子监听的分支，为编译打包的分支\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Ebranches:\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-bullet\"\u003E-\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Efeat\u002Fdev\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-comment\"\u003E# 任务\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-attr\"\u003Ejobs:\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-attr\"\u003Ebuild-and-deploy:\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-comment\"\u003E# 服务器环境：最新版 Ubuntu\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Eruns-on:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Eubuntu-latest\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Esteps:\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E# 拉取代码\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-bullet\"\u003E-\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ename:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003ECheckout\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-attr\"\u003Euses:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Eactions\u002Fcheckout@v2\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-attr\"\u003Ewith:\u003C\u002Fspan\u003E\n          \u003Cspan class=\"hljs-attr\"\u003Epersist-credentials:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E\n\n      \u003Cspan class=\"hljs-comment\"\u003E# 生成静态文件\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-bullet\"\u003E-\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ename:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003EBuild\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-attr\"\u003Erun:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Enpm\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Einstall\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&amp;&amp;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Enpm\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Erun\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&amp;&amp;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Ecp\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E-i\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003ECNAME\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E__sapper__\u002Fexport\u003C\u002Fspan\u003E\n\n      \u003Cspan class=\"hljs-comment\"\u003E# 部署到 GitHub Pages\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-bullet\"\u003E-\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ename:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003EDeploy\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-attr\"\u003Euses:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003EJamesIves\u002Fgithub-pages-deploy-action@releases\u002Fv3\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-attr\"\u003Ewith:\u003C\u002Fspan\u003E\n          \u003Cspan class=\"hljs-attr\"\u003EACCESS_TOKEN:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E${{\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Esecrets.GH_PAGES\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E}}\u003C\u002Fspan\u003E\n          \u003Cspan class=\"hljs-attr\"\u003EBRANCH:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Egh-pages\u003C\u002Fspan\u003E\n          \u003Cspan class=\"hljs-attr\"\u003EFOLDER:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E__sapper__\u002Fexport\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E上面配置有个别要注意的点：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003Ebranches需要设置为要处理的分支。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Ewith\u002FACCESS_TOKEN为github生成的token。\u003C\u002Fp\u003E\n\u003Cp\u003E生成步骤：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fsettings\u002Ftokens\"\u003Egithub右上角的Settings-Developer settings-Personal access tokens\u003C\u002Fa\u003E 点击\u003Ccode\u003EGenerate new token\u003C\u002Fcode\u003E，为了和配置文件对应，token的note需要填写为GH_PAGES，然后勾选scope为repo。\u003C\u002Fp\u003E\n\u003Cp\u003E在博客的仓库的setting设置secret。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F22\u002FjurxoLcUY7p5C8a.jpg\" alt=\"Xnip2020-06-22_14-12-10.jpg\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Ewith\u002FFOLDER为sapper导出export的静态文件目录。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E以上完成之后，将代码push到远端仓库，就可以在Actions看到名字为\u003Ccode\u003EDeploy Github Pages\u003C\u002Fcode\u003E的workflow。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F22\u002FbCxitLWKVlgHD8P.jpg\" alt=\"Xnip2020-06-22_14-15-32.jpg\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Ch2 id=\"体会\"\u003E体会\u003C\u002Fh2\u003E\n\u003Cp\u003EGithub Actions比在公司使用gitlab cicd快了不少，体验非常不错。在写完博客之后，只需要做的，只有将更新的内容push到github就可以了。\u003C\u002Fp\u003E\n"},{title:q,slug:"2020_06_eclipse",description:"日环食，10年一遇，还有自己的一点小思考。",keywords:q,labels:[d],date:"2020-06-21",path:"2020\u002F06\u002Feclipse.md",html:"\u003Cp\u003E或许是不留意，像日环食、日全食这样难得一见的新闻像是突然冒出来一样。今天遇上了10年一遇的日环食。\u003C\u002Fp\u003E\n\u003Cp\u003E当然是不能用眼睛直视啦，不过我在的屋子刚好下午是看不到阳光，外加上兴趣也不是十分大（没有工具，手机也拍不到好，外面又很热很热），就没有特意跑到楼下去看了。倒是朋友圈和微博都有非常多的直播，看他们发的，其实也就够了。新闻也提到了可以用小孔成像原理，就是拿一个带小孔的“东西”放在阳光下就可以看到日食的样子。恰巧有人路过拍下下面有意思的画面。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F21\u002F3y8KMzdDhmQWBtq.jpg\" alt=\"IMG_6668.JPG\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E也不是我现场看到，但如果这是日环食通过小孔成像体验的模样，就颇为奇妙了，奇妙的不仅仅是这一自然现象，还有的是大千世界无与伦比的恰巧带来奇妙的画面。\u003C\u002Fp\u003E\n\u003Ch2 id=\"小思考\"\u003E小思考\u003C\u002Fh2\u003E\n\u003Cp\u003E自己也常常浮想联翩。就拿今天的日环食，我会想为啥星球都是如此的圆；为什么会有那么巧的情况，让太阳被某个星球所刚好阻挡住光线。《星际穿越》是我最喜欢的电影，对于浩瀚太空的探索，显得我们那么渺小，就像男主结尾疑惑是谁把空间放在那的，我也在想，所有的一切都是自然发生的吗？还是有更高的物质将我们赋予生命、时间、还有空间？恐怕人类从开始到结束，都不会知道。走出浮想，想想今天也是天气很好的一天，我总可以好好享受自然带来的乐趣，觉得人类到底也是幸运的。\u003C\u002Fp\u003E\n"},{title:"用sapper构建一个博客",slug:"2020_06_build-blog",description:"用sapper构建一个博客，相关技术：svelte、sapper、tailwindcss、typescript。编写markdown后一键部署到github pages。",keywords:"sapper，博客，svelte，tailwindcss，typescript，github pages，markdown",labels:[a,"技术"],date:"2020-06-20",path:"2020\u002F06\u002Fbuild-blog.md",html:"\u003Cp\u003E发现自己好久没有写博客了。之前在github开了一个仓库，在仓库的\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002FGzhiYi\u002Fblog\u002Fissues\"\u003Eissue区\u003C\u002Fa\u003E写一些内容。issue区体验挺好的，可以refer上项目代码，也可以追加评论。但我想自己写一个博客，不需要很多花里胡哨的功能，只对内容专注，极大的好处是，可以随心所欲的编写自己喜欢的页面样式。刚好最近有接触了下\u003Ca target='_blank'  href=\"https:\u002F\u002Fsvelte.dev\u002F\"\u003Esvelte\u003C\u002Fa\u003E，就顺带的用\u003Ca target='_blank'  href=\"https:\u002F\u002Fsapper.svelte.dev\u002F\"\u003Esapper\u003C\u002Fa\u003E写一个静态页面。\u003C\u002Fp\u003E\n\u003Cp\u003E实现需要用到的知识点\u002F技术：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003Esvelte\u003C\u002Fli\u003E\n\u003Cli\u003Esapper\u003C\u002Fli\u003E\n\u003Cli\u003Etailwindcss\u003C\u002Fli\u003E\n\u003Cli\u003Etypescript\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E后面两点非必须，可以根据自己需要进行增减。\u003C\u002Fp\u003E\n\u003Ch2 id=\"思路\"\u003E思路\u003C\u002Fh2\u003E\n\u003Cp\u003E整体的思路比较简单。\u003C\u002Fp\u003E\n\u003Cp\u003Esapper支持export出静态文件，我只需要将静态文件部署到一个静态站点，首选的就是github pages。sapper导出export有一个好处：\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EStatic doesn&#39;t mean non-interactive — your Svelte components work exactly as they do normally, and you still get all the benefits of client-side routing and prefetching.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003Esapper默认的template就是一个blog，这不是刚好可以拿来起手嘛！但默认的template的 blog内容是固定的数据，大致内容是一个js文件，export一个blog的array。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Eexport const [\n  {\n    title: &#x27;\u003Cspan class=\"hljs-number\"\u003E2020-06\u003C\u002Fspan\u003E\u002Fbuild-blog.md&#x27;,\n    slug: &#x27;\u003Cspan class=\"hljs-number\"\u003E2020-06\u003C\u002Fspan\u003E_build-blog&#x27;, \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 生成的路由路径\u003C\u002Fspan\u003E\n    html: &#x27;&lt;h1 id=\\&quot;用sapper构建一个博客\\&quot;&gt;用sapper构建一个博客&lt;\u002Fh1&gt;&#x27;\n  }\n]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在sapper export之后，可以在\u003Ccode\u003E__sapper__\u002Fexport\u002Fblog\u003C\u002Fcode\u003E看到生成html静态文件。也就意味着最后需要部署到github pages的目录，就是\u003Ccode\u003E__sapper__\u003C\u002Fcode\u003E目录啦。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E可如果要写博客，那肯定也优先选择Markdown。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E所以需要解决的也就是将Markdown文件转为上面提到的js文件。\u003C\u002Fp\u003E\n\u003Ch2 id=\"将markdown转为js文件\"\u003E将Markdown转为js文件\u003C\u002Fh2\u003E\n\u003Cp\u003E需要用到\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fmarkedjs\u002Fmarked\"\u003EMarkedjs\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E使用也是简单粗暴：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E marked = \u003Cspan class=\"hljs-built_in\"\u003Erequire\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&#x27;marked&#x27;\u003C\u002Fspan\u003E)\nmarked.setOptions({\n  \u003Cspan class=\"hljs-attr\"\u003Erenderer\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E marked.Renderer(),\n  \u003Cspan class=\"hljs-attr\"\u003Ehighlight\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Ecode, language\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E hljs = \u003Cspan class=\"hljs-built_in\"\u003Erequire\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&#x27;highlight.js&#x27;\u003C\u002Fspan\u003E)\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E validLanguage = hljs.getLanguage(language) ? language : \u003Cspan class=\"hljs-string\"\u003E&#x27;plaintext&#x27;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E hljs.highlight(validLanguage, code).value\n  },\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ...(more options)\u003C\u002Fspan\u003E\n});\nmarked(markdownString)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E例如markdownString为：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-strong\"\u003E*hello world*\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E将会被转为：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Eem\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003Ehello world\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Eem\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E知道用法之后，只需要通过fs文件操作，将目标的Markdown文件全部push进一个数组，最后将数组写入一个js文件。\u003C\u002Fp\u003E\n\u003Ch2 id=\"读取markdown并写入文件\"\u003E读取Markdown并写入文件\u003C\u002Fh2\u003E\n\u003Cp\u003Enode对操作文件提供了\u003Ccode\u003Ereadir\u003C\u002Fcode\u003E、\u003Ccode\u003EreadFile\u003C\u002Fcode\u003E、\u003Ccode\u003EwriteFile\u003C\u002Fcode\u003E等函数。\u003C\u002Fp\u003E\n\u003Cp\u003E其中核心的处理逻辑如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 获取所有文件\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E getAllFiles = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003EdirPath, arrayOfFiles\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    files = fs.readdirSync(dirPath)\n    arrayOfFiles = arrayOfFiles || []\n    files.forEach(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Efile\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (fs.statSync(dirPath + \u003Cspan class=\"hljs-string\"\u003E&quot;\u002F&quot;\u003C\u002Fspan\u003E + file).isDirectory()) {\n            arrayOfFiles = getAllFiles(dirPath + \u003Cspan class=\"hljs-string\"\u003E&quot;\u002F&quot;\u003C\u002Fspan\u003E + file, arrayOfFiles)\n        } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n            arrayOfFiles.push(path.join(dirPath, \u003Cspan class=\"hljs-string\"\u003E&quot;\u002F&quot;\u003C\u002Fspan\u003E, file))\n        }\n    })\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E arrayOfFiles\n}\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 将markdown转为js文件\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E compile = \u003Cspan class=\"hljs-function\"\u003E() =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Etry\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E dirs = getAllFiles(\u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002F&#x27;\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 读取所有文件\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E inPosts = [] \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 文章数组\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E fileName \u003Cspan class=\"hljs-keyword\"\u003Eof\u003C\u002Fspan\u003E dirs) {\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-regexp\"\u003E\u002F.md\u002F\u003C\u002Fspan\u003E.test(fileName)) {\n                \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E fileData = fs.readFileSync(\u003Cspan class=\"hljs-string\"\u003E`.\u002F\u003Cspan class=\"hljs-subst\"\u003E${fileName}\u003C\u002Fspan\u003E`\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E&#x27;utf-8&#x27;\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F markdown内容\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E fmData = fm(fileData) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 此处可以忽略fm（fm是处理markdown front matter的，可有可无）\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E rmSuffix = fileName.split(\u003Cspan class=\"hljs-string\"\u003E&#x27;.&#x27;\u003C\u002Fspan\u003E)[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E] \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 移除文件名后缀\u003C\u002Fspan\u003E\n                inPosts.push({\n                    \u003Cspan class=\"hljs-attr\"\u003Etitle\u003C\u002Fspan\u003E: fileName,\n                    \u003Cspan class=\"hljs-attr\"\u003Epath\u003C\u002Fspan\u003E: rmSuffix,\n                    \u003Cspan class=\"hljs-attr\"\u003Eslug\u003C\u002Fspan\u003E: rmSuffix.replace(\u003Cspan class=\"hljs-string\"\u003E&#x27;\u002F&#x27;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E&#x27;_&#x27;\u003C\u002Fspan\u003E),\n                    \u003Cspan class=\"hljs-attr\"\u003Ehtml\u003C\u002Fspan\u003E: marked(fmData.body),\n                    fmData\n                })\n            }\n        }\n        inPosts.forEach(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Epost\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n            post.html = post.html.replace(\u003Cspan class=\"hljs-regexp\"\u003E\u002F^\\t{3}\u002Fgm\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E&#x27;&#x27;\u003C\u002Fspan\u003E);\n        });\n        \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E outPutContent = \u003Cspan class=\"hljs-string\"\u003E`export default \u003Cspan class=\"hljs-subst\"\u003E${\u003Cspan class=\"hljs-built_in\"\u003EJSON\u003C\u002Fspan\u003E.stringify(inPosts)}\u003C\u002Fspan\u003E`\u003C\u002Fspan\u003E\n        fs.writeFile(\u003Cspan class=\"hljs-string\"\u003E&#x27;..\u002Froutes\u002Fblog\u002F_posts.js&#x27;\u003C\u002Fspan\u003E, outPutContent, \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Eerr\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (err) \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\u003Cspan class=\"hljs-string\"\u003E&#x27;生成post失败&#x27;\u003C\u002Fspan\u003E, err)\n            \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\u003Cspan class=\"hljs-string\"\u003E&#x27;已生成_posts.js&#x27;\u003C\u002Fspan\u003E)\n        })\n    } \u003Cspan class=\"hljs-keyword\"\u003Ecatch\u003C\u002Fspan\u003E (error) {\n        \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.error(\u003Cspan class=\"hljs-string\"\u003E&#x27;error&#x27;\u003C\u002Fspan\u003E, error)\n    }\n}\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E watcher = chokidar.watch(\u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002F&#x27;\u003C\u002Fspan\u003E)\nwatcher\n    .on(\u003Cspan class=\"hljs-string\"\u003E&#x27;all&#x27;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-function\"\u003E() =&gt;\u003C\u002Fspan\u003E {\n        compile()\n    })\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"部署到github-pages\"\u003E部署到github pages\u003C\u002Fh2\u003E\n\u003Cp\u003E对于sapper，执行export命令生成静态文件。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Enpm run \u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E将\u003Ccode\u003E__sapper__\u002Fexport\u003C\u002Fcode\u003E推送到仓库的gh-pages分支。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit subtree \u003Cspan class=\"hljs-built_in\"\u003Epush\u003C\u002Fspan\u003E --\u003Cspan class=\"hljs-built_in\"\u003Eprefix\u003C\u002Fspan\u003E __sapper__\u002Fexport \u003Cspan class=\"hljs-built_in\"\u003Eorigin\u003C\u002Fspan\u003E gh-pages\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E最后在仓库设置出将gh-pages分支设置为部署分支就好了。\u003C\u002Fp\u003E\n\u003Cp\u003E以上完成了从写Markdown到可以看到文章，后续页面的编写就可以随心所欲啦！\u003C\u002Fp\u003E\n"},{title:"Element-ui table组件表头sticky",slug:"2020_05_element-ui-table-header-sticky",description:"不用js处理，css实现element-ui表头sticky。",keywords:"element-ui,table,header,表头,sticky,position,overflow hidden",labels:[a,"Element"],date:"2020-05-29",path:"2020\u002F05\u002Felement-ui-table-header-sticky.md",html:"\u003Cp\u003Eelement组件表头未支持sticky相关api。可以通过如下css处理：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-css\"\u003E\u002F\u002F 表头sticky\n.el-table__footer-\u003Cspan class=\"hljs-keyword\"\u003Ewrapper\u003C\u002Fspan\u003E,\n.el-table__header-\u003Cspan class=\"hljs-keyword\"\u003Ewrapper\u003C\u002Fspan\u003E {\n  position: sticky;\n  top: \u003Cspan class=\"hljs-number\"\u003E48\u003C\u002Fspan\u003Epx;\n  overflow: \u003Cspan class=\"hljs-keyword\"\u003Einherit\u003C\u002Fspan\u003E !important;\n  z-\u003Cspan class=\"hljs-keyword\"\u003Eindex\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E99\u003C\u002Fspan\u003E;\n}\n.el-\u003Cspan class=\"hljs-keyword\"\u003Etable\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-comment\"\u003E--small {\u003C\u002Fspan\u003E\n  overflow: \u003Cspan class=\"hljs-keyword\"\u003Einherit\u003C\u002Fspan\u003E;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E说明：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Eposition: sticky\u003C\u002Fcode\u003E如果没有效果，检查：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ccode\u003Etop\u003C\u002Fcode\u003E、\u003Ccode\u003Eright\u003C\u002Fcode\u003E、\u003Ccode\u003Eleft\u003C\u002Fcode\u003E或者\u003Ccode\u003Ebottom\u003C\u002Fcode\u003E属性是否有设置。\u003C\u002Fli\u003E\n\u003Cli\u003E在table组件中设置层级，以免被遮挡。\u003C\u002Fli\u003E\n\u003Cli\u003Esticky对象的祖先元素不能设置\u003Ccode\u003Eoverflow: hidden;\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"},{title:"Docker安装easymock",slug:"2020_01_docker-easymock",description:"为了方便本地mock接口，需要在本地用docker跑一个easy-mock服务。第一时间想到docker运行，方便管理和使用。基本上是非常简单就可以跑起来的。所以在这记录一下安装easy-mock的步骤，也为了下次更快的安装。",keywords:"docker,esaymock,api",labels:[a],date:"2020-01-20",path:"2020\u002F01\u002Fdocker-easymock.md",html:"\u003Cp\u003E为了方便本地mock接口，需要在本地用docker跑一个easy-mock服务。第一时间想到docker运行，方便管理和使用。基本上是非常简单就可以跑起来的。所以在这记录一下安装easy-mock的步骤，也为了下次更快的安装。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E假设在目录\u003Ccode\u003E\u002FUsers\u002F{{用户目录名}}\u002Feasymock\u003C\u002Fcode\u003E存放easy-mock配置。\n当然需要先安装好docker啦，不再赘述。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"docker-compose文件\"\u003EDocker compose文件\u003C\u002Fh2\u003E\n\u003Cp\u003Ex在easymock目录下新建一个docker-compose.yml文件，内容如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-yml\"\u003E\u003Cspan class=\"hljs-attr\"\u003Eversion:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;3&#x27;\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-attr\"\u003Eservices:\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-attr\"\u003Emongodb:\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Eimage:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Emongo:3.4.1\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Evolumes:\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E# .\u002Fdata\u002Fdb 数据库文件存放地址，根据需要修改为本地地址\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-bullet\"\u003E-\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002Fdata\u002Fdb:\u002FUsers\u002F\u003Cspan class=\"hljs-template-variable\"\u003E{{用户目录名}}\u003C\u002Fspan\u003E\u002Feasymock\u002Fdata\u002Fdb&#x27;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Enetworks:\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-bullet\"\u003E-\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Eeasy-mock\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Erestart:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Ealways\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-attr\"\u003Eredis:\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Eimage:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Eredis:4.0.6\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Ecommand:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Eredis-server\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E--appendonly\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Eyes\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Evolumes:\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E# .\u002Fdata\u002Fredis redis 数据文件存放地址，根据需要修改为本地地址\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-bullet\"\u003E-\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002Fdata\u002Fredis:\u002FUsers\u002F\u003Cspan class=\"hljs-template-variable\"\u003E{{用户目录名}}\u003C\u002Fspan\u003E\u002Feasymock\u002Fdata&#x27;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Enetworks:\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-bullet\"\u003E-\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Eeasy-mock\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Erestart:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Ealways\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-attr\"\u003Eweb:\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Eimage:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Eeasymock\u002Feasymock:1.6.0\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Ecommand:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E\u002Fbin\u002Fbash\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E-c\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&quot;npm start&quot;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Eports:\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-bullet\"\u003E-\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E7300\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-string\"\u003E:7300\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Evolumes:\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E# 日志地址，根据需要修改为本地地址\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-bullet\"\u003E-\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002Flogs:\u002FUsers\u002F\u003Cspan class=\"hljs-template-variable\"\u003E{{用户目录名}}\u003C\u002Fspan\u003E\u002Feasymock\u002Feasy-mock\u002Flogs&#x27;\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-comment\"\u003E# 配置地址，请使用本地配置地址替换\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-bullet\"\u003E-\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002Fproduction.json:\u002FUsers\u002F\u003Cspan class=\"hljs-template-variable\"\u003E{{用户目录名}}\u003C\u002Fspan\u003E\u002Feasymock\u002Feasy-mock\u002Fconfig&#x27;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Enetworks:\u003C\u002Fspan\u003E\n      \u003Cspan class=\"hljs-bullet\"\u003E-\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Eeasy-mock\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Erestart:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Ealways\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-attr\"\u003Enetworks:\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-attr\"\u003Eeasy-mock:\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"运行\"\u003E运行\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ccode\u003Edocker-compose up -d\u003C\u002Fcode\u003E即可运行。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Eeasymock_redis_1 \u003Cspan class=\"hljs-keyword\"\u003Eis\u003C\u002Fspan\u003E up-\u003Cspan class=\"hljs-keyword\"\u003Eto\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-built_in\"\u003Edate\u003C\u002Fspan\u003E\neasymock_mongodb_1 \u003Cspan class=\"hljs-keyword\"\u003Eis\u003C\u002Fspan\u003E up-\u003Cspan class=\"hljs-keyword\"\u003Eto\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-built_in\"\u003Edate\u003C\u002Fspan\u003E\neasymock_web_1 \u003Cspan class=\"hljs-keyword\"\u003Eis\u003C\u002Fspan\u003E up-\u003Cspan class=\"hljs-keyword\"\u003Eto\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-built_in\"\u003Edate\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E后打开\u003Ccode\u003Elocalhost:7300\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n"},{title:"Docker部署nuxtjs应用",slug:"2019_12_docker-nuxtjs",description:"有个主页的项目需要用到ssr。所以选择nuxtjs进行主页开发。关于nextjs的使用可以到官方文档进行查看。这里主要是记录一下docker部署nuxtjs应用的一些小事情。",keywords:"docker,nuxtjs,ssr",labels:[a],date:"2019-12-25",path:"2019\u002F12\u002Fdocker-nuxtjs.md",html:"\u003Cp\u003E有个主页的项目需要用到ssr。所以选择nuxtjs进行主页开发。关于nextjs的使用可以到官方文档进行查看。这里主要是记录一下docker部署nuxtjs应用的一些小事情。\u003C\u002Fp\u003E\n\u003Ch2 id=\"dockerfile\"\u003EDockerfile\u003C\u002Fh2\u003E\n\u003Cp\u003E通过dockerfile可以build一个docker镜像。dockerfile内容如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-dockerfile\"\u003E\u003Cspan class=\"hljs-keyword\"\u003EFROM\u003C\u002Fspan\u003E node:11.13.0-alpine\n\n\u003Cspan class=\"hljs-comment\"\u003E# create destination directory\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E mkdir -p \u002Fapp\nWORKDIR \u002Fapp\n\n\u003Cspan class=\"hljs-comment\"\u003E# copy the app, note .dockerignore\u003C\u002Fspan\u003E\nCOPY . \u002Fapp\n\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E npm install\n\n\u003Cspan class=\"hljs-comment\"\u003E# build necessary, even if no static files are needed,\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# since it builds the server as well\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E npm \u003Cspan class=\"hljs-builtin-name\"\u003Erun\u003C\u002Fspan\u003E build\n\n\u003Cspan class=\"hljs-comment\"\u003E# expose 3000 on container\u003C\u002Fspan\u003E\nEXPOSE 3000\n\n\u003Cspan class=\"hljs-comment\"\u003E# set app serving to permissive \u002F assigned\u003C\u002Fspan\u003E\nENV \u003Cspan class=\"hljs-attribute\"\u003ENUXT_HOST\u003C\u002Fspan\u003E=0.0.0.0\n\u003Cspan class=\"hljs-comment\"\u003E# set app port\u003C\u002Fspan\u003E\nENV \u003Cspan class=\"hljs-attribute\"\u003ENUXT_PORT\u003C\u002Fspan\u003E=3000\n\n\u003Cspan class=\"hljs-comment\"\u003E# start the app\u003C\u002Fspan\u003E\nCMD [ \u003Cspan class=\"hljs-string\"\u003E&quot;npm&quot;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E&quot;start&quot;\u003C\u002Fspan\u003E ]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E注意：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E部署 Nuxt.js 服务端渲染的应用不能直接使用 nuxt 命令，而应该先进行编译构建，然后再启动 Nuxt 服务。\u003C\u002Fli\u003E\n\u003Cli\u003E在build之前，需要ignore以下三个规则文件（手动创建.dockerignore文件）：\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-attribute\"\u003Enode_modules\u003C\u002Fspan\u003E\nnpm-\u003Cspan class=\"hljs-literal\"\u003Edebug\u003C\u002Fspan\u003E*\n.nuxt\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E否则会出现镜像build失败的情况。\u003C\u002Fp\u003E\n\u003Cp\u003E运行命令：docker run -it -d -p 3000:3000 gzhiyi\u002Fnuxt-homepage  后面为镜像build后的名称，注意按实际情况进行更改。\u003C\u002Fp\u003E\n\u003Ch2 id=\"nginx配置\"\u003Enginx配置\u003C\u002Fh2\u003E\n\u003Cp\u003EDocker运行node服务，如果需要外部访问的话，需要nginx反向代理。具体配置：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-nginx\"\u003E\u003Cspan class=\"hljs-section\"\u003Eserver\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-attribute\"\u003Elisten\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E80\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-attribute\"\u003Eserver_name\u003C\u002Fspan\u003E *your servername*;\n    \u003Cspan class=\"hljs-attribute\"\u003Elocation\u003C\u002Fspan\u003E \u002F {\n        \u003Cspan class=\"hljs-attribute\"\u003Eproxy_pass\u003C\u002Fspan\u003E http:\u002F\u002Flocalhost:3000;\n        \u003Cspan class=\"hljs-attribute\"\u003Eproxy_http_version\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-attribute\"\u003Eproxy_set_header\u003C\u002Fspan\u003E Upgrade $http_upgrade;\n        \u003Cspan class=\"hljs-attribute\"\u003Eproxy_set_header\u003C\u002Fspan\u003E Connection \u003Cspan class=\"hljs-string\"\u003E&#x27;upgrade&#x27;\u003C\u002Fspan\u003E;\n        \u003Cspan class=\"hljs-attribute\"\u003Eproxy_set_header\u003C\u002Fspan\u003E Host $host;\n        \u003Cspan class=\"hljs-attribute\"\u003Eproxy_cache_bypass\u003C\u002Fspan\u003E $http_upgrade;\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"访问\"\u003E访问\u003C\u002Fh2\u003E\n\u003Cp\u003E需要配置host才能访问，如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-hosts\"\u003E\u003Cspan class=\"hljs-comment\"\u003E*your serverip* *your servername*\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"},{title:r,slug:"2019_11_http-cache",description:r,keywords:"http,缓存",labels:[j],date:"2019-11-28",path:"2019\u002F11\u002Fhttp-cache.md",html:"\u003Ch2 id=\"缓存相关头\"\u003E缓存相关头\u003C\u002Fh2\u003E\n\u003Ch3 id=\"响应头\"\u003E响应头\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003EExpire。资源过期时间。\u003C\u002Fli\u003E\n\u003Cli\u003ECache-Control。缓存控制字段，精确控制缓存策略。\u003C\u002Fli\u003E\n\u003Cli\u003ELast-Modified。资源最近修改时间。\u003C\u002Fli\u003E\n\u003Cli\u003EEtag。资源标识。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"请求头\"\u003E请求头\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003ECache-Control。缓存控制字段，精确控制缓存策略。\u003C\u002Fli\u003E\n\u003Cli\u003EIf-Modified-Since。资源最新修改时间。\u003C\u002Fli\u003E\n\u003Cli\u003EIf-None-Match。缓存资源标识。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"字段匹配\"\u003E字段匹配\u003C\u002Fh3\u003E\n\u003Cp\u003EIf-Modified-Since和Last-Modified\nEtag和If-None-Match\u003C\u002Fp\u003E\n\u003Ch2 id=\"浏览器和服务器约定资源过期时间\"\u003E浏览器和服务器约定资源过期时间\u003C\u002Fh2\u003E\n\u003Cp\u003E服务器和浏览器之间约定文件的过期时间，控制的字段为：Expires。在这个时间未到之前，浏览器对同一个文件不会向服务器发起请求。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E缺点：\u003C\u002Fstrong\u003EExpire到期后，如果文件未进行过改动，浏览器还是会向服务器请求读取文件。\u003C\u002Fp\u003E\n\u003Ch2 id=\"服务器告诉浏览器资源上次的修改时间（解决上面的问题）\"\u003E服务器告诉浏览器资源上次的修改时间（解决上面的问题）\u003C\u002Fh2\u003E\n\u003Cp\u003E服务器返回文件的时候，在响应头上增加一个最近修改时间（Last-Modified）。浏览器在Expires时间到之后，会向服务器发起文件请求，这时带上一个最近修改时间（If-Modified-Since = Last-Modified）。服务器在接受到请求之后，会拿这个时间和服务器上目标文件的上一次修改时间做对比：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E相等。进行304跳转，不要读取服务器文件了，读取缓存就行了。\u003C\u002Fli\u003E\n\u003Cli\u003E不相等。读取服务器上的文件。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E缺点：\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003EExpires过期时间浏览器断可以修改，这样会导致缓存不准确。\u003C\u002Fli\u003E\n\u003Cli\u003ELast-Modified过期时间只能精确到秒。（一秒内可能多次改动，这样会造成两个可能的问题：文件一秒内改动多次，但还是通知浏览器读缓存。如果文件修改了，但内容不变，那就会去读服务器文件了。）\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"增加相对时间控制，引入cache-control\"\u003E增加相对时间控制，引入Cache-Control\u003C\u002Fh2\u003E\n\u003Cp\u003E服务器在返回资源给浏览器的时候，会增加一个相对时间：Cache-Control：max-age=1000s。这个的意思是告诉浏览器，1000s内使用浏览器缓存的文件。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E优先级：\u003C\u002Fstrong\u003E \nCache-Control优先于Expires。有Cache-Control就以Cache-Control为准。\u003C\u002Fp\u003E\n\u003Ch2 id=\"继续升级缓存机制\"\u003E继续升级缓存机制\u003C\u002Fh2\u003E\n\u003Cp\u003E带上Etag-可以理解为文件的唯一Id，由服务器返回到浏览器上。\n在有效期过后，带上一个等同于Etag值的If-None-Match请求头，比较后处理是否读取文件。\u003C\u002Fp\u003E\n\u003Ch2 id=\"最后是我前端的一个技巧啦\"\u003E最后是我前端的一个技巧啦\u003C\u002Fh2\u003E\n\u003Cp\u003E由于上面那么多的缓存判断条件，都不能满足一个情况，既浏览器永远无法主动知道服务器的文件已经更新。那好：静态资源在请求链接上更新就行了。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;http:\u002F\u002Ftest.com\u002Fa.【hash值】.js&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"},{title:"JS引入资源的一点总结",slug:"2019_09_js-asset-import",description:"很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。",keywords:"javascript,script,阻塞渲染,defer,async,动态引入",labels:[a],date:"2019-09-28",path:"2019\u002F09\u002Fjs-asset-import.md",html:"\u003Ch2 id=\"js引入的时候放在哪比较好呢？\"\u003EJS引入的时候放在哪比较好呢？\u003C\u002Fh2\u003E\n\u003Cp\u003E很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。\u003C\u002Fp\u003E\n\u003Ch2 id=\"浏览器渲染\"\u003E浏览器渲染\u003C\u002Fh2\u003E\n\u003Cp\u003E在知道放在哪最好之前，需要知道下浏览器渲染的过程。有以下的步骤：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E处理文档中的标签并构建DOM（Document Object Model）树。\u003C\u002Fli\u003E\n\u003Cli\u003E处理文档中的css并构建CSSOM（CSS Object Model）树。\u003C\u002Fli\u003E\n\u003Cli\u003E合并DOM和CSSOM为一个渲染树。\u003C\u002Fli\u003E\n\u003Cli\u003E处理渲染树没一个节点的布局。\u003C\u002Fli\u003E\n\u003Cli\u003E最后将没一个节点渲染（绘制）到浏览器上。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"阻塞渲染：css和javascript\"\u003E阻塞渲染：CSS和JavaScript\u003C\u002Fh3\u003E\n\u003Cp\u003E浏览器资源阻塞是一个常见的问题。要知道，资源在大多数浏览器上都是并行加载的，这种情况下，当Html文档被javascript阻塞时，Html文档会终止构建，但仍会\u003Ccode\u003E识别阻塞脚本后面的资源，进行预加载\u003C\u002Fcode\u003E。有以下要点需要注意：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Ecss加载不会阻塞dom树解析，但会阻塞dom树渲染。\u003C\u002Fli\u003E\n\u003Cli\u003E浏览器dom构建会在遇到script标签的时候暂停，直到script内的脚本执行完毕。\u003C\u002Fli\u003E\n\u003Cli\u003ECSSOM在构建的时候，JavaScript的执行会暂停，直到CSSOM准备就绪。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E以上正好说明了，我该把js脚本放在哪😄。我们就得出这样的原则以加快文档构建渲染：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003ECSS优先渲染。将css放在JavaScript资源之上，也就是普遍的放在 &lt; head &gt; 标签内。\u003C\u002Fli\u003E\n\u003Cli\u003E为减少script脚本对dom构建的影响，应该把script尽可能的放到最后（文档底部）。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"defer和async\"\u003Edefer和async\u003C\u002Fh2\u003E\n\u003Cp\u003Escript标签的这两个属性，均是为解决上面问题的。defer和async的使用有所不同。\n\u003Ccode\u003Edefer\u003C\u002Fcode\u003E：DOM元素的加载和脚本的 ** 加载 ** 异步执行。但是脚本的执行需要在所有dom元素解析完成之后，在\u003Ccode\u003EDOMContentLoaded\u003C\u002Fcode\u003E事件触发之前执行。\n\u003Ccode\u003Easync\u003C\u002Fcode\u003E：DOM元素的加载和脚本的加载 ** 以及执行 ** 异步执行。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F65817605-0ae1dc00-e23c-11e9-890b-e70207d371b6.jpeg\" alt=\"284aec5bb7f16b3ef4e7482110c5ddbb_articlex\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E无async和defer的时候，dom渲染被脚本\u003Cdel\u003E加载以及执行\u003C\u002Fdel\u003E所中断。\u003C\u002Fli\u003E\n\u003Cli\u003Edefer的时候，dom渲染未被阻塞，但脚本执行将会到最后。这个特性可以对需求有所利用。\u003C\u002Fli\u003E\n\u003Cli\u003Easync的时候，dom渲染和脚本加载和执行异步。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"有时候要用到动态引入？\"\u003E有时候要用到动态引入？\u003C\u002Fh2\u003E\n\u003Cp\u003E  统计脚本，广告脚本这类第三方嵌入脚本会在文档底部引入脚本文件。但都是以js生成script标签的形式进行动态引入。\n  先来看下百度统计脚本是怎么引入的：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E(\u003Cspan class=\"hljs-name\"\u003Efunction\u003C\u002Fspan\u003E() {\n  var hm = document.createElement(\u003Cspan class=\"hljs-string\"\u003E&quot;script&quot;\u003C\u002Fspan\u003E)\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n  hm.src = \u003Cspan class=\"hljs-string\"\u003E&quot;https:\u002F\u002Fhm.baidu.com\u002Fhm.js?10dbf7bc9ad86276329db7b&quot;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n  var s = document.getElementsByTagName(\u003Cspan class=\"hljs-string\"\u003E&quot;script&quot;\u003C\u002Fspan\u003E)[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E]\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n  s.parentNode.insertBefore(\u003Cspan class=\"hljs-name\"\u003Ehm\u003C\u002Fspan\u003E, s)\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n})()\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这就是动态创建script标签进行引入的方式。那么为什么要这样引入而不是直接:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;source_url&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Easync\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E  ** 其实，这既不是自执行函数的问题，也不是阻塞渲染的问题。是为了防止用户把脚本放置在文档不规范的地方导致文档被阻塞，并不是所有的脚本嵌入用户都知道这个脚本应该嵌入在哪的。而这样动态引入就可以避免这样的问题。**\u003C\u002Fp\u003E\n"},{title:"CodeReview",slug:"2019_09_codereview",description:"公司能有CodeReview的实践是非常好的。它最终的作用是促进工程师日常代码交流和提升工程师的代码能力。",keywords:"代码,codeReview",labels:[j],date:"2019-09-17",path:"2019\u002F09\u002Fcodereview.md",html:"\u003Cblockquote\u003E\n\u003Cp\u003EThere are about 15-20 common mistakes made by programmers.\nA checklist is a useful means of ensuring that common mistakes are identified.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E公司能有CodeReview的实践是非常好的。它最终的作用是促进工程师日常代码交流和提升工程师的代码能力。\u003C\u002Fp\u003E\n\u003Ch2 id=\"明确代码规范\"\u003E明确代码规范\u003C\u002Fh2\u003E\n\u003Cp\u003E无论前端还是后端，代码规范是很重要的。不应该把过多的CodeReview时间放在诸如代码空格、缩进等问题，这都是可以通过代码规范去约束的。各个开发人员都要尽力去写出符合公司代码规范的代码，减少CodeReview时间。\u003C\u002Fp\u003E\n\u003Ch2 id=\"codereview-检查项\"\u003ECodeReview 检查项\u003C\u002Fh2\u003E\n\u003Cp\u003E有一个简单明确的检查项可以快速对代码进行检查，不用担心遗漏某些必要的项。以下的列表提供建议，可以按公司内要求进行优化添加等。\u003C\u002Fp\u003E\n\u003Ch3 id=\"一般\"\u003E一般\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E代码是否符合预期的功能，逻辑是否正确。\u003C\u002Fli\u003E\n\u003Cli\u003E所写的代码是否容易理解。\u003C\u002Fli\u003E\n\u003Cli\u003E代码是否符合规定的编码规范。\u003C\u002Fli\u003E\n\u003Cli\u003E是否有冗余或者重复编写的代码。\u003C\u002Fli\u003E\n\u003Cli\u003E是否尽可能的模块化\u002F组件化。\u003C\u002Fli\u003E\n\u003Cli\u003E全局变量是否全局定义（可以快速修改不必多处查找遗漏）。\u003C\u002Fli\u003E\n\u003Cli\u003E是否留下注释的代码（视情况保留，一般不要存在好些）。\u003C\u002Fli\u003E\n\u003Cli\u003E循环是否正确设置了结束条件。\u003C\u002Fli\u003E\n\u003Cli\u003E代码设置的变量命名是否符合语义，易于理解。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"性能上\"\u003E性能上\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E是否还有更好的能提升既有性能的有效方法。\u003C\u002Fli\u003E\n\u003Cli\u003E是否有内置函数或者成熟的库\u002F组件能替换已有代码。\u003C\u002Fli\u003E\n\u003Cli\u003E是否已移除掉日志和debug代码。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"安全上\"\u003E安全上\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E输入类型的代码是否检查了类型、长度、提交格式等，后台是否对输入进行编码（encode）。（防xss）\u003C\u002Fli\u003E\n\u003Cli\u003E使用的第三方库有无错误异常捕获处理。\u003C\u002Fli\u003E\n\u003Cli\u003E容易出错的地方是否进行异常捕获处理。\u003C\u002Fli\u003E\n\u003Cli\u003E代码是否对变量做了空值判断处理。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"解释说明上\"\u003E解释说明上\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E代码的作用是否有注释留下描述。\u003C\u002Fli\u003E\n\u003Cli\u003E所有函数都做了注释吗？\u003C\u002Fli\u003E\n\u003Cli\u003E有没对所有代码异常和边缘情况做好判断处理。\u003C\u002Fli\u003E\n\u003Cli\u003E引入的第三方库\u002F组件是否做了必要的用途和引入说明。\u003C\u002Fli\u003E\n\u003Cli\u003E有没有不完整的代码？如果有，那代码可不可以删除或者标记TODO等？\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"reviewer--author\"\u003EReviewer &amp;&amp; Author\u003C\u002Fh3\u003E\n\u003Cp\u003E这部分原文在：\u003Ca target='_blank'  href=\"https:\u002F\u002Fphauer.com\u002F2018\u002Fcode-review-guidelines\u002F\"\u003E戳\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E用I-Messages\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EYou are not your code.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E要知道 \u003Ccode\u003EYou !== Your Code\u003C\u002Fcode\u003E。给代码review错误不是对人review错误，不要把人自身价值和人写的代码连接起来。每个人都是团队中有价值的一部分。\u003Cbr\u003E在Author和Reviewer之间应该交换业务最好的实践、经验、一些踩坑点还有一些提示。\u003Cbr\u003EReviewer在代码反馈上，有一个小规则我觉得挺有意思的：用I-Messages代替I-Messages。\u003C\u002Fp\u003E\n\u003Cp\u003E错误: “\u003Cstrong\u003E你\u003C\u002Fstrong\u003E写的这段代码存在黑魔法。”\u003C\u002Fp\u003E\n\u003Cp\u003E正确: “这段代码\u003Cstrong\u003E我\u003C\u002Fstrong\u003E不是很理解哦。”\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E讨论对象是代码不是人呐\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E只讨论代码可以增加review反馈的可接受度。\u003C\u002Fp\u003E\n\u003Cp\u003E错误: “\u003Cstrong\u003E你\u003C\u002Fstrong\u003E写的这代码请求了多次接口，这会影响性能。”\u003C\u002Fp\u003E\n\u003Cp\u003E正确: “\u003Cstrong\u003E这段代码\u003C\u002Fstrong\u003E触发多次请求了，应该会影响性能。”\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E \u003Cstrong\u003E提问题\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E好的方式提问题，让人更好的接受。\u003C\u002Fp\u003E\n\u003Cp\u003E错误: “这变量就应该命名为UserId。”\u003C\u002Fp\u003E\n\u003Cp\u003E正确: “如果这变量命名为UserId是不是好理解多了？”\u003C\u002Fp\u003E\n"},{title:"分离小程序环境",slug:"2019_09_mp-env-seperate",description:"官方文档很模糊，搜索到了几条关于小程序环境分离的问题，大部分吐槽官方怎么没有一个好的办法分离开发和生产环境。",keywords:"小程序,环境,分离,云开发",labels:[c],date:"2019-09-08",path:"2019\u002F09\u002Fmp-env-seperate.md",html:"\u003Cp\u003E官方文档很模糊，搜索到了几条关于小程序环境分离的问题，大部分吐槽官方怎么没有一个好的办法分离开发和生产环境。\u003C\u002Fp\u003E\n\u003Ch2 id=\"分离方式\"\u003E分离方式\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E云函数在调用的时候指定环境，依据云函数所在的环境进行动态设置。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Econst wxContext = cloud\u003Cspan class=\"hljs-selector-class\"\u003E.getWXContext\u003C\u002Fspan\u003E()\n  cloud\u003Cspan class=\"hljs-selector-class\"\u003E.updateConfig\u003C\u002Fspan\u003E({\n    env: wxContext\u003Cspan class=\"hljs-selector-class\"\u003E.ENV\u003C\u002Fspan\u003E\n  })\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 初始化数据库\u003C\u002Fspan\u003E\n  const db = cloud\u003Cspan class=\"hljs-selector-class\"\u003E.database\u003C\u002Fspan\u003E({\n    env: wxContext\u003Cspan class=\"hljs-selector-class\"\u003E.ENV\u003C\u002Fspan\u003E\n  })\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E小程序端起到起立环境的主要作用。在appjs中。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E     wx.cloud.init({\n        traceUser: true,\n        env: \u003Cspan class=\"hljs-string\"\u003E&#x27;release-wifo3&#x27;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 测试环境\n        \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E env: \u003Cspan class=\"hljs-string\"\u003E&#x27;dandan-zdm86&#x27;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 正式环境\n      })\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E预览小程序的时候开启测试环境的env，在部署上线发布的时候再切换为正式环境。\u003C\u002Fp\u003E\n"},{title:"我想要小程序过审",slug:"2019_08_mp-pass",description:"小程序审核是很多小程序开发者的痛。怎么让小程序审核通过，这里有一个小技巧。",keywords:"mp,小程序,审核",labels:[c],date:"2019-08-23",path:"2019\u002F08\u002Fmp-pass.md",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"http:\u002F\u002Ftva1.sinaimg.cn\u002Flarge\u002F007X8olVly1g69pnw5ai1j30mu05cmxx.jpg\" alt=\"cover\" \u003E\u003C\u002Fdiv\u003E\n小程序审核就是一个痛。资质、内容没问题的自然感受不到这样的痛苦。\u003C\u002Fp\u003E\n\u003Cp\u003E尤其是个人小程序，不给你过，因为你小程序有UGC；不给你过，因为你诱导用户分享...\u003C\u002Fp\u003E\n\u003Cp\u003E如果类目多还好，个人小程序就那几个能用（感兴趣）的类目，还能怎么办。反正上线过多次小程序，也尝试过很多次审核不通过，对于怎么避开审核组哥哥姐姐的法眼，我有一个代码级绕过的方法。\u003C\u002Fp\u003E\n\u003Ch2 id=\"什么内容导致审核不过\"\u003E什么内容导致审核不过\u003C\u002Fh2\u003E\n\u003Cp\u003E要十分清楚什么内容导致小程序没法审核通过。审核不过会简单把驳回原因返回，无外乎是资质、内容之类的问题。有时候觉得描述的模凌两可，我的小程序没有这些违规的，怎么审核还是不过呢！不怕，多试几次之后，很有可能审核组会给一张审核不过的“证据图”。一般是小程序的截图。\u003C\u002Fp\u003E\n\u003Ch2 id=\"怎么避开\"\u003E怎么避开\u003C\u002Fh2\u003E\n\u003Cp\u003E知道什么原因后，就想办法绕开审核。希望你的小程序不是很违规，只想上线满足自己那种程度，不要干坏事！ \u003C\u002Fp\u003E\n\u003Cp\u003E我自己总结了两种办法，两种办法的核心都是：\u003Ccode\u003E不要在审核员在审核期间看到不该看到的内容\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E使用延迟显示。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E定义一个时间戳，你的内容将在时间戳到达后显示出来。基本的代码可以如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 判断是否在审核期间\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E nowTime = \u003Cspan class=\"hljs-built_in\"\u003EDate\u003C\u002Fspan\u003E.parse(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EDate\u003C\u002Fspan\u003E())\n\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (nowTime &lt; \u003Cspan class=\"hljs-number\"\u003E1565078400000\u003C\u002Fspan\u003E) { \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 2019-08-06 16:00:00\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.globalData.isEscape = \u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F true 的时候就放开内容\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这样就可以屏蔽掉并保证在isEscape为false的时候不显示违规内容。当然这么做还是有缺点的：你不能保证你的小程序审核时候处于审核期，有可能审核周期很长，那怎么办？\u003C\u002Fp\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E使用接口控制显示。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E接口这个总该稳了吧？\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Ewx\u003Cspan class=\"hljs-selector-class\"\u003E.request\u003C\u002Fspan\u003E({\n  url: \u003Cspan class=\"hljs-string\"\u003E&#x27;##&#x27;\u003C\u002Fspan\u003E,\n  method: \u003Cspan class=\"hljs-string\"\u003E&#x27;GET&#x27;\u003C\u002Fspan\u003E,\n  success(res) {\n    getApp()\u003Cspan class=\"hljs-selector-class\"\u003E.globalData\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-selector-class\"\u003E.isEscape\u003C\u002Fspan\u003E = res\u003Cspan class=\"hljs-selector-class\"\u003E.data\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-selector-class\"\u003E.isEscape\u003C\u002Fspan\u003E\n  }\n})\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这其实也不是很好，毕竟接口存在延迟。多少会有。尤其是在云开发的免费配额上，这基本是会影响体验。判断究竟用那种方法，取决于你小程序上线的周期安排等。\u003C\u002Fp\u003E\n\u003Ch2 id=\"提示\"\u003E提示\u003C\u002Fh2\u003E\n\u003Cp\u003E小程序审核应该能绕过页面逻辑直接打开全部pages定义的页面的，所以要针对这个做一些跳转屏蔽处理。\u003C\u002Fp\u003E\n"},{title:"小程序egg后台简要文档",slug:"2019_06_mp-egg",description:"如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。",keywords:"mp,小程序,eggjs,微信开发后台",labels:[c],date:"2019-06-06",path:"2019\u002F06\u002Fmp-egg.md",html:"\u003Cp\u003E如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。\u003C\u002Fp\u003E\n\u003Cp\u003E如果未接触过node编写接口，首先还是需要基本过一下\u003Ca target='_blank'  href=\"https:\u002F\u002Feggjs.org\u002Fzh-cn\u002Fintro\u002F\"\u003Eegg官方文档\u003C\u002Fa\u003E，至少得把快速入门看完。\u003C\u002Fp\u003E\n\u003Cp\u003E不会从头开始把每一步都详细写下来，只针对微信对接的一些处理列出来。\u003C\u002Fp\u003E\n\u003Ch2 id=\"数据库\"\u003E数据库\u003C\u002Fh2\u003E\n\u003Cp\u003E使用mongo，示例通过\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Feggjs\u002Fegg-mongoose\"\u003Eegg-mongoose\u003C\u002Fa\u003E进行连接处理。\u003C\u002Fp\u003E\n\u003Cp\u003E安装插件后，在\u003Ccode\u003E\u002Fconfig\u002Fplugin.js\u003C\u002Fcode\u003E进行基本配置：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-attr\"\u003Emongoose:\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-attr\"\u003Eenable:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-attr\"\u003Epackage:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;egg-mongoose&#x27;\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在\u003Ccode\u003E\u002Fconfig\u002Fconfig.default.js\u003C\u002Fcode\u003E文件中配置mongodb的连接（保证本地测试环境数据库连接好）：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F connect mongo\n  config.mongoose = {\n    clien\u003Cspan class=\"hljs-variable\"\u003Et:\u003C\u002Fspan\u003E {\n      ur\u003Cspan class=\"hljs-variable\"\u003El:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;mongodb:\u002F\u002F127.0.0.1\u002Ffulishe&#x27;\u003C\u002Fspan\u003E,\n      option\u003Cspan class=\"hljs-variable\"\u003Es:\u003C\u002Fspan\u003E {},\n    }\n  }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在\u003Ccode\u003E\u002Fapp\u002Fmodels\u003C\u002Fcode\u003E文件夹编写相关的model，在程序运行时会自动在mongo上创建对应的表。也可以优先创建好数据库和表设计等。\u003C\u002Fp\u003E\n\u003Ch2 id=\"编写接口\"\u003E编写接口\u003C\u002Fh2\u003E\n\u003Cp\u003E在\u003Ccode\u003Econtroller\u003C\u002Fcode\u003E写主要的业务逻辑，接受接口请求参数并返回。\n对于入参，需要进行验证的可以做验证处理，需要处理返回结果，即使请求出错也不要返回非200的状态码。\n可以将处理结果设置为一个函数，如：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F data: 返回给前端的数据，code: 状态，1为成功，0为失败，message：状态信息\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-symbol\"\u003EformatResponse:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-meta\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-meta\"\u003Edata\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-meta\"\u003Ecode\u003C\u002Fspan\u003E, message) {\n  return {\n    \u003Cspan class=\"hljs-meta\"\u003Ecode\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-meta\"\u003Edata\u003C\u002Fspan\u003E,\n    message\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E!&gt; 为避免出现出现问题而导致程序中断，最好在每一个容易出现问题的地方进行\u003Ccode\u003Etry catch\u003C\u002Fcode\u003E将异常抛出并返回到前端。\u003C\u002Fp\u003E\n\u003Cp\u003E在\u003Ccode\u003Eservice\u003C\u002Fcode\u003E编写数据库操作函数等，通过在\u003Ccode\u003Econtroller\u003C\u002Fcode\u003E进行调用，统一管理数据库数据进出。\n注意在数据新增的时候需要进行\u003Ccode\u003Esave\u003C\u002Fcode\u003E操作：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E addUser = await \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.ctx.model.Users(\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E)\naddUser.save() \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 不要遗漏\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E相关的增删改查操作，需要直接点的可以看仓库\u003Ccode\u003Eapp\u002Fservice\u003C\u002Fcode\u003E下的写法。\u003C\u002Fp\u003E\n\u003Ch2 id=\"小程序接口相关\"\u003E小程序接口相关\u003C\u002Fh2\u003E\n\u003Cp\u003E以下是eggjs对小程序包括获取openId、获取unionId、获取手机号码、判断用户是否关注公众号、客服信息发送进行编写说明。\u003Cbr\u003E如果某个对象不知道是什么，一般都是可以根据名字找到对于的js文件或者通过npm引入，不再表述引入什么了。\u003C\u002Fp\u003E\n\u003Ch3 id=\"获取openid\"\u003E获取openId\u003C\u002Fh3\u003E\n\u003Cp\u003E参数说明：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAPPID： 小程序的appId\u003C\u002Fli\u003E\n\u003Cli\u003ESECRET： 小程序的secret，跟appId在同一个地方能找到\u003C\u002Fli\u003E\n\u003Cli\u003ECODE：小程序在前端通过wx.login()获取的jscode\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Econst openIdRes = await rp(`https:\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003Eapi.weixin.qq.com\u003Cspan class=\"hljs-regexp\"\u003E\u002Fsns\u002F\u003C\u002Fspan\u003Ejscode2session?appid=\u003Cspan class=\"hljs-variable\"\u003E${APPID}\u003C\u002Fspan\u003E&amp;secret=\u003Cspan class=\"hljs-variable\"\u003E${SECRET}\u003C\u002Fspan\u003E&amp;js_code=\u003Cspan class=\"hljs-variable\"\u003E${CODE}\u003C\u002Fspan\u003E&amp;grant_type=authorization_code`)\nconst openId = JSON.parse(openIdRes).openId \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 在处理错误判断后，返回的数据是json字符串，需要转化\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"获取unionid\"\u003E获取unionId\u003C\u002Fh3\u003E\n\u003Cp\u003EunionId，属于微信端通用的账号唯一标识，举个例子就是同一个微信号，唯一对应一个unionId。而在每一个小程序上，用户openId都不一样。可以用于判断在小程序上的用户是否关注公众号等。\u003C\u002Fp\u003E\n\u003Cp\u003E在第一个获取\u003Ccode\u003EopenId\u003C\u002Fcode\u003E的时候，会返回\u003Ccode\u003EopenId\u003C\u002Fcode\u003E以及\u003Ccode\u003Esession_key\u003C\u002Fcode\u003E，通过小程序前端传过来的\u003Ccode\u003EencryptedData\u003C\u002Fcode\u003E以及\u003Ccode\u003Eiv\u003C\u002Fcode\u003E就可以拿到\u003Ccode\u003EunionId\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E参数说明：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAPPID： 小程序的appId\u003C\u002Fli\u003E\n\u003Cli\u003EsessionKey：获取openId的时候，一并返回了sessionKey\u003C\u002Fli\u003E\n\u003Cli\u003EencryptedData：小程序在前端通过获取用户信息返回\u003C\u002Fli\u003E\n\u003Cli\u003Eiv：小程序在前端通过获取用户信息返回\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Econst pc = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-constructor\"\u003EWXBizDataCrypt(APPID, \u003Cspan class=\"hljs-params\"\u003EsessionKey\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\nconst data = pc.decrypt\u003Cspan class=\"hljs-constructor\"\u003EData(\u003Cspan class=\"hljs-params\"\u003EencryptedData\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Eiv\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\nconst unionId = data.unionId\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"获取手机号码\"\u003E获取手机号码\u003C\u002Fh3\u003E\n\u003Cp\u003E获取手机号码的步骤跟获取unionId一样。\u003C\u002Fp\u003E\n\u003Cp\u003E只需要注意的是，\u003Ccode\u003EencryptedData\u003C\u002Fcode\u003E、\u003Ccode\u003Eiv\u003C\u002Fcode\u003E是在小程序端通过\u003Ccode\u003EgetPhoneNumber\u003C\u002Fcode\u003E获取。\u003C\u002Fp\u003E\n\u003Ch3 id=\"判断用户是否关注公众号\"\u003E判断用户是否关注公众号\u003C\u002Fh3\u003E\n\u003Cp\u003E这里单独在小程序后台无法判断。需要在对于的公众号后台提供一个接口用于判断该unionId是否已经关注了公众号。\u003C\u002Fp\u003E\n\u003Ch3 id=\"客服信息发送\"\u003E客服信息发送\u003C\u002Fh3\u003E\n\u003Cp\u003E在小程序开发设置中配置消息推送。\u003C\u002Fp\u003E\n\u003Cp\u003E配置参考： \u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003E参数\u003C\u002Fth\u003E\n\u003Cth\u003E值\u003C\u002Fth\u003E\n\u003Cth\u003E备注\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\n\u003Ctd\u003EURL(服务器地址)\u003C\u002Ftd\u003E\n\u003Ctd\u003Ehttps:\u002F\u002F\u003Cem\u003E.\u003C\u002Fem\u003E.com\u002Fmessage\u002Fcheck\u003C\u002Ftd\u003E\n\u003Ctd\u003E微信那边与你服务器通信的接口\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EToken(令牌)\u003C\u002Ftd\u003E\n\u003Ctd\u003EisToken\u003C\u002Ftd\u003E\n\u003Ctd\u003E自定义\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EEncodingAESKey(消息加密密钥)\u003C\u002Ftd\u003E\n\u003Ctd\u003E******\u003C\u002Ftd\u003E\n\u003Ctd\u003E填写那可以自动生成\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E消息加密方式\u003C\u002Ftd\u003E\n\u003Ctd\u003E兼容模式\u003C\u002Ftd\u003E\n\u003Ctd\u003E涉及信息安全\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E数据格式\u003C\u002Ftd\u003E\n\u003Ctd\u003EJSON\u003C\u002Ftd\u003E\n\u003Ctd\u003E一般是这个吧\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\n\u003Cp\u003E在\u003Ccode\u003Econtroller\u003C\u002Fcode\u003E层编写一个\u003Ccode\u003Eget\u003C\u002Fcode\u003E接口，对应\u003Ccode\u003E\u002Fmessage\u002Fcheck\u003C\u002Fcode\u003E，用以给微信进行服务器验证。\n完整验证函数接口可如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Easync\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eindex\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E { ctx } = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E {\n    signature,\n    timestamp,\n    nonce,\n    echostr\n  } = ctx.query\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 2.将token、timestamp、nonce三个参数进行字典序排序\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E array = [\u003Cspan class=\"hljs-string\"\u003E&#x27;线上配置的令牌&#x27;\u003C\u002Fspan\u003E, timestamp, nonce]\n  array.sort() \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F JavaScript sort函数就是字典序排序的\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 3.将三个参数字符串拼接成一个字符串进行sha1加密\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E tempStr = array.\u003Cspan class=\"hljs-keyword\"\u003Ejoin\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&#x27;&#x27;\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E hashCode = crypto.createHash(\u003Cspan class=\"hljs-string\"\u003E&#x27;sha1&#x27;\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F创建加密类型\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E resultCode = hashCode.update(tempStr, \u003Cspan class=\"hljs-string\"\u003E&#x27;utf8&#x27;\u003C\u002Fspan\u003E).digest(\u003Cspan class=\"hljs-string\"\u003E&#x27;hex&#x27;\u003C\u002Fspan\u003E)\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (resultCode === signature) {\n    ctx.body = echostr\n  } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 非微信服务器请求\u003C\u002Fspan\u003E\n    ctx.body = format.formatResponse({\n      resultCode,\n      req: ctx.query\n    }, \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E&#x27;验证失败1&#x27;\u003C\u002Fspan\u003E)\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E自动回复操作：\n在\u003Ccode\u003Econtroller\u003C\u002Fcode\u003E层编写一个\u003Ccode\u003Epost\u003C\u002Fcode\u003E接口，对应\u003Ccode\u003E\u002Fmessage\u002Fcheck\u003C\u002Fcode\u003E，用于自动回复。\n完整处理自动回复接口：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Easync\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003Ehandle\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E { ctx } = \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E { FromUserName, MsgType, Content } = ctx.request.body \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这是从微信转发过来的用户发送的信息参数\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E { openid } = ctx.query\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 获取accessToken\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E tokenRes = \u003Cspan class=\"hljs-keyword\"\u003Eawait\u003C\u002Fspan\u003E rp(\u003Cspan class=\"hljs-string\"\u003E`https:\u002F\u002Fapi.weixin.qq.com\u002Fcgi-bin\u002Ftoken?grant_type=client_credential&amp;appid=\u003Cspan class=\"hljs-subst\"\u003E${CONST.appId}\u003C\u002Fspan\u003E&amp;secret=\u003Cspan class=\"hljs-subst\"\u003E${CONST.secret}\u003C\u002Fspan\u003E`\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!(\u003Cspan class=\"hljs-string\"\u003E&#x27;errcode&#x27;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EJSON\u003C\u002Fspan\u003E.parse(tokenRes))) {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (MsgType === \u003Cspan class=\"hljs-string\"\u003E&#x27;text&#x27;\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E postData = {\n        \u003Cspan class=\"hljs-attr\"\u003Etouser\u003C\u002Fspan\u003E: openid,\n        \u003Cspan class=\"hljs-attr\"\u003Emsgtype\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;link&quot;\u003C\u002Fspan\u003E,\n        \u003Cspan class=\"hljs-attr\"\u003Elink\u003C\u002Fspan\u003E: {\n          \u003Cspan class=\"hljs-attr\"\u003Etitle\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;链接标题&#x27;\u003C\u002Fspan\u003E,\n          \u003Cspan class=\"hljs-attr\"\u003Edescription\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;链接描述&#x27;\u003C\u002Fspan\u003E,\n          \u003Cspan class=\"hljs-attr\"\u003Eurl\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;链接&#x27;\u003C\u002Fspan\u003E,\n          \u003Cspan class=\"hljs-attr\"\u003Ethumb_url\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;链接封面图&#x27;\u003C\u002Fspan\u003E\n        }\n      }\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E sendRes = \u003Cspan class=\"hljs-keyword\"\u003Eawait\u003C\u002Fspan\u003E rp({\n        \u003Cspan class=\"hljs-attr\"\u003Euri\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E`https:\u002F\u002Fapi.weixin.qq.com\u002Fcgi-bin\u002Fmessage\u002Fcustom\u002Fsend?access_token=\u003Cspan class=\"hljs-subst\"\u003E${\u003Cspan class=\"hljs-built_in\"\u003EJSON\u003C\u002Fspan\u003E.parse(tokenRes).access_token}\u003C\u002Fspan\u003E`\u003C\u002Fspan\u003E,\n        \u003Cspan class=\"hljs-attr\"\u003Emethod\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;post&#x27;\u003C\u002Fspan\u003E,\n        \u003Cspan class=\"hljs-attr\"\u003Ebody\u003C\u002Fspan\u003E: postData,\n        \u003Cspan class=\"hljs-attr\"\u003Ejson\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E\n      })\n    }\n  }\n  ctx.body = \u003Cspan class=\"hljs-string\"\u003E&#x27;success&#x27;\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E!&gt; 注意：需要在自动回复的最后返回\u003Ccode\u003Esuccess\u003C\u002Fcode\u003E，否则会在聊天窗口看到提示：\u003Ccode\u003E该小程序提供的服务出现故障，请稍后再试\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n"},{title:"修改浏览器回退历史",slug:"2019_04_history-api",description:"有个需求，需要修改短链跳转到落地页后，在落地页返回的历史记录。避免出现跳转到落地页后返回还是出现短链中转的问题。",keywords:"浏览器,回退历史，history api,pushState,replaceState",labels:[a],date:"2019-04-12",path:"2019\u002F04\u002Fhistory-api.md",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F56006752-c05db900-5d08-11e9-94c3-61938d3f2eeb.png\" alt=\"无标题绘图\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E有个需求，需要修改短链跳转到落地页后，在落地页返回的历史记录。避免出现跳转到落地页后返回还是出现短链中转的问题。\u003C\u002Fp\u003E\n\u003Cp\u003E要求：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E无法控制落地页的所有代码。\u003C\u002Fli\u003E\n\u003Cli\u003E回退页面可在短链内进行定义。 \u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"history-api\"\u003EHistory Api\u003C\u002Fh3\u003E\n\u003Cp\u003Ehistory api提供浏览器修改历史记录功能。简单罗列下api的一些使用。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 返回上一个历史记录\nwindow.history.back()\nwindow.history.go(-\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E)\n\n\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 前进一个历史记录\nwindow.history.forward()\nwindow.history.go(\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E)\n\n\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 添加或者替换历史记录条目，注意这【并不会刷新页面】。\nhistory.pushState(state, title, url);\n\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E state：网址相关的状态Object，在popstate事件触发时，会在回调函数中接收到这个对象。不需要的话可以设为null。\n\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E title：新页面的title属性，填null。\n\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E url：新的页面地址，必须必须和上一个页面处于同域，否则抛出异常。\n\n\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 替换当前的历史记录，注意这【并不会刷新页面】。\nhistory.replaceState(state, title, url);\n\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 参数同上。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"实现的思考\"\u003E实现的思考\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E第一次尝试。既然要实现在落地页返回的历史，可不可以在短链中转页上监听一下上一页面的url，当然在跳转到落地页之前可以在落地页的url上带上参数，可以在短链中转页上通过是否带这个参数进行判断。放弃，理由是麻烦而且不稳定，可能出现难以预料的问题。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E第二次尝试。使用历史记录api修改历史记录。要修改的页面是短链中转页的历史记录，需要替换【当前】短链中转页的历史，使得跳转到落地页到上一个历史是短链所配置到页面。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E需要注意到是，历史记录不能replace或者push不同域的url。所以需要通过一个queryString进行判断。所以做法是：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Ewindow.onload = \u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-literal\"\u003E()\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (get\u003Cspan class=\"hljs-constructor\"\u003EParam(&#x27;\u003Cspan class=\"hljs-params\"\u003EbackUrl\u003C\u002Fspan\u003E&#x27;, \u003Cspan class=\"hljs-params\"\u003Elocation\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-params\"\u003Ehref\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E) {\n        console.log(&#x27;进入跳转到预定回退页&#x27;)\n        location.replace(get\u003Cspan class=\"hljs-constructor\"\u003EParam(&#x27;\u003Cspan class=\"hljs-params\"\u003EbackUrl\u003C\u002Fspan\u003E&#x27;, \u003Cspan class=\"hljs-params\"\u003Elocation\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-params\"\u003Ehref\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E)\n      } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n        console.log(&#x27;进入跳转到落地页并改写历史&#x27;)\n        history.replace\u003Cspan class=\"hljs-constructor\"\u003EState(\u003Cspan class=\"hljs-params\"\u003Enull\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Enull\u003C\u002Fspan\u003E,  \u003Cspan class=\"hljs-string\"\u003E&quot;[域名、处理返回逻辑页面]?backUrl=https:\u002F\u002Fwww.baidu.com&quot;\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n        document.get\u003Cspan class=\"hljs-constructor\"\u003EElementById(&#x27;\u003Cspan class=\"hljs-params\"\u003Ejump\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-params\"\u003Eid\u003C\u002Fspan\u003E&#x27;)\u003C\u002Fspan\u003E.click\u003Cspan class=\"hljs-literal\"\u003E()\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 跳转到落地页\u003C\u002Fspan\u003E\n      }\n    }\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F getParam是获取链接qs参数的函数。\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"},{title:s,slug:"2019_04_project-down",description:s,keywords:"node,dev,network,shadowsocks",labels:[a],date:t,path:"2019\u002F04\u002Fproject-down.md",html:"\u003Ch2 id=\"突遇node建本地开发服务的项目跑不起来\"\u003E突遇node建本地开发服务的项目跑不起来\u003C\u002Fh2\u003E\n\u003Cp\u003E今天早上来上班，发现平时跑的一个项目突然跑不了。症状如下：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003Ecommand无任何异常。\u003C\u002Fli\u003E\n\u003Cli\u003EautoOpenBrowser正常，打开浏览器后一直转加载。\u003C\u002Fli\u003E\n\u003Cli\u003Econsole无任何报错。\u003C\u002Fli\u003E\n\u003Cli\u003Enetwork仅有一个document处理一直pending的状态。\u003C\u002Fli\u003E\n\u003Cli\u003E理应不是端口问题，如果端口被占用会自动选一个的。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"找问题\"\u003E找问题\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E查看本机ip变了没有？\u003C\u002Fli\u003E\n\u003Cli\u003E这个项目不行，再跑一个其他的同类项目，还是有这个问题？\u003C\u002Fli\u003E\n\u003Cli\u003E重启个电脑试一下吧？\u003C\u002Fli\u003E\n\u003Cli\u003E最后，问题是：\u003Ccode\u003Eshadowsocks开了全局代理忘了关\u003C\u002Fcode\u003E。\n\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F55298682-903d2d00-5461-11e9-8c7f-6cdb66b0dea2.png\" alt=\"WX20190401-093546\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"},{title:"黑苹果计划",slug:"2019_03_hackintosh",description:"小米笔记本 13.3 指纹版 i5 7200U；目标系统：macOS High Sierra 10.13",keywords:"hackintosh,xiaomi,sierra 10.13,i5 7200U,13.3,macos",labels:["折腾"],date:t,path:"2019\u002F03\u002Fhackintosh.md",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F53999869-1a0a1b00-4180-11e9-8c8b-8b564e12ff99.jpg\" alt=\"macos-high-sierra\" \u003E\u003C\u002Fdiv\u003E\n\u003Cstrong\u003E看到米本现在黑苹果貌似可以挺稳定的工作，所以想折腾的心就沸腾起来了。也为了方便前端开发！\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch2 id=\"机器\"\u003E机器\u003C\u002Fh2\u003E\n\u003Cp\u003E小米笔记本 13.3 指纹版 i5 7200U；目标系统：macOS High Sierra 10.13\u003C\u002Fp\u003E\n\u003Ch2 id=\"前期工作\"\u003E前期工作\u003C\u002Fh2\u003E\n\u003Cp\u003E由于原本在windows上进行开发，还有之前装过windows和mint的双系统，所以现在的状态是GNU 启动。前期有很多的工作要做，是否要重新格盘安装也是未知数。现在前期工作的基本流程是：移除linux分区，移除GNU引导启动，进行备份工作。以上有风险的是：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E完全移除linux，稍有不慎可能就启动不了两个系统了。自己在处理这部分的知识不是很足，所以谨慎为妙。\u003C\u002Fli\u003E\n\u003Cli\u003E备份工作使用移动硬盘进行备份，主要是工作文档的备份。下面会罗列在windows上进行备份的一些软件链接和配置等。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"windows软件配置列表\"\u003Ewindows软件配置列表\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fwww.google.com\u002Fchrome\u002F\"\u003EGoogle Chrome\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EAdobe Photoshop CS6\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fwww.axure.com\u002F\"\u003EAxure RP8\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fcn.bandisoft.com\u002Fbandizip\u002F\"\u003EBandizip\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fconemu.github.io\u002F\"\u003EConEmu\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fwww.foxmail.com\u002F\"\u003EFoxmail\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EGit version\u003C\u002Fli\u003E\n\u003Cli\u003EGo programming\u003C\u002Fli\u003E\n\u003Cli\u003EKMPlayer\u003C\u002Fli\u003E\n\u003Cli\u003ELogitech 游戏软件\u003C\u002Fli\u003E\n\u003Cli\u003EMicrosoft Office Professional Plus 2013\u003C\u002Fli\u003E\n\u003Cli\u003EMicrosoft Visual Studio Code \u003C\u002Fli\u003E\n\u003Cli\u003EMozilla Firefox\u003C\u002Fli\u003E\n\u003Cli\u003ENode.js\u003C\u002Fli\u003E\n\u003Cli\u003EPostgreSQL 11\u003C\u002Fli\u003E\n\u003Cli\u003EPremiumSoft Navicat Premium\u003C\u002Fli\u003E\n\u003Cli\u003EFiddler\u003C\u002Fli\u003E\n\u003Cli\u003EPuTTY\u003C\u002Fli\u003E\n\u003Cli\u003EPxCook\u003C\u002Fli\u003E\n\u003Cli\u003EPython 3.7.0\u003C\u002Fli\u003E\n\u003Cli\u003ERuby\u003C\u002Fli\u003E\n\u003Cli\u003ETIM\u003C\u002Fli\u003E\n\u003Cli\u003ETortoiseSVN\u003C\u002Fli\u003E\n\u003Cli\u003EWinHTTrack Website Copier\u003C\u002Fli\u003E\n\u003Cli\u003EXMind\u003C\u002Fli\u003E\n\u003Cli\u003EYarn\u003C\u002Fli\u003E\n\u003Cli\u003E火绒安全软件\u003C\u002Fli\u003E\n\u003Cli\u003E企业微信\u003C\u002Fli\u003E\n\u003Cli\u003E贴吧、网易云音乐、微信\u003C\u002Fli\u003E\n\u003Cli\u003E微信web开发者工具\u003C\u002Fli\u003E\n\u003Cli\u003E迅雷极速版\u003C\u002Fli\u003E\n\u003Cli\u003EShadowsocks\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"主要进行开发配置备份\"\u003E主要进行开发配置备份\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cstrong\u003EChrome\u003C\u002Fstrong\u003E:保证所有内容同步到谷歌服务器。\n\u003Cstrong\u003ELogitech 游戏软件\u003C\u002Fstrong\u003E:关闭鼠标背光，灯光设置-关闭标识。\n\u003Cstrong\u003EMicrosoft Visual Studio Code\u003C\u002Fstrong\u003E:确保配置Settings Sync，保存gist以及token。\n\u003Cstrong\u003EPuTTY\u003C\u002Fstrong\u003E: IP:144.34.221.194 Port:28333 Connection type: SSH\u003C\u002Fp\u003E\n\u003Ch2 id=\"进度\"\u003E进度\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fblog.str-mo.com\u002Ftech\u002F217\u002F\"\u003E教程链接\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E数据备份------ 0%\u003C\u002Fli\u003E\n\u003Cli\u003E安装准备 ------ 10%，已刻录mac os镜像\u003C\u002Fli\u003E\n\u003Cli\u003E原系统处理 ------ 0%\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"关于espefi分区的扩容\"\u003E关于esp(EFI)分区的扩容\u003C\u002Fh2\u003E\n\u003Cp\u003E如果是win10和黑果双系统的话，需要保证安装黑果的硬盘内的esp分区大小不小于200M。而win10一般都是100M，所以就必须要进行esp扩容，否则没法对硬盘进行抹除操作。对于这部分，我昨天查了不少的资料，属于点门外汉吧。经过测试，一般的做法是：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E在windows下，打开DiskGenius。在windows自带的磁盘管理上，分出一个未分配的磁盘空间，大小够200M即可（压缩卷）。在未分配的磁盘上新建一个esp分区（右键未分配的分区，点击新建分区，后选EFI那个选项），大小为未分配磁盘空间的大小，保存。\u003C\u002Fli\u003E\n\u003Cli\u003E在DiskGenius下，浏览原esp分区的文件，将原来的文件复制到桌面，再从桌面复制到新的esp分区上。然后删除原来的100M的esp分区，保存，重启还是可以进入windows的。\u003Cbr\u003E到此，esp分区扩容就完成了。接着按教程走就行。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"镜像说明\"\u003E镜像说明\u003C\u002Fh2\u003E\n\u003Cp\u003E字节莫的镜像存在无法选择Apple安装的问题，在黑果小兵的博客上找到这个镜像的发布说明。\u003Ca target='_blank'  href=\"https:\u002F\u002Fblog.daliansky.net\u002FmacOS-High-Sierra-10.13.6-17G65-Release-Version-with-Clover-4596-original-mirror.html\"\u003E镜像地址\u003C\u002Fa\u003E。\n里面有对这个问题进行说明：  \u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E重要提示：由于CLOVER新版的缘故，原来的HD3000\u002FHD4000的配置文件不支持新版，会造成进CLOVER后卡住的情况，请降低CLOVER版本，或者直接删除掉所有的HD3000\u002FHD4000开头的配置文件；\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E按照上面引用的做法，就不用字节莫的efi文件了，直接用原来的efi然后删除上面的配置文件。删除文件的方法不用说了吧。接着重启就可以选择苹果进入安装了。\u003C\u002Fp\u003E\n\u003Ch2 id=\"替换驱动\"\u003E替换驱动\u003C\u002Fh2\u003E\n\u003Cp\u003E在mac系统内操作，用访达打开字节莫或者其他好的EFI，依次找路径：EFI-CLOVER-kexts-other文件夹，里面有很多驱动。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E触摸板驱动：\u003Ccode\u003EApplePS2SmartTouchPad.kext\u003C\u002Fcode\u003E。效果：触摸板ok。  \u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E将驱动拖动到Kext Utility，不要拖几次，一次就行，只是有其他加载工作在，等到第二次输入密码的时候就是安装的时候。\u003Cbr\u003E安装后重启驱动效果就有了。\u003C\u002Fp\u003E\n\u003Cp\u003E我试了两个ALC的驱动都不能驱动声音。。如果有知道的可以提一下。\n亮度也不敢弄，怕显卡驱动不好开不到机，目前配置好了很多开发工具，不大敢冒险了。\u003Cbr\u003E目前亮度的调节是用App Store里面的\u003Ccode\u003EBrightness slider\u003C\u002Fcode\u003E进行调节。治标不治本！\u003C\u002Fp\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E声卡解决：\n下载下面这个声卡驱动。按上面一楼的安装方法，完成后重启就行。\n链接: \u003Ca target='_blank'  href=\"https:\u002F\u002Fpan.baidu.com\u002Fs\u002F1pkaaUN3hCbxJhkVhX4kn9w\"\u003Ehttps:\u002F\u002Fpan.baidu.com\u002Fs\u002F1pkaaUN3hCbxJhkVhX4kn9w\u003C\u002Fa\u003E 提取码: kiur \u003C\u002Fli\u003E\n\u003Cli\u003E其他：\u003Cbr\u003E如果发现耳机杂音，可以在设置-输出-将平衡拖动到最左或者最右即可。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"},{title:u,slug:"2019_02_new-year",description:u,keywords:"new year,新的一年",labels:[d],date:"2019-02-10",path:"2019\u002F02\u002Fnew-year.md",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fmedia.socastsrm.com\u002Fwordpress\u002Fwp-content\u002Fblogs.dir\u002F348\u002Ffiles\u002F2019\u002F01\u002Fcrop635w_college-scholarships-2019-edition.jpg\" alt=\"cover\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E过去2018年，是自己进步非常大的一年。进了新的公司，认识一批新的同事。在众多的业务中能得到不少的帮助。自己也趁机学习和实践了很多的开发技术，最多而且最有印象的就是小程序的开发了。上一年的进步离不开自己对开源和技术的热爱，以及同事之间的帮助，当然很重要的是有不错的感情寄托。\u003C\u002Fp\u003E\n\u003Cp\u003E在慢慢的进步中，来到了2019年，我的本命年。\u003C\u002Fp\u003E\n\u003Cp\u003E很不幸，遇到了比较大的打击，导致心态崩溃了吧😭。\u003C\u002Fp\u003E\n\u003Cp\u003E往后的生活工作还是需要自己好好把握好好争取，有些事情需要自己去挖掘去熟悉，这样才会成长起来。很重要的一部分就是需要自己的自律，外加就是有计划的生活了。\u003C\u002Fp\u003E\n\u003Cp\u003E我在知乎上也写了一些关于自己在2019上的学习计划，其中TS和Flutter是自己需要好好学习的，尤其是TS需要跟着Vue 3.0的发布而运用到项目中。对于偏后端的应用上，会主动的学习Egg.js，最好是能找机会能在项目中应用上。\u003C\u002Fp\u003E\n\u003Cp\u003E开年的打击还是会伴着我一段比较长的时间，但生活还得继续，自己的坚持还要持续下去，无论多难，身边总会有朋友，家人的鼓励支持，这将是我2019年甚至是往后很重要的支柱了。\u003C\u002Fp\u003E\n\u003Cp\u003E2019年，给猪年的自己，加一份油😁。\u003C\u002Fp\u003E\n"},{title:v,slug:"2019_01_chrome-provisional-header",description:v,keywords:"chrome,caution,provisional,headers are shown",labels:[a],date:"2019-01-07",path:"2019\u002F01\u002Fchrome-provisional-header.md",html:"\u003Cp\u003E开发的一个项目出现一个Caution：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-attribute\"\u003ECaution provisional headers are shown\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E注：这个提示出现在chrome开发者工具的每一个接口请求上。这也只是个警告，还要理它干啥？先看看Google“热搜”的第一个解答：\n\u003Ca target='_blank'  href=\"https:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F21177387\u002Fcaution-provisional-headers-are-shown-in-chrome-debugger\"\u003E“CAUTION: provisional headers are shown” in Chrome debugger\u003C\u002Fa\u003E\n“请求被阻塞，东西发不出去，自然没有东西回来”\u003Cbr\u003E在答者那的例子他说是被adblock拦截了。\u003C\u002Fp\u003E\n\u003Ch2 id=\"问题\"\u003E问题\u003C\u002Fh2\u003E\n\u003Cp\u003E在项目上线的这段时间内，前期由于使用的少，并未将问题暴露出来，后面使用的人数多了之后，就会出现一个高概率的事情：\n\u003Cstrong\u003E个别接口请求一直处于pending状态，数据无法回流\u003C\u002Fstrong\u003E\u003Cbr\u003E这个问题比较严重，后面一直在找解决方案。我的思路历程是：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E一开始发现这个问题的时候，有些不可思议，第一次遇到，如果这是一个普遍的问题，为啥又只会出现在个别接口（非固定的个别接口）？\u003C\u002Fli\u003E\n\u003Cli\u003E调试工具出现\u003Ccode\u003Eprovisional headers are shown\u003C\u002Fcode\u003E的警告，瞄准这个警告入手。找到了大量相关的问题描述和方法，在前端这边的处理都未解决。在拦截器修改头，在\u003Ccode\u003Enet-internals\u003C\u002Fcode\u003E抓起日志等就差在每个请求后加上时间戳了（怀疑是前端缓存cache出现异常）。\u003C\u002Fli\u003E\n\u003Cli\u003E开始怀疑是后端的问题。与后端商量后，在日志打印那发现每一个请求返回都在几毫秒内。当然这个好像没有什么参考性，因为前端貌似这边请求并未成功发出。\u003C\u002Fli\u003E\n\u003Cli\u003E发现除chrome默认模式外，其它浏览器比如firefox、Edge都没这个问题。甚至在chrome无痕模式也没有这个问题。这时候觉得解决问题比找到原因更重要了（因为已经上线了）。\u003C\u002Fli\u003E\n\u003Cli\u003E经过后端前端的协调与商量，发现这大概率是因为前后端跨域而出现的问题。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"解决\"\u003E解决\u003C\u002Fh2\u003E\n\u003Cp\u003E\u003Cstrong\u003E设置请求接口与静态文件处于同源状态（需要nginx配置），警告消失，经过一段时间观察，问题解决。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n"},{title:"koa异步写文件遇到的小问题",slug:"2018_12_koa-async",description:"最近用koa写个微信小程序二维码生成接口，出现了一个小坑：由于小程序二维码生成接口返回的是二进制流，需要通过fs操作生成图片返回给前端下载。期间反复出现下载文件大小为0（零 \u002F 大小未知）的情况。",keywords:"koa,async,file",labels:[a],date:"2018-12-13",path:"2018\u002F12\u002Fkoa-async.md",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fgithub.com\u002Fkoajs\u002Fkoa\u002Fraw\u002Fmaster\u002Fdocs\u002Flogo.png\" alt=\"koa\" \u003E\u003C\u002Fdiv\u003E\n最近用koa写个微信小程序二维码生成接口，出现了一个小坑：由于小程序二维码生成接口返回的是二进制流，需要通过fs操作生成图片返回给前端下载。期间反复出现下载文件大小为0（零 \u002F 大小未知）的情况。  \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E主要生成二维码代码如下\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 其余代码省略\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E writeS = fs.createWriteStream(\u003Cspan class=\"hljs-string\"\u003E&#x27;qrcode.png&#x27;\u003C\u002Fspan\u003E)\n\u003Cspan class=\"hljs-keyword\"\u003Eawait\u003C\u002Fspan\u003E request(\u003Cspan class=\"hljs-comment\"\u003E{\n  uri: `https:\u002F\u002Fapi.weixin.qq.com\u002Fwxa\u002Fgetwxacode?access_token=${token}\u003C\u002Fspan\u003E`,\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Emethod\u003C\u002Fspan\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;post&#x27;\u003C\u002Fspan\u003E,\n  body: data,\n  json: \u003Cspan class=\"hljs-keyword\"\u003Etrue\u003C\u002Fspan\u003E\n}).pipe(writeS)\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 其余代码省略\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E需要有个先后顺序问题，必须先等到文件写完后才能进行图片下载接口调用。处理方法是在前端调用生成二维码的接口，而接口的操作需要有个等待过程，即要在\u003Ccode\u003EcreateWriteStream\u003C\u002Fcode\u003E结束后\u003Cstrong\u003E生成二维码接口\u003C\u002Fstrong\u003E才返回数据。  \u003C\u002Fp\u003E\n\u003Cp\u003E前端在接收到\u003Cstrong\u003E生成二维码接口\u003C\u002Fstrong\u003E返回数据后才调用下载二维码接口。  \u003C\u002Fp\u003E\n\u003Cp\u003Ekoa端等待写文件结束后返回，这里koa要用promise在callback后触发返回数据：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E ctx.body = \u003Cspan class=\"hljs-keyword\"\u003Eawait\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EPromise\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E(resolve, reject)\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    writeS.\u003Cspan class=\"hljs-literal\"\u003Eon\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&#x27;finish&#x27;\u003C\u002Fspan\u003E, function () {\n      resolve({\n        code: \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\n      })\n    })\n  })\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E前端监听操作：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-title\"\u003Eif\u003C\u002Fspan\u003E (res.\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E.code === 1) {\n  \u003Cspan class=\"hljs-title\"\u003Ewindow\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title\"\u003Eopen\u003C\u002Fspan\u003E(&#x27;图片下载地址&#x27;)\n}\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E具体接口代码（\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002FGzhiYi\u002Fwxqrcode-generater\u002Fblob\u002Fmaster\u002Findex.js\"\u003E查看\u003C\u002Fa\u003E）\u003C\u002Fp\u003E\n"},{title:w,slug:"2018_12_es6-module",description:w,keywords:"es6,ES6,module",labels:[a],date:"2018-12-12",path:"2018\u002F12\u002Fes6-module.md",html:"\u003Ch2 id=\"export\"\u003E\u003Ccode\u003Eexport\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E输出变量。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ename\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&#x27;GzhiYi&#x27;\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E job = \u003Cspan class=\"hljs-string\"\u003E&#x27;Frontend&#x27;\u003C\u002Fspan\u003E;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E以上可简写（荐）：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ename\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-string\"\u003E&#x27;GzhiYi&#x27;\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E job = \u003Cspan class=\"hljs-string\"\u003E&#x27;Frontend&#x27;\u003C\u002Fspan\u003E;\n\n\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E{ name, job }\u003C\u002Fspan\u003E;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E输出函数或者类\u003Ccode\u003Eclass\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EexportMe\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{}\n\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EexportMeToo\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E{}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E关键字\u003Ccode\u003Eas\u003C\u002Fcode\u003E重命名输出。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E name = \u003Cspan class=\"hljs-string\"\u003E&#x27;GzhiYi&#x27;\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E job = \u003Cspan class=\"hljs-string\"\u003E&#x27;Frontend&#x27;\u003C\u002Fspan\u003E;\n\n\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E {\n   name \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E changeName,\n   job \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E changeJob  \n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"import\"\u003E\u003Ccode\u003Eimport\u003C\u002Fcode\u003E\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E导入\u003Ccode\u003Eexport\u003C\u002Fcode\u003E输出的接口。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E { \u003Cspan class=\"hljs-type\"\u003Ename\u003C\u002Fspan\u003E, job } \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;filePath&#x27;\u003C\u002Fspan\u003E;\n\u002F\u002F \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E 进来的变量均是readOnly，也不建议改写引入的其它类型数据。\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E关键字\u003Ccode\u003Eas\u003C\u002Fcode\u003E重命名输入。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E { \u003Cspan class=\"hljs-type\"\u003Ename\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E changName } \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;filePath&#x27;\u003C\u002Fspan\u003E;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"整体引入\"\u003E整体引入\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 假设demo.js文件有如下内容\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EfunA\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{}\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EfunB\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{}\n\n\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E { funA, funB };\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 平常加载\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E { funA, funB } \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002Fdemo&#x27;\u003C\u002Fspan\u003E;\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 整体引入\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E * \u003Cspan class=\"hljs-keyword\"\u003Eas\u003C\u002Fspan\u003E allFun \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002Fdemo&#x27;\u003C\u002Fspan\u003E;\nallFun.funA();\nallFun.funB();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"export-defalut-指定默认输出\"\u003E\u003Ccode\u003Eexport defalut\u003C\u002Fcode\u003E 指定默认输出\u003C\u002Fh2\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F demo.js\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Edefault\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{};\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 引入\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E funName \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;demo&#x27;\u003C\u002Fspan\u003E; \n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 不需要知道封装demo.js包含的函数名，import后无需接大括号，因为默认输出的只有一个。\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"},{title:"git在工作中的一些用处",slug:"2018_11_git-usage-in-work",description:"git内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。",keywords:"git,工作中,用处,git工作流,分支,git rebase,git merge",labels:[j],date:"2018-11-28",path:"2018\u002F11\u002Fgit-usage-in-work.md",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F26\u002Fbanner.png\" alt=\"banner\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E本周四分享会主题：__git在工作中的一些用处__。  \u003C\u002Fp\u003E\n\u003Cp\u003Egit内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。\u003Cstrong\u003E基本的概念不会多说\u003C\u002Fstrong\u003E，都能在入门教程那些学习到。接下来会说下git在工作中比较常用的功能，会发现，其实git能做的事情还是非常多的。\u003C\u002Fp\u003E\n\u003Ch3 id=\"git在开发中常用的命令\"\u003Egit在开发中常用的命令\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cstrong\u003E编辑和代码提交\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-meta\"\u003E# 为git初始化一个代码库\u003C\u002Fspan\u003E\ngit init\n\n\u003Cspan class=\"hljs-meta\"\u003E# 将目录的所有文件提交到暂存区\u003C\u002Fspan\u003E\ngit add .\n\n\u003Cspan class=\"hljs-meta\"\u003E# 提交暂存区到代码仓库区，并添加提交信息\u003C\u002Fspan\u003E\ngit commit -m \u003Cspan class=\"hljs-string\"\u003E&quot;commit message&quot;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E分支处理\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# 列出本地所有的分支\u003C\u002Fspan\u003E\ngit \u003Cspan class=\"hljs-keyword\"\u003Ebranch\n\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# 列出远程仓库的所有分支\u003C\u002Fspan\u003E\ngit \u003Cspan class=\"hljs-keyword\"\u003Ebranch \u003C\u002Fspan\u003E-r\n\n\u003Cspan class=\"hljs-comment\"\u003E# 列出仓库的所有分支（包含远端和本地分支）\u003C\u002Fspan\u003E\ngit \u003Cspan class=\"hljs-keyword\"\u003Ebranch \u003C\u002Fspan\u003E-a\n\n\u003Cspan class=\"hljs-comment\"\u003E# 切换到指定分支，并更新工作区\u003C\u002Fspan\u003E\ngit checkout [\u003Cspan class=\"hljs-keyword\"\u003EbranchName]\n\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# 新建一个分支并切换到该分支\u003C\u002Fspan\u003E\ngit checkout -\u003Cspan class=\"hljs-keyword\"\u003Eb \u003C\u002Fspan\u003E[\u003Cspan class=\"hljs-keyword\"\u003EbranchName]\n\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# 删除一个分支\u003C\u002Fspan\u003E\ngit \u003Cspan class=\"hljs-keyword\"\u003Ebranch \u003C\u002Fspan\u003E-d [\u003Cspan class=\"hljs-keyword\"\u003EbranchName]\n\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# 强制删除一个分支\u003C\u002Fspan\u003E\ngit \u003Cspan class=\"hljs-keyword\"\u003Ebranch \u003C\u002Fspan\u003E-D [\u003Cspan class=\"hljs-keyword\"\u003EbranchName]\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E查看状态信息\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-meta\"\u003E# 查看变更的文件，可多用这个命令查看当前文件改动状态\u003C\u002Fspan\u003E\ngit status\n\n\u003Cspan class=\"hljs-meta\"\u003E# 查看当前分支提交历史，可以得到加密的commit_id\u003C\u002Fspan\u003E\ngit log\n\n\u003Cspan class=\"hljs-meta\"\u003E# 查看暂存区和工作区的对比\u003C\u002Fspan\u003E\ngit diff\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E同步远程仓库\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-meta\"\u003E# 同步远程仓库的所有更新\u003C\u002Fspan\u003E\ngit fetch [remote]\n\n\u003Cspan class=\"hljs-meta\"\u003E# 显示所有远程仓库\u003C\u002Fspan\u003E\ngit remote -v\n\n\u003Cspan class=\"hljs-meta\"\u003E# 增加一个新的远程仓库，并定义一个远程仓库名，shortName常用origin，当然可自定义\u003C\u002Fspan\u003E\ngit remote add [shortName] url\n\n\u003Cspan class=\"hljs-meta\"\u003E# 拉取远端分支，并与本地分支合并\u003C\u002Fspan\u003E\ngit pull [remote] [branchName]\n\n\u003Cspan class=\"hljs-meta\"\u003E# 上传本地分支到远端\u003C\u002Fspan\u003E\ngit push [remote] [branchName]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E撤销操作\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-meta\"\u003E# 恢复暂存区的指定文件到工作区\u003C\u002Fspan\u003E\ngit checkout [file]\n\n\u003Cspan class=\"hljs-meta\"\u003E# 恢复暂存区的所有文件到工作区\u003C\u002Fspan\u003E\ngit checkout .\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F49006081-37a00f80-f1a3-11e8-982e-c02cd71c1495.png\" alt=\"image\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003Egit工作中常用命令基本可以上图概括。\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E其它常用的命令\u003C\u002Fstrong\u003E\n单独拿出来说是因为平常知道用的可能不会很多，但实际用起来会非常有用。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ccode\u003Egit stash\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E当你在工作的时候，累计了比较多的改动，但是突然间需要临时切换到其它分支工作，可是又不好把中途工作的内容提交，那怎么办？这时候git stash就有用了。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-meta\"\u003E# 查看文件变更状态\u003C\u002Fspan\u003E\ngit status\n\n\u003Cspan class=\"hljs-meta\"\u003E# 储藏变更，这时候会提示已储藏变更\u003C\u002Fspan\u003E\ngit stash\n\n\u003Cspan class=\"hljs-meta\"\u003E# 当在其它分支工作完回到原来分支的时候，可以查看储藏列表\u003C\u002Fspan\u003E\ngit stash list\n\n\u003Cspan class=\"hljs-meta\"\u003E# 恢复储藏，这时候文件变更就回来了，listNum为列表序号\u003C\u002Fspan\u003E\ngit stash apply stash@{listNum}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E\u003Ccode\u003Egit rebase\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E一般我们完成代码后，需要将分支的改动进行整合，会用到合并（merge）操作，但这不是唯一的方式，Rebase就是其中的代替方式。\u003Cbr\u003E先来说说merge。我们在需要合并的时候，会有如下的两种基本情况： \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Fstarting-situation-fast-forward.gif\" alt=\"情况1\" \u003E\u003C\u002Fdiv\u003E\n其中一个分支没有新的改动，而另一个分支却有改动。这个时候进行整合的话，git仅仅只是添加所有改动的分支的新提交即可。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Fstarting-situation-merge-commit.gif\" alt=\"情况2\" \u003E\u003C\u002Fdiv\u003E\n第二种就是我们开发过程经常遇到的情况，两个分支都有不同的开发轨迹。为了完成合并，git会创建一个新的提交来涵括它们之间的差异，这就是整合提交。\u003C\u002Fp\u003E\n\u003Cp\u003E有人不喜欢这个合并的方式，希望项目有一个单一的开发轨迹，在流程上是一条直线，不希望在开发历史记录上看到被分成过多个分支。这时候就可以用到rebase操作了。\u003C\u002Fp\u003E\n\u003Cp\u003E我们还是看第一个例子：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Fstarting-situation-fast-forward.gif\" alt=\"情况1\" \u003E\u003C\u002Fdiv\u003E\n如果我们想合并分支B到A分支上，可以用到下面这个命令：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-attribute\"\u003Egit rebase branchB\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003Egit会进行这样的操作：\u003Cbr\u003E“撤销”所有分支A上与分支B开发分叉后的更改，这并不是真的checkout掉更改，后面还会用到。\n\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Frebase-step-1.gif\" alt=\"rebase1\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E然后它将整合分支B上的提交到A上，这要看，分支A和分支B就会像一条线一样。\n\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Frebase-step-2.gif\" alt=\"rebase2\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E最后，在分支A上的那些新的提交会被重新应用回来。\n\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Frebase-step-3.gif\" alt=\"rebase3\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E\u003Ccode\u003Egit reset\u003C\u002Fcode\u003E和\u003Ccode\u003Egit revert\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E开发期间难免会有提交出错代码的情况，如何进行版本回退呢？git reset命令就派上用场了.  \u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Egit reset 为重置提交，可以将版本回退到某一个commit记录上。git reset 命令后面是需要加2种参数的：–-hard 和 –-soft。这条命令默认情况下是 -–soft。\u003Cbr\u003E\u003Cstrong\u003E区别：\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E默认参数 -soft,所有commit的修改都会退回到git暂存区。\n参数--hard，所有commit的修改直接丢弃，小心用。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit \u003Cspan class=\"hljs-built_in\"\u003Ereset\u003C\u002Fspan\u003E --hard commit_id\ngit \u003Cspan class=\"hljs-built_in\"\u003Epush\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eorigin\u003C\u002Fspan\u003E [branchName] --force\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E当然如果--hard错了，也还有救，\u003Ccode\u003Egit reflog\u003C\u002Fcode\u003E命令记录你的所有git操作，能获取到原有的移除掉的commit_id。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Egit revert 为还原提交，可以将某个commit还原然后创建一个新的还原commit。字面意思已经很好理解了。比如：\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-comment\"\u003E# 某个commit的文件a增加两行文字\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-attribute\"\u003Egit\u003C\u002Fspan\u003E revert commit_id\n\n\u003Cspan class=\"hljs-comment\"\u003E# 执行该命令后，还原了这个commit文件a的更改，新增一个revert的commit，更改为增加的两行文字被移除。\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"git工作流\"\u003Egit工作流\u003C\u002Fh3\u003E\n\u003Cp\u003E这里只说下最广泛应用的git工作流，也就是git flow。\u003Cbr\u003E在开发的初期，我们定两个分支：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E主分支master\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E开发分支develop\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E规定，master分支为版本发布的分支，提供上线的版本。develop分支为日常开发分支，存放最新的开发版本。一般的develop分支会切出如下的三个短期分支：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E功能分支（feature）\u003C\u002Fli\u003E\n\u003Cli\u003E修bug分支（hotfix或者fix）\u003C\u002Fli\u003E\n\u003Cli\u003E预发布分支（release）\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cstrong\u003E还有其它工作流？\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E当然有！下面就继续说一个挺不错的工作流：  \u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E功能分支工作流  \u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E这个工作流的核心思路是所有的功能开发都应该独立一个分支，而主分支一样是master。这样的隔离开发不会扰乱主分支上的代码，也能保证主分支的代码准确无误。\u003C\u002Fp\u003E\n\u003Cp\u003E这种方式让pull request变得更加有效果。过多的就不解释，通过一个例子看看这个工作流到底是如何工作的。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E小红开始开发一个新功能\u003C\u002Fstrong\u003E\u003Cbr\u003E理所当然，从master切出一个独立功能分支：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit checkout -b \u003Cspan class=\"hljs-built_in\"\u003Efeature\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E master\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E持续打码，中途完成部分:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit status\ngit \u003Cspan class=\"hljs-built_in\"\u003Eadd\u003C\u002Fspan\u003E [\u003Cspan class=\"hljs-built_in\"\u003Efile\u003C\u002Fspan\u003E]\ngit commit -m \u003Cspan class=\"hljs-string\"\u003E&#x27;xxx&#x27;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E中午去吃个饭\u003C\u002Fstrong\u003E\u003Cbr\u003E在吃午饭前，小红把自己的功能分支推到了远端仓库。好习惯，多学习。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit \u003Cspan class=\"hljs-built_in\"\u003Epush\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eorigin\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Efeature\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E小红完成开发\u003C\u002Fstrong\u003E\n在合并之前，小红保证远端仓库有自己功能分支的最新代码。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit \u003Cspan class=\"hljs-built_in\"\u003Epush\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eorigin\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Efeature\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E接下来，可以发起一个合并请求，在github或者gitlab都有快捷的合并请求操作。合并功能分支feature-new到master。发起后，团队都可以收到合并请求的通知。\u003C\u002Fp\u003E\n\u003Cp\u003E这时候团队可以code review，有问题就可以继续提示小红去修正。\u003C\u002Fp\u003E\n\u003Cp\u003E修正后小红可以持续推代码到功能分支，commit记录也会一并出现在pull request处。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E小红发布功能\u003C\u002Fstrong\u003E\u003Cbr\u003E经过紧张的讨论修改，终于完成功能开发，要发布功能：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit checkout master\ngit pull\ngit pull \u003Cspan class=\"hljs-built_in\"\u003Eorigin\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Efeature\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E\ngit \u003Cspan class=\"hljs-built_in\"\u003Epush\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E完毕。\u003C\u002Fp\u003E\n\u003Ch3 id=\"还能怎么发挥git作用？\"\u003E还能怎么发挥git作用？\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cstrong\u003Ewebhooks\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E根据github的介绍，webhooks可以通过使用github的事件被触发时通过http post的形式调用服务器上的接口，服务器接受到推送事件之后就可以执行构建，更新项目代码，进而部署生产服务器等等。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E这一切能限制的只有你的想象力。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E一般而言，比如说我部署一个node程序到服务器上需要怎么操作？\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E本地代码开发完毕，准备上线，上传本地代码到git远端仓库。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Essh连接远程服务器，登录管理员账号密码后进入命令行界面。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E进入项目目录，拉取最新提交的代码。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E执行部署操作。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E需要代码更新，重复此操作。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cstrong\u003E而我通过webhooks之后，这些操作得到很大的简化。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E配置webhooks的push事件，因为我要在本地push代码后执行后续操作。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F49086433-78755280-f28f-11e8-98ee-a1279e427c8e.png\" alt=\"image\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E在服务器上编写一个自动部署脚本，这里举个简单的脚本\u003Ccode\u003Edeploy.sh\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-comment\"\u003E#！\u002Fbin\u002Fbash\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-built_in\"\u003Eecho\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;enter project&#x27;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-built_in\"\u003Ecd\u003C\u002Fspan\u003E [your project dir]\n\n\u003Cspan class=\"hljs-built_in\"\u003Eecho\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;pull code&#x27;\u003C\u002Fspan\u003E\ngit pull origin master\n\n\u003Cspan class=\"hljs-built_in\"\u003Eecho\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;deploy&#x27;\u003C\u002Fspan\u003E\npm2 start deploy.js\npm2 logs deploy\n\n\u003Cspan class=\"hljs-built_in\"\u003Eecho\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;deploy finished&#x27;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E用node写一个监听接口，不一定要node，只要能跑出个接口能监听到事件即可。需要提到：\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E createHandler = \u003Cspan class=\"hljs-built_in\"\u003Erequire\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&#x27;node-github-webhook&#x27;\u003C\u002Fspan\u003E)\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E config = {\n  \u003Cspan class=\"hljs-attr\"\u003Epath\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;\u002Fhook&#x27;\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-attr\"\u003Esecret\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;your srcret&#x27;\u003C\u002Fspan\u003E\n}\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E handler = createHandler(config)\n...\n\nhandler.on(\u003Cspan class=\"hljs-string\"\u003E&#x27;push&#x27;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Eevent\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  execFunc(\u003Cspan class=\"hljs-string\"\u003E&#x27;sh .\u002Fdeploy.sh&#x27;\u003C\u002Fspan\u003E)\n})\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里的path和secret都需要在github webhooks那边对应配置上。\u003C\u002Fp\u003E\n\u003Col start=\"4\"\u003E\n\u003Cli\u003E完成之后，一旦代码提交到master的话，就会触发事件，然后自动执行后续操作。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"git工具推荐\"\u003Egit工具推荐\u003C\u002Fh3\u003E\n\u003Cp\u003E有几个个人认为不错的git工具或者项目可以提高git的使用。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fgithub\u002Fgitignore\"\u003Egitignore\u003C\u002Fa\u003E。在项目根目录新建一个\u003Ccode\u003E.gitignore\u003C\u002Fcode\u003E文件，将不需要提交到git上的文件路径添加到这个文件。在这个项目中可以快速找到自己所属项目的通用gitignore文件\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127222540.png\" alt=\"gitignore\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E[\u003Ccode\u003EVS Code\u003C\u002Fcode\u003E] gitignore。可以右键将文件夹或者文件添加到.gitignore文件中。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127222733.png\" alt=\"gitignore\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E[\u003Ccode\u003EVS Code\u003C\u002Fcode\u003E] GitLens。可以让每一行代码都显示历史记录等。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127223043.png\" alt=\"Gitlens\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Col start=\"4\"\u003E\n\u003Cli\u003E[\u003Ccode\u003EChrome\u003C\u002Fcode\u003E] octotree。浏览github上的代码更加轻松便捷。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127223252.png\" alt=\"octotree\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Col start=\"5\"\u003E\n\u003Cli\u003ESourcetree。git图形界面工具，讲了那么多命令应该可以不用图形界面了吧😀。\n\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F28\u002F微信截图_20181128215137.png\" alt=\"sourcetree\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"最后\"\u003E最后\u003C\u002Fh3\u003E\n\u003Cp\u003E分享内容大概如此了，欢迎补充，也希望内容有些帮助。😄\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E参考\n\u003Ca target='_blank'  href=\"https:\u002F\u002Fwww.git-tower.com\u002Flearn\u002Fgit\u002Febook\u002Fcn\u002Fcommand-line\u002Fadvanced-topics\u002Frebase\"\u003ERebase 代替合并 \u003C\u002Fa\u003E\n\u003Ca target='_blank'  href=\"http:\u002F\u002Fwww.ruanyifeng.com\u002Fblog\u002F2015\u002F12\u002Fgit-workflow.html\"\u003Egit 工作流-阮老师的\u003C\u002Fa\u003E\n\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fxirong\u002Fmy-git\u002Fblob\u002Fmaster\u002Fgit-workflow-tutorial.md\"\u003Egit 工作流\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n"},{title:"七牛回收测试域名后，下载图片",slug:"2018_11_qiniu-download-pic",description:"月中就收到了七牛测试域名被回收的邮件。没多瞥几眼，直接拖到了过期时间，错过了下载图片的时间。",keywords:"七牛,qiniu,下载,图片,域名回收,windows",labels:[a],date:"2018-11-22",path:"2018\u002F11\u002Fqiniu-download-pic.md",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48887594-d3134680-ee6a-11e8-9721-b46722c63f88.png\" alt=\"_20181122152425\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Ch2 id=\"测试域名回收\"\u003E测试域名回收\u003C\u002Fh2\u003E\n\u003Cp\u003E月中就收到了七牛测试域名被回收的邮件。没多瞥几眼，直接拖到了过期时间，错过了下载图片的时间。\u003C\u002Fp\u003E\n\u003Cp\u003E现在考虑不用hexo那个github pages了，转移到github issue区进行记录。博客嘛，不搞花里胡巧了，issue几乎满足所有要求。对于图片挂了这回事，还是要处理的，所以找了下补救措施，也在这记录下。\u003C\u002Fp\u003E\n\u003Ch2 id=\"主要步骤（系统环境windows）\"\u003E主要步骤（系统环境Windows）\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E在对象存储处，新建一个新的存储空间，假设名为\u003Ccode\u003Ebackup\u003C\u002Fcode\u003E，过期的空间名为\u003Ccode\u003Eimages\u003C\u002Fcode\u003E。注意存储区域选择和原有过期空间一致。\u003C\u002Fli\u003E\n\u003Cli\u003E下载\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fqiniu\u002Fqshell\"\u003Eqshell\u003C\u002Fa\u003E。下载解压后应该包含以下几端的qshell文件（以下载回来的文件为主）。\n\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48888437-aa408080-ee6d-11e8-8a4b-ab02b58a6f7d.png\" alt=\"image\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E根据对于系统选择对应的qshell文件。注意windows不要双击打开，应该在该目录处打开shell脚本，输入文件名代替qshell命令。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E查看qshell版本检查qshell是否可用：\n\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48888591-2f2b9a00-ee6e-11e8-8732-14a97de2baac.png\" alt=\"image\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Col start=\"4\"\u003E\n\u003Cli\u003E\u003Cp\u003E按以下命令格式配置七牛账号信息，注意命令包含AK（access_key）、SK（secret_key）以及账户名（注册邮箱）。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Eqshell_windows_x64.exe account AK SK \u003Cspan class=\"hljs-keyword\"\u003ENAME\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48888794-c133a280-ee6e-11e8-9edb-db6b3db9188c.png\" alt=\"image\" \u003E\u003C\u002Fdiv\u003E\n\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fqiniu\u002Fqshell\u002Fblob\u002Fmaster\u002Fdocs\u002Faccount.md\"\u003E命令account参考\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E导出图片信息列表到txt文件。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Eqshell_wi\u003Cspan class=\"hljs-symbol\"\u003Endows_x64\u003C\u002Fspan\u003E.exe -v  listbucket images -o tocopy.txt\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fqiniu\u002Fqshell\u002Fblob\u002Fmaster\u002Fdocs\u002Flistbucket.md\"\u003E命令listbucket参考\u003C\u002Fa\u003E\n完成后，tocopy.txt就包含了原有过期空间images的所有文件信息。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E只保留tocopy.txt每行内的文件名，其余的去掉。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E使用batchcopy命令迁移。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Eqshell_windows_x64.exe -v  \u003Cspan class=\"hljs-keyword\"\u003Ebatchcopy \u003C\u002Fspan\u003Eimages \u003Cspan class=\"hljs-keyword\"\u003Ebackup \u003C\u002Fspan\u003E-i tocopy.txt\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fqiniu\u002Fqshell\u002Fblob\u002Fmaster\u002Fdocs\u002Fbatchcopy.md\"\u003E命令batchcopy参考\u003C\u002Fa\u003E\n自此，空间文件迁移成功，可以到新空间查看图片或者下载图片了。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"},{title:"用小程序做个动态倒计时",slug:"2018_10_mp-countdown",description:"最近由于业务需要，需要做一个倒计时的小插件，想想自己在很久以前用JavaScript写过，操作dom，很快就可以修改对应的数字了。现在换到小程序后，主要的还是去更改data的值，进而修改对应的图片。",keywords:"小程序,倒计时,编写",labels:[c],date:e,path:"2018\u002F10\u002Fmp-countdown.md",html:"\u003Ch3 id=\"写在前\"\u003E写在前\u003C\u002Fh3\u003E\n\u003Cp\u003E最近由于业务需要，需要做一个倒计时的小插件，想想自己在很久以前用JavaScript写过，操作dom，很快就可以修改对应的数字了。现在换到小程序后，主要的还是去更改data的值，进而修改对应的图片。  \u003C\u002Fp\u003E\n\u003C!--more--\u003E\n\n\u003Ch3 id=\"效果\"\u003E效果\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F22\u002F微信截图_20181122151328.png\" alt=\"counter\" \u003E\u003C\u002Fdiv\u003E\n具体：  \u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E精度为天时分秒\u003C\u002Fli\u003E\n\u003Cli\u003E初始时间可以从接口获取\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"代码\"\u003E代码\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E\u003Cspan class=\"xml\"\u003E  \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Eview\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eclass\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;counter&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    距离活动结束仅剩\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ebindload\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;showPicture&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eclass\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;clock&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Emode\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;widthFix&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;..\u002F..\u002Fsrc\u002Fimages\u002Fclock\u002Fnum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{{\u003Cspan class=\"hljs-name\"\u003Ecount.dayBegin\u003C\u002Fspan\u003E}}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E\u003Cspan class=\"hljs-string\"\u003E.png&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ebindload\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;showPicture&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eclass\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;clock&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Emode\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;widthFix&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;..\u002F..\u002Fsrc\u002Fimages\u002Fclock\u002Fnum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{{\u003Cspan class=\"hljs-name\"\u003Ecount.dayEnd\u003C\u002Fspan\u003E}}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E\u003Cspan class=\"hljs-string\"\u003E.png&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    天\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ebindload\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;showPicture&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eclass\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;clock&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Emode\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;widthFix&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;..\u002F..\u002Fsrc\u002Fimages\u002Fclock\u002Fnum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{{\u003Cspan class=\"hljs-name\"\u003Ecount.hourBegin\u003C\u002Fspan\u003E}}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E\u003Cspan class=\"hljs-string\"\u003E.png&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ebindload\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;showPicture&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eclass\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;clock&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Emode\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;widthFix&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;..\u002F..\u002Fsrc\u002Fimages\u002Fclock\u002Fnum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{{\u003Cspan class=\"hljs-name\"\u003Ecount.hourEnd\u003C\u002Fspan\u003E}}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E\u003Cspan class=\"hljs-string\"\u003E.png&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    时\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ebindload\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;showPicture&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eclass\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;clock&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Emode\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;widthFix&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;..\u002F..\u002Fsrc\u002Fimages\u002Fclock\u002Fnum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{{\u003Cspan class=\"hljs-name\"\u003Ecount.minuteBegin\u003C\u002Fspan\u003E}}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E\u003Cspan class=\"hljs-string\"\u003E.png&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ebindload\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;showPicture&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eclass\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;clock&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Emode\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;widthFix&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;..\u002F..\u002Fsrc\u002Fimages\u002Fclock\u002Fnum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{{\u003Cspan class=\"hljs-name\"\u003Ecount.minuteEnd\u003C\u002Fspan\u003E}}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E\u003Cspan class=\"hljs-string\"\u003E.png&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    分\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ebindload\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;showPicture&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eclass\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;clock&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Emode\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;widthFix&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;..\u002F..\u002Fsrc\u002Fimages\u002Fclock\u002Fnum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{{\u003Cspan class=\"hljs-name\"\u003Ecount.secondBegin\u003C\u002Fspan\u003E}}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E\u003Cspan class=\"hljs-string\"\u003E.png&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ebindload\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;showPicture&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eclass\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;clock&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Emode\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;widthFix&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;..\u002F..\u002Fsrc\u002Fimages\u002Fclock\u002Fnum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{{\u003Cspan class=\"hljs-name\"\u003Ecount.secondEnd\u003C\u002Fspan\u003E}}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E\u003Cspan class=\"hljs-string\"\u003E.png&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Eimage\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    秒\n  \u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Eview\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 初始值\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-attr\"\u003Etimer\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E,\n\u003Cspan class=\"hljs-attr\"\u003Edata\u003C\u002Fspan\u003E: {\n  \u003Cspan class=\"hljs-attr\"\u003Ecount\u003C\u002Fspan\u003E: {\n    \u003Cspan class=\"hljs-attr\"\u003EexpireDate\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E172800\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F s\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003EdayBegin\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-attr\"\u003EdayEnd\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-attr\"\u003EhourBegin\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-attr\"\u003EhourEnd\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-attr\"\u003EminuteBegin\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-attr\"\u003EminuteEnd\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-attr\"\u003EsecondBegin\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-attr\"\u003EsecondEnd\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n  }\n}\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 接口回调处\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E { count } = \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.data\ndelele count[\u003Cspan class=\"hljs-string\"\u003E`expireDate`\u003C\u002Fspan\u003E] \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 删除原count中的expireDate\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.setData({\n  ...count,\n  \u003Cspan class=\"hljs-attr\"\u003EexpireDate\u003C\u002Fspan\u003E: newExpireDate\n})\n\u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.timer = \u003Cspan class=\"hljs-built_in\"\u003EsetInterval\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E expireDate = \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.data.count.expireDate - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.setData({\n    \u003Cspan class=\"hljs-attr\"\u003Ecount\u003C\u002Fspan\u003E: {\n      \u003Cspan class=\"hljs-attr\"\u003EdayBegin\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.convertTime(expireDate)[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E][\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E],\n      \u003Cspan class=\"hljs-attr\"\u003EdayEnd\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.convertTime(expireDate)[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E][\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E],\n      \u003Cspan class=\"hljs-attr\"\u003EhourBegin\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.convertTime(expireDate)[\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E][\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E],\n      \u003Cspan class=\"hljs-attr\"\u003EhourEnd\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.convertTime(expireDate)[\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E][\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E],\n      \u003Cspan class=\"hljs-attr\"\u003EminuteBegin\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.convertTime(expireDate)[\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E][\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E],\n      \u003Cspan class=\"hljs-attr\"\u003EminuteEnd\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.convertTime(expireDate)[\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E][\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E],\n      \u003Cspan class=\"hljs-attr\"\u003EsecondBegin\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.convertTime(expireDate)[\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E][\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E],\n      \u003Cspan class=\"hljs-attr\"\u003EsecondEnd\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.convertTime(expireDate)[\u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E][\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E],\n      expireDate,\n    }\n  })\n}, \u003Cspan class=\"hljs-number\"\u003E1000\u003C\u002Fspan\u003E)\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F**\n * 时间转化函数，时间戳入参为秒\n*\u002F\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-attr\"\u003EconvertTime\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Esec\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E time\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (sec &gt; -\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) {\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E hour = \u003Cspan class=\"hljs-built_in\"\u003EMath\u003C\u002Fspan\u003E.floor(sec \u002F \u003Cspan class=\"hljs-number\"\u003E3600\u003C\u002Fspan\u003E)\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E min = \u003Cspan class=\"hljs-built_in\"\u003EMath\u003C\u002Fspan\u003E.floor(sec \u002F \u003Cspan class=\"hljs-number\"\u003E60\u003C\u002Fspan\u003E) % \u003Cspan class=\"hljs-number\"\u003E60\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E second = sec % \u003Cspan class=\"hljs-number\"\u003E60\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E day = \u003Cspan class=\"hljs-built_in\"\u003EparseInt\u003C\u002Fspan\u003E(hour \u002F \u003Cspan class=\"hljs-number\"\u003E24\u003C\u002Fspan\u003E)\n    hour = hour - \u003Cspan class=\"hljs-number\"\u003E24\u003C\u002Fspan\u003E * day\n    hour = hour &lt; \u003Cspan class=\"hljs-number\"\u003E10\u003C\u002Fspan\u003E ? \u003Cspan class=\"hljs-string\"\u003E`0\u003Cspan class=\"hljs-subst\"\u003E${hour}\u003C\u002Fspan\u003E`\u003C\u002Fspan\u003E : hour\n    time = day &lt; \u003Cspan class=\"hljs-number\"\u003E10\u003C\u002Fspan\u003E ? \u003Cspan class=\"hljs-string\"\u003E`0\u003Cspan class=\"hljs-subst\"\u003E${day}\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-subst\"\u003E${hour}\u003C\u002Fspan\u003E:`\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E`\u003Cspan class=\"hljs-subst\"\u003E${day}\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-subst\"\u003E${hour}\u003C\u002Fspan\u003E:`\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (min &lt; \u003Cspan class=\"hljs-number\"\u003E10\u003C\u002Fspan\u003E) {\n      time += \u003Cspan class=\"hljs-string\"\u003E&quot;0&quot;\u003C\u002Fspan\u003E\n    }\n    time += min + \u003Cspan class=\"hljs-string\"\u003E&quot;:&quot;\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (second &lt; \u003Cspan class=\"hljs-number\"\u003E10\u003C\u002Fspan\u003E) {\n      time += \u003Cspan class=\"hljs-string\"\u003E&quot;0&quot;\u003C\u002Fspan\u003E\n    }\n    time += second\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E time.split(\u003Cspan class=\"hljs-string\"\u003E&#x27;:&#x27;\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 返回一个包含天时分秒的数组\u003C\u002Fspan\u003E\n  }\n}\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 最后不要忘记在周期销毁处清空计时器\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-attr\"\u003EonUnload\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-built_in\"\u003EclearInterval\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.timer)\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 时间转 **前的函数\u003C\u002Fspan\u003E\n  getDateDiff: \u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E(dateTimeStamp){\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E result = &#x27;&#x27;\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E minute = \u003Cspan class=\"hljs-number\"\u003E1000\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-operator\"\u003E * \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-number\"\u003E60\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E hour = minute\u003Cspan class=\"hljs-operator\"\u003E * \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-number\"\u003E60\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E day = hour\u003Cspan class=\"hljs-operator\"\u003E * \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-number\"\u003E24\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E halfamonth = day\u003Cspan class=\"hljs-operator\"\u003E * \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-number\"\u003E15\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E month = day\u003Cspan class=\"hljs-operator\"\u003E * \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-number\"\u003E30\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E now = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-constructor\"\u003EDate()\u003C\u002Fspan\u003E.get\u003Cspan class=\"hljs-constructor\"\u003ETime()\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E diffValue = now - dateTimeStamp\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E(diffValue &lt; \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E) { return; }\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E monthC = diffValue\u003Cspan class=\"hljs-operator\"\u003E \u002F \u003C\u002Fspan\u003Emonth\n      \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E weekC = diffValue\u003Cspan class=\"hljs-operator\"\u003E \u002F \u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-number\"\u003E7\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-operator\"\u003E * \u003C\u002Fspan\u003Eday)\n      \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E dayC = diffValue\u003Cspan class=\"hljs-operator\"\u003E \u002F \u003C\u002Fspan\u003Eday\n      \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E hourC = diffValue\u003Cspan class=\"hljs-operator\"\u003E \u002F \u003C\u002Fspan\u003Ehour\n      \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E minC = diffValue\u003Cspan class=\"hljs-operator\"\u003E \u002F \u003C\u002Fspan\u003Eminute\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E(monthC&gt;= \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E){\n    result = \u003Cspan class=\"hljs-string\"\u003E&quot;&quot;\u003C\u002Fspan\u003E + parse\u003Cspan class=\"hljs-constructor\"\u003EInt(\u003Cspan class=\"hljs-params\"\u003EmonthC\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E + \u003Cspan class=\"hljs-string\"\u003E&quot;月前&quot;\u003C\u002Fspan\u003E\n    }\n      \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (weekC &gt;= \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) {\n      result = \u003Cspan class=\"hljs-string\"\u003E&quot;&quot;\u003C\u002Fspan\u003E + parse\u003Cspan class=\"hljs-constructor\"\u003EInt(\u003Cspan class=\"hljs-params\"\u003EweekC\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E + \u003Cspan class=\"hljs-string\"\u003E&quot;周前&quot;\u003C\u002Fspan\u003E\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (dayC &gt;= \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) {\n      result = \u003Cspan class=\"hljs-string\"\u003E&quot;&quot;\u003C\u002Fspan\u003E + parse\u003Cspan class=\"hljs-constructor\"\u003EInt(\u003Cspan class=\"hljs-params\"\u003EdayC\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E + \u003Cspan class=\"hljs-string\"\u003E&quot;天前&quot;\u003C\u002Fspan\u003E\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (hourC &gt;= \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) {\n      result = \u003Cspan class=\"hljs-string\"\u003E&quot;&quot;\u003C\u002Fspan\u003E + parse\u003Cspan class=\"hljs-constructor\"\u003EInt(\u003Cspan class=\"hljs-params\"\u003EhourC\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E + \u003Cspan class=\"hljs-string\"\u003E&quot;小时前&quot;\u003C\u002Fspan\u003E\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (minC &gt;= \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E) {\n      result = \u003Cspan class=\"hljs-string\"\u003E&quot;&quot;\u003C\u002Fspan\u003E + parse\u003Cspan class=\"hljs-constructor\"\u003EInt(\u003Cspan class=\"hljs-params\"\u003EminC\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E + \u003Cspan class=\"hljs-string\"\u003E&quot;分钟前&quot;\u003C\u002Fspan\u003E\n    } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E\n      result = \u003Cspan class=\"hljs-string\"\u003E&quot;刚刚&quot;\u003C\u002Fspan\u003E\n    return result\n  },\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"最后\"\u003E最后\u003C\u002Fh3\u003E\n\u003Cp\u003E相关思路适用于所有mvvm框架。\u003C\u002Fp\u003E\n"},{title:x,slug:"2018_10_month-pass",description:"很忙。最近在业务上花的时间很多，公司内有一批业务陆陆续续到来，只好花了时间去做好来。也就大半个月的时间吧，有了很多的事情，我也没有常来这里看看，所以就遗忘了。心想也是，在Google、Baidu都很难搜索到我的帖子所以不管了吧。当作自己的一个小地方得了。",keywords:x,labels:[d],date:e,path:"2018\u002F10\u002Fmonth-pass.md",html:"\u003Ch3 id=\"上一篇发布于2018-08-20\"\u003E上一篇发布于2018-08-20\u003C\u002Fh3\u003E\n\u003Cp\u003E很忙。最近在业务上花的时间很多，公司内有一批业务陆陆续续到来，只好花了时间去做好来。也就大半个月的时间吧，有了很多的事情，我也没有常来这里看看，所以就遗忘了。\n心想也是，在Google、Baidu都很难搜索到我的帖子所以不管了吧。当作自己的一个小地方得了。\u003C\u002Fp\u003E\n\u003Ch3 id=\"技术栈\"\u003E技术栈\u003C\u002Fh3\u003E\n\u003Cp\u003E说一下最近在前端的实践：Jquery Vue 小程序之间来回切换，自身所负责的前端项目大概有3~4个，逐渐的对这样的开发情况熟悉起来了。最近小程序开放了云开发后台，非常\n感兴趣，在打开vscode去实践的时候，猛然发现博客没写好久了，所以就上来写两句。待会就去实践云开发啦。\u003Cbr\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F22\u002F微信截图_20180913213730.png\" alt=\"微信截图_20180913213730\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"infinite\"\u003EInfinite\u003C\u002Fh3\u003E\n\u003Cp\u003E未来会更好，专注前端开发。多接触好的技术，创造无限。\n\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F22\u002F微信图片_20180913213837.jpg\" alt=\"微信图片_20180913213837\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n"},{title:"一次h5开发踩坑记录",slug:"2018_10_h5-step",description:"这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。",keywords:"h5,踩坑,vue,vux",labels:[a],date:e,path:"2018\u002F10\u002Fh5-step.md",html:"\u003Ch3 id=\"时间\"\u003E时间\u003C\u002Fh3\u003E\n\u003Cp\u003E这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。\u003C\u002Fp\u003E\n\u003Ch3 id=\"使用框架\"\u003E使用框架\u003C\u002Fh3\u003E\n\u003Cp\u003E原本想直接了当用jQuery，毕竟用jQuery开发是真的快而且紧急情况可控。缺点是写起来会比较乱，维护也比较麻烦。但最后还是放弃，想尝试新的技术。最后试用了几套框架|库后，决定使用vux进行编写。\u003C\u002Fp\u003E\n\u003C!--more--\u003E\n\u003Ch3 id=\"vux\"\u003EVux\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48887191-5af85100-ee69-11e8-84e9-fc534223e75b.png\" alt=\"tim 20181015093748\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E使用原因：  \u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E使用vue-cli构建，几乎不用配置其余东西，内建命令让开发和打包生产版十分便捷。\u003C\u002Fli\u003E\n\u003Cli\u003Evux有大量组件而且github上有非常多的issue记录，遇到问题可以快速定位解决。\u003C\u002Fli\u003E\n\u003Cli\u003Evue生态给力，写起来舒舒服服。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"主要坑\"\u003E主要坑\u003C\u002Fh3\u003E\n\u003Cp\u003E由于第一次用vux写h5，难免会遇到不少问题，不仅是框架本身的问题，还有其他业务上需要攻克的问题。就记录下踩过的坑：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Ebackground-image在部署的时候路径不对。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E修改vue-cli的build文件夹下的utils.js为如下：\n\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48887225-7b281000-ee69-11e8-85a0-6e465667d9c4.png\" alt=\"util\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E这样在 CSS 中：background-image: url(&quot;.\u002Fassets\u002Fbg.jpg&quot;)，不管是在开发环境下还是在生产环境下，背景图都可以读出来\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E怎么生成图片并在微信端支持长按保存图片？  \u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E以前也做过类似的，但没做过微信支持长按保存图片的。首先当然是要用到将html转为canvas然后再考虑转为图片。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E库：\u003Ca target='_blank'  href=\"https:\u002F\u002Fhtml2canvas.hertzen.com\u002Fdocumentation\"\u003Ehtml2canvas\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E用法非常简单，指定挂载的元素进行转化。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Ehtml2canvas(\u003Cspan class=\"hljs-built_in\"\u003Edocument\u003C\u002Fspan\u003E.body).then(\u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003Ecanvas\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(canvas);    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这个是生成的canvas\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E base64Code = canvas.toDataURL(\u003Cspan class=\"hljs-string\"\u003E&quot;image\u002Fpng&quot;\u003C\u002Fspan\u003E);    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F将生成的canvas通过api`toDataURL`转为base64格式图片。\u003C\u002Fspan\u003E\n});\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E怎么保存图片？\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E不是已经生成图片了吗？生成就可以可以保存了。没错，但是业务问题，在生成的图片上还要包含可点击的按钮和一个超链接。可以想到，可以将按钮和超链接定位到生成的图片上。可是存在这样的问题，不同的移动端呈现的结果可能不一致，这会直接导致页面显示出现问题，进而影响使用体验。这种覆盖的想法最后放弃了。\u003C\u002Fp\u003E\n\u003Cp\u003E最后的做法：将生成的图片的透明度设置为0覆盖到原本要渲染的元素上，然后提高可点击按钮的层级。\n\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48887259-95fa8480-ee69-11e8-8564-ddbccc8f1e26.png\" alt=\"tim 20181015100607\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E存在无法分享到朋友圈的问题\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E微信浏览器唤起的分享菜单，存在点击分享到朋友圈出现卡死问题。\n排查过程： 在页面操作第一步和第二步都不会有这个问题，在生成图片的第三步就出现无法分享的问题。在想是不是生成图片太大了导致太卡顿了？在开发调试过程，打开vue开发工具查看第三步data的时候，发现非常卡顿。这样就可以认定是图片造成的卡顿了。\u003C\u002Fp\u003E\n\u003Cp\u003E最后找到的原因：canvas生成的base64编码的图片码十分长，直接导致vue处理的时候出现卡顿严重进而影响页面分享效果。最后的解决方案：将base64转为file上传，最后展示返回的url图片。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E base64Code = canvas.toDataURL(\u003Cspan class=\"hljs-string\"\u003E&quot;image\u002Fpng&quot;\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 去掉url的头，并转换为byte。以下步骤生成JavaScript blob文件\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E bytes = \u003Cspan class=\"hljs-built_in\"\u003Ewindow\u003C\u002Fspan\u003E.atob(base64Code.split(\u003Cspan class=\"hljs-string\"\u003E&#x27;,&#x27;\u003C\u002Fspan\u003E)[\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E])\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E ab = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EArrayBuffer\u003C\u002Fspan\u003E(bytes.length)\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E ia = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EUint8Array\u003C\u002Fspan\u003E(ab)\n  \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; bytes.length; i++) {\n    ia[i] = bytes.charCodeAt(i)\n  }\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E files = self.blobToFile(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Blob([ab], { \u003Cspan class=\"hljs-attr\"\u003Etype\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;png&#x27;\u003C\u002Fspan\u003E }), \u003Cspan class=\"hljs-string\"\u003E&#x27;post&#x27;\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E formData = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E FormData()\n  formData.append(\u003Cspan class=\"hljs-string\"\u003E&quot;file&quot;\u003C\u002Fspan\u003E, files, \u003Cspan class=\"hljs-string\"\u003E`myPost-\u003Cspan class=\"hljs-subst\"\u003E${\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EDate\u003C\u002Fspan\u003E().getTime()}\u003C\u002Fspan\u003E.png`\u003C\u002Fspan\u003E);\n  self.$http.post(config.fileUploadURL, formData, {\n    \u003Cspan class=\"hljs-attr\"\u003Eheaders\u003C\u002Fspan\u003E: {\n      \u003Cspan class=\"hljs-string\"\u003E&#x27;Content-Type&#x27;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;multipart\u002Fform-data&#x27;\u003C\u002Fspan\u003E\n    }\n  }).then (\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003EuploadRes\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (uploadRes.data.code === \u003Cspan class=\"hljs-number\"\u003E200\u003C\u002Fspan\u003E) {\n      self.imageBase = uploadRes.data.url\n    }\n  })\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F blob图片转为文件的函数\u003C\u002Fspan\u003E\n  blobToFile (theBlob, fileName){\n    theBlob.lastModifiedDate = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EDate\u003C\u002Fspan\u003E();\n    theBlob.name = fileName;\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E theBlob;\n  }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"成品\"\u003E成品\u003C\u002Fh3\u003E\n\u003Cp\u003E虽然国庆过了，但是还是贴出来哈哈。\n\u003Ca target='_blank'  href=\"http:\u002F\u002Fxiaolu.ybj.com\u002Fwechat\u002Fhtml\u002Fgqyx\u002Findex.html\"\u003E活动\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n"},{title:"防盗链的解析",slug:"2018_10_anti-theft",description:"最近涉及到了图片防盗链的问题，链接是特殊的，不能被其他网站解析为图片。说下来有几种办法，当然解决后发现还是最后那种简单便捷。唯一的缺点就是大概也许差不多可能无法访问到。这个没关系，只要保佑保佑，总会比加iframe轻松愉悦的。",keywords:"防盗链",labels:[a],date:e,path:"2018\u002F10\u002Fanti-theft.md",html:"\u003Ch3 id=\"前言\"\u003E前言\u003C\u002Fh3\u003E\n\u003Cp\u003E最近涉及到了图片防盗链的问题，链接是特殊的，不能被其他网站解析为图片。说下来有几种办法，当然解决后发现还是最后那种简单便捷。唯一的缺点就是大概也许差不多可能无法访问到。这个没关系，只要保佑保佑，总会比加iframe轻松愉悦的。  \u003C\u002Fp\u003E\n\u003Cp\u003E首先，你看到的图片会是这样的：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fmmbiz.qpic.cn\u002Fmmbiz_jpg\u002FcfehZicXpD0ib9BP0iafksSmxPcWm4ORDGkD5ibHIHeWSyWjHriaFGhHLFvZNwiau4icCOBvT56MktVFATAf1D8vuyOHw\u002F0?wx_fmt=jpeg\" alt=\"例图\" \u003E\u003C\u002Fdiv\u003E  \u003C\u002Fp\u003E\n\u003Cp\u003E实际上，如果你能看到上面这张图，说明你骨骼精奇，自带解锁功能。\n但是我们想直接看到：  \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.weserv.nl\u002F?url=\u002F\u002Fmmbiz.qpic.cn\u002Fmmbiz_jpg\u002FcfehZicXpD0ib9BP0iafksSmxPcWm4ORDGkD5ibHIHeWSyWjHriaFGhHLFvZNwiau4icCOBvT56MktVFATAf1D8vuyOHw\u002F0?wx_fmt=jpeg\" alt=\"例图\" \u003E\u003C\u002Fdiv\u003E  \u003C\u002Fp\u003E\n\u003Cp\u003E那怎么做呢？\u003C\u002Fp\u003E\n\u003Ch3 id=\"页面头部加入标签\"\u003E页面头部加入\u003Cmate\u003E标签\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E&lt;meta \u003Cspan class=\"hljs-attribute\"\u003Ename\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;referrer&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attribute\"\u003Econtent\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;never&quot;\u003C\u002Fspan\u003E&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这种办法通过控制referer绕过防盗链的检测。html可以通过这个参数决定http请求中的referer，要注意使用这个标签属性的时候，浏览器原有的referer策略就发生改变了。\u003C\u002Fp\u003E\n\u003Ch3 id=\"图片在iframe内显示\"\u003E图片在iframe内显示\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eurl\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&#x27;防盗的链接&#x27;\u003C\u002Fspan\u003E;\n\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E finalUrl = displayImg(\u003Cspan class=\"hljs-built_in\"\u003Eurl\u003C\u002Fspan\u003E);\n\u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(finalUrl);\n\u003Cspan class=\"hljs-built_in\"\u003Edocument\u003C\u002Fspan\u003E.getElementById(\u003Cspan class=\"hljs-string\"\u003E&#x27;img&#x27;\u003C\u002Fspan\u003E).innerHTML = finalUrl;\n\ndisplayImg = (\u003Cspan class=\"hljs-built_in\"\u003Eurl\u003C\u002Fspan\u003E) =&gt; {\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E iFrameid = \u003Cspan class=\"hljs-string\"\u003E&#x27;frameimg&#x27;\u003C\u002Fspan\u003E + \u003Cspan class=\"hljs-built_in\"\u003EMath\u003C\u002Fspan\u003E.random();\n    \u003Cspan class=\"hljs-built_in\"\u003Ewindow\u003C\u002Fspan\u003E.img = \u003Cspan class=\"hljs-string\"\u003E&#x27;&lt;img id=&quot;img&quot; src=\\&#x27;&#x27;\u003C\u002Fspan\u003E + \u003Cspan class=\"hljs-built_in\"\u003Eurl\u003C\u002Fspan\u003E + \u003Cspan class=\"hljs-string\"\u003E&#x27;?&#x27;\u003C\u002Fspan\u003E + \u003Cspan class=\"hljs-built_in\"\u003EMath\u003C\u002Fspan\u003E.random() + \u003Cspan class=\"hljs-string\"\u003E&#x27;\\&#x27; \u002F&gt;&#x27;\u003C\u002Fspan\u003E;\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;&lt;iframe id=&quot;&#x27;\u003C\u002Fspan\u003E + iFrameid + \u003Cspan class=\"hljs-string\"\u003E&#x27;&quot; src=&quot;javascript:parent.img;&quot; frameBorder=&quot;0&quot; scrolling=&quot;no&quot; width=&quot;100%&quot;&gt;&lt;\u002Fiframe&gt;&#x27;\u003C\u002Fspan\u003E;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这样可以正常显示图片，除了多了iframe外也没啥太大的问题，但是我发现在Vue里面一旦数据更新iframe就会刷新，外加上插件vue-draggable没法用了所以我就放弃这个方法了。这也促使我找更好的方案👇。\u003C\u002Fp\u003E\n\u003Ch3 id=\"传送门--跳板\"\u003E传送门 | 跳板\u003C\u002Fh3\u003E\n\u003Cp\u003E所以最后我还是找到了一个好的方法，搜索引擎下，发现大部分的跳板都被清理了。不要慌，总会有的，对于怎么找到这个跳板的话，我的建议是怎么不去对比一下开头的两张图？😄😄😄\u003C\u002Fp\u003E\n"},{title:"微信小程序踩坑",slug:"2018_05_mp-back",description:"大概写了大半年的React，回想起来还真是挺长的。一直都想找机会了解更多的项目内容，小程序就是一直想去了解的。不过，就算是更换了工作内容，我还是很喜欢开源技术的。对于React的关注也一直没有停止，打心底的喜欢React这一个充满活力的库。",keywords:"微信小程序",labels:[c],date:"2018-05-16",path:"2018\u002F05\u002Fmp-back.md",html:"\u003Ch2 id=\"react-----微信小程序开发\"\u003EReact -- &gt; 微信小程序开发\u003C\u002Fh2\u003E\n\u003Ch3 id=\"因工作需要，这一段时间将进行小程序的开发工作\"\u003E因工作需要，这一段时间将进行小程序的开发工作\u003C\u002Fh3\u003E\n\u003Cp\u003E大概写了大半年的React，回想起来还真是挺长的。一直都想找机会了解更多的项目内容，小程序就是一直想去了解的。不过，就算是更换了工作内容，我还是很喜欢开源技术的。对于React的关注也一直没有停止，打心底的喜欢React这一个充满活力的库。\u003Cbr\u003E除了小程序外，Vue的开发有空会去了解并去写一些简单的Demo。额，这一篇内容还是记录一下小程序的踩坑过程。\u003C\u002Fp\u003E\n\u003C!--more--\u003E\n\n\u003Ch3 id=\"小程序基本概况\"\u003E小程序基本概况\u003C\u002Fh3\u003E\n\u003Cp\u003E小程序的理念就是用完就走，不用多停留。从小程序面世到现在也过了几年了吧，在我注册一个个人开发者账号到写下第一行代码这个过程，比我想象中还是顺利的多。这得益于还是挺清晰的官方文档，里面也包含了一些基本的Demo。\u003Cbr\u003E槽点：\u003Ca target='_blank'  href=\"https:\u002F\u002Fdevelopers.weixin.qq.com\u002Fminiprogram\u002Fdev\u002F\"\u003E官方文档\u003C\u002Fa\u003E访问体验很差，难道是我电脑问题，搜索一个api有很大的几率拿不到正确返回。希望后面能有一个畅快的阅读文档体验。\u003C\u002Fp\u003E\n\u003Ch3 id=\"小程序生态\"\u003E小程序生态\u003C\u002Fh3\u003E\n\u003Cp\u003E在github的repo搜索“小程序”，最多star的是\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fjustjavac\u002Fawesome-wechat-weapp\"\u003Eawesome-wechat-weapp\u003C\u002Fa\u003E。这个repo起到一个导航作用，在github带awesome开头的一般都是以收集数据为主的仓库。可以得到的信息是，看起来小程序的开发生态很不错，但认真点进每一个仓库的链接，会发现并没有想象中那么多。这个应该是我被React的生态惯坏了。没关系，先看看小程序开发有哪些比较知名的repo吧。  \u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002FTencent\u002Fwepy\"\u003EWePY\u003C\u002Fa\u003E ★10k+ - 支持组件化的小程序开发框架\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002FMeituan-Dianping\u002Fmpvue\"\u003Empvue\u003C\u002Fa\u003E ★8.7k - 基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系\u003Cbr\u003E槽点：原本打算用WePy做生产环境的开发，但是看到众多人吐槽bug我就吓退了。整体而言，小程序的生态还没有我想象中那么好。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"开发体验\"\u003E开发体验\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E在Windows下使用官方小程序开发工具，可以快速搭建小程序结构，提供实时预览，以及小程序可以在手机可以进行实时运行。开发过程中出现有如预览和手机上的样式不一致等的问题。\u003C\u002Fli\u003E\n\u003Cli\u003E自带开发工具的控制台在调试样式选取元素的体验上很差。我选不到元素，只好从Wxml上按代码筛查需要改的选择器再进行修改。\u003C\u002Fli\u003E\n\u003Cli\u003E类似于MVVM的开发体验。一个页面对应一个page，页面以及app的生命周期分明。\u003C\u002Fli\u003E\n\u003Cli\u003E大部分的api都采取回调的方式返回内容，整体结构很清晰。\u003C\u002Fli\u003E\n\u003Cli\u003E路由跳转很轻松。\u003C\u002Fli\u003E\n\u003Cli\u003E很像React的一点就是state的存在方式，在小程序上就是Data。每个page都可以设置属于这个页面的数据。\u003C\u002Fli\u003E\n\u003Cli\u003E有类似与Vue的语法糖\u003C\u002Fli\u003E\n\u003Cli\u003E很多组件官方都封装好了，使用起来很方便。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"目前踩的坑\"\u003E目前踩的坑\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003Ewx.getUserInfo()这个接口在我刚入门小程序的这段时间被砍了。对我影响不大，但是对开发而言这种底层的api的改动影响还是很大的。\u003Cbr\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48886468-08b63080-ee67-11e8-8f63-83d81534d6ad.gif\" alt=\"default\" \u003E\u003C\u002Fdiv\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E高度适配上没考虑好问题，所以有那么一点时间是花在适配如iphoneX上。\u003C\u002Fli\u003E\n\u003Cli\u003E如何去掉小程序按钮的边框？\u003Cpre\u003E\u003Ccode\u003Eselector\u003Cspan class=\"hljs-selector-pseudo\"\u003E::after\u003C\u002Fspan\u003E{\n\u003Cspan class=\"hljs-attribute\"\u003Eborder\u003C\u002Fspan\u003E: none;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E怎么修改checkbox的大小？\u003Cpre\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-selector-class\"\u003E.checkbox\u003C\u002Fspan\u003E {\n\u003Cspan class=\"hljs-attribute\"\u003Etransform\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-built_in\"\u003Escale\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-number\"\u003E0.6\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E0.6\u003C\u002Fspan\u003E);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"后语\"\u003E后语\u003C\u002Fh3\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E目前还没对接数据接口，不知道会有什么坑等着我。而且如果后期需要封装组件的话，还不知道会发生什么问题呢。也很希望官方多为开发者着想下，不要轻易动底层api，不然又要多熬几天夜的人就不少了。再接再厉，好好学习。\u003C\u002Fp\u003E\n"},{title:"Ubuntu的搜狗输入法出现候选词乱码的问题",slug:"2018_04_ubuntu-sougou",description:"ubuntu的搜狗输入法会出现候选词乱码的情况，只会出现在中文上，怎么解决呢？",keywords:"ubuntu,sougou,code",labels:[b],date:"2018-04-08",path:"2018\u002F04\u002Fubuntu-sougou.md",html:"\u003Cpre\u003E\u003Ccode\u003E$ rm -rf ~\u003Cspan class=\"hljs-regexp\"\u003E\u002F.config\u002F\u003C\u002Fspan\u003ESogouPY ~\u003Cspan class=\"hljs-regexp\"\u003E\u002F.config\u002F\u003C\u002Fspan\u003Esogou*\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E然后重启reboot\u003C\u002Fp\u003E\n"},{title:y,slug:"2017_12_linux-mint",description:y,keywords:"linux,mint,soft,tools",labels:[b],date:"2017-12-21",path:"2017\u002F12\u002Flinux-mint.md",html:"\u003Ch2 id=\"系统\"\u003E系统\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fwww.google.com\u002Fchrome\u002Fbrowser\u002Fdesktop\u002Findex.html\"\u003EGoogle\u003C\u002Fa\u003E\u003Cbr\u003E 谷歌页面缩放125%\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fpinyin.sogou.com\u002Flinux\u002F?r=pinyin\"\u003E搜狗输入法\u003C\u002Fa\u003E\u003Cbr\u003E 重启-输入法设置成功-QQ登录同步词库\u003C\u002Fli\u003E\n\u003Cli\u003E安装扩展透明状态栏\u003Cbr\u003E 设置-面板-扩展\u003C\u002Fli\u003E\n\u003Cli\u003Eterminal\u003Cbr\u003E ctrl + shift + c --&gt; ctrl + c  \u003C\u002Fli\u003E\n\u003Cli\u003E创建ssh key  \u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fsettings\u002Fkeys\"\u003E粘贴到github\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Esh-keygen \u003C\u002Fspan\u003E-t rsa -\u003Cspan class=\"hljs-keyword\"\u003Eb \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-number\"\u003E4096\u003C\u002Fspan\u003E -C \u003Cspan class=\"hljs-string\"\u003E&quot;gzy.guy@gmail.com&quot;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"6\"\u003E\n\u003Cli\u003E安装oh my zsh\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Ehttps:\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002Fgi\u003C\u002Fspan\u003Ethub.com\u003Cspan class=\"hljs-regexp\"\u003E\u002Frobbyrussell\u002F\u003C\u002Fspan\u003Eoh-my-zsh\nsudo apt-get install zsh\nsudo apt-get install git\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"7\"\u003E\n\u003Cli\u003E设置小飞机\u003Cbr\u003E \u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002FGzhiYi\u002Ffrontend-log\u002Fissues\u002F2\"\u003E#链接\u003C\u002Fa\u003E  \u003C\u002Fli\u003E\n\u003Cli\u003E安装vscode\u003Cbr\u003E \u003Ca target='_blank'  href=\"https:\u002F\u002Fcode.visualstudio.com\u002F\"\u003EvsCode\u003C\u002Fa\u003E\u003Cbr\u003E 下载安装扩展setting-sync 需要token 和 gistId\u003C\u002Fli\u003E\n\u003Cli\u003E字体问题\u003Cbr\u003E \u003Ca target='_blank'  href=\"http:\u002F\u002Ftieba.baidu.com\u002Fp\u002F5128932851\"\u003E链接\u003C\u002Fa\u003E\u003Cbr\u003E 软件管理器 - 删除 Fonts-arphic-ukai  Fonts-arphic-uming\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"项目\"\u003E项目\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E安装nvm\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo apt-\u003Cspan class=\"hljs-built_in\"\u003Eget\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eupdate\u003C\u002Fspan\u003E\nsudo apt-\u003Cspan class=\"hljs-built_in\"\u003Eget\u003C\u002Fspan\u003E install build-essential libssl-dev\ncurl -sL http\u003Cspan class=\"hljs-variable\"\u003Es:\u003C\u002Fspan\u003E\u002F\u002Fraw.githubusercontent.\u003Cspan class=\"hljs-keyword\"\u003Ecom\u003C\u002Fspan\u003E\u002Fcreationix\u002Fnvm\u002Fv0.\u003Cspan class=\"hljs-number\"\u003E31.0\u003C\u002Fspan\u003E\u002Finstall.\u003Cspan class=\"hljs-keyword\"\u003Esh\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-keyword\"\u003Eo\u003C\u002Fspan\u003E install_nvm.\u003Cspan class=\"hljs-keyword\"\u003Esh\u003C\u002Fspan\u003E\nbash install_nvm.\u003Cspan class=\"hljs-keyword\"\u003Esh\u003C\u002Fspan\u003E\nnvm use \u003Cspan class=\"hljs-number\"\u003E6.11\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-number\"\u003E5\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E换源\u003Cbr\u003E \u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002FGzhiYi\u002Ffrontend-log\u002Fissues\u002F4\"\u003E链接\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E安装postgres\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo apt-\u003Cspan class=\"hljs-keyword\"\u003Eget\u003C\u002Fspan\u003E install postgresql-client\nsudo apt-\u003Cspan class=\"hljs-keyword\"\u003Eget\u003C\u002Fspan\u003E install postgresql\nsudo apt-\u003Cspan class=\"hljs-keyword\"\u003Eget\u003C\u002Fspan\u003E install pgadmin3\nsudo su - postgres\npsql\n\u003Cspan class=\"hljs-keyword\"\u003Ecreate\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Erole\u003C\u002Fspan\u003E gzhiyi \u003Cspan class=\"hljs-keyword\"\u003Elogin\u003C\u002Fspan\u003E;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"4\"\u003E\n\u003Cli\u003E安装virtualenv  \u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo apt-\u003Cspan class=\"hljs-builtin-name\"\u003Eget\u003C\u002Fspan\u003E install virtualenv\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"问题\"\u003E问题\u003C\u002Fh2\u003E\n\u003Cp\u003Eubuntu 系的chrome有个闪屏的问题， 原因还是因为显卡。\n有解决办法：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E关闭chrome设置中的硬件加速。\u003C\u002Fli\u003E\n\u003Cli\u003E打开 chrome:\u002F\u002Fflags， 找到GPU rasterization，选择Force enable for layers。\n第二个不知道有没用。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E只是没有闪的问题，但是还有些异常的\u003C\u002Fp\u003E\n"},{title:"前端搭建win10-ubuntu双系统的小记",slug:"2017_11_win10-ubuntu",description:"笔记本安装win10和ubuntu做开发本",keywords:"前端,win10,ubuntu,gnome",labels:[b],date:z,path:"2017\u002F11\u002Fwin10-ubuntu.md",html:"\u003Ch2 id=\"首先版本是ubuntu-1604lts非麒麟版本。\"\u003E首先版本是Ubuntu 16.04(LTS)非麒麟版本。\u003C\u002Fh2\u003E\n\u003Cp\u003E由于时间不多，主要拿Ubuntu进行web开发。其他发行版并未尝试。也好记录一下配置Ubuntu以及gnome的走过的坑。\u003C\u002Fp\u003E\n\u003Ch3 id=\"安装ubuntu\"\u003E安装Ubuntu\u003C\u002Fh3\u003E\n\u003Cp\u003E可到官网安装，版本看个人喜欢，麒麟版本自带中文以及拼音输入法等。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ca target='_blank'  href=\"http:\u002F\u002Fcn.ubuntu.com\u002Fdownload\u002F\"\u003EDownload\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E下载好之后用软碟通写入U盘映像。无论双系统与否都必须关闭secure Boot。\n解释算好也基本上上每个懂折腾Linux的都会看过这一篇文章\n\u003Ca target='_blank'  href=\"http:\u002F\u002Fwww.ruanyifeng.com\u002Fblog\u002F2013\u002F01\u002Fsecure_boot.html\"\u003E反Secure Boot垄断：兼谈如何在Windows 8电脑上安装Linux\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E自行划分硬盘空间。\n硬盘划好，电脑开机选快捷启动就进入安装，分区的时候主要有几个分区点（以下只是在双系统下分配硬盘空间较小的建议，实际看个人需要）:\u003C\u002Fp\u003E\n\u003Cp\u003E\u002F：存储系统文件，建议15G;\u003C\u002Fp\u003E\n\u003Cp\u003Eswap：交换分区，即Linux系统的虚拟内存，建议是物理内存的1～2倍；\u003C\u002Fp\u003E\n\u003Cp\u003E\u002Fhome：home目录，存放音乐、图片及下载等文件的空间，建议最后分配所有剩下的空间；\u003C\u002Fp\u003E\n\u003Cp\u003E\u002Fboot：包含系统内核和系统启动所需的文件，实现双系统的关键所在，建议200M。\u003C\u002Fp\u003E\n\u003Cp\u003E均可选择为逻辑分区。\n一路下来就可以开机了。\n由于没有记录图片所以不再多说。\u003C\u002Fp\u003E\n\u003Ch3 id=\"安装gnome\"\u003E安装gnome\u003C\u002Fh3\u003E\n\u003Cp\u003E安装完Ubuntu如果足够开发就不需要Gnome，自带的是Untiy，Gnome只是美化和方便。因为有大量的扩展可以使用。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-bullet\"\u003E1.\u003C\u002Fspan\u003E Ctrl+Alt+T 打开终端\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E. $ sudo apt-\u003Cspan class=\"hljs-keyword\"\u003Eget\u003C\u002Fspan\u003E install gnome-\u003Cspan class=\"hljs-keyword\"\u003Eshell\u003C\u002Fspan\u003E  \u002F\u002F安装gnome-\u003Cspan class=\"hljs-keyword\"\u003Eshell\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-number\"\u003E3.\u003C\u002Fspan\u003E $ sudo apt-\u003Cspan class=\"hljs-keyword\"\u003Eget\u003C\u002Fspan\u003E install ubuntu-gnome-desktop  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F安装gnome-desktop\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-number\"\u003E4.\u003C\u002Fspan\u003E $ sudo apt-\u003Cspan class=\"hljs-keyword\"\u003Eget\u003C\u002Fspan\u003E install unity-tweak-tool  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F安装 unity-tweak-tool\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-number\"\u003E5.\u003C\u002Fspan\u003E $ sudo apt-\u003Cspan class=\"hljs-keyword\"\u003Eget\u003C\u002Fspan\u003E install gnome-tweak-tool   \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F安装gnome-tweak-tool\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"重启请选择-gnome经典桌面\"\u003E重启请选择 Gnome经典桌面\u003C\u002Fh3\u003E\n\u003Cp\u003E输密码那有个齿轮的，不选择的话会有坑。一开始自己默认进入的是Ubuntu桌面，只能应用主题图标，扩展都没办法应用。\ngnome拓展到\u003Ca target='_blank'  href=\"https:\u002F\u002Fextensions.gnome.org\u002F\"\u003Egnome拓展中心\u003C\u002Fa\u003E下载安装。\n如果没有安装浏览器插件，火狐和chrome的应用或者说插件中心搜索gnome shell extensoins 安装就可以。\u003C\u002Fp\u003E\n\u003Ch3 id=\"扩展推荐和注意\"\u003E扩展推荐和注意\u003C\u002Fh3\u003E\n\u003Cp\u003E推荐(必装)： \u003Ca target='_blank'  href=\"https:\u002F\u002Fextensions.gnome.org\u002Fextension\u002F307\u002Fdash-to-dock\u002F\"\u003EDash to Dock\u003C\u002Fa\u003E、\u003Ca target='_blank'  href=\"https:\u002F\u002Fextensions.gnome.org\u002Fextension\u002F545\u002Fhide-top-bar\u002F\"\u003EHide Top Bar自动隐藏顶栏\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E底栏去除：\u003C\u002Fp\u003E\n\u003Cp\u003E到目录\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-regexp\"\u003E\u002Fusr\u002F\u003C\u002Fspan\u003Eshare\u003Cspan class=\"hljs-regexp\"\u003E\u002Fgnome-shell\u002F\u003C\u002Fspan\u003Eextensions\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"},{title:A,slug:"2017_11_ubuntu-shadowsocks",description:A,keywords:"ubuntu,shadowsocks",labels:[b],date:z,path:"2017\u002F11\u002Fubuntu-shadowsocks.md",html:"\u003Ch3 id=\"提示：\"\u003E提示：\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003E测试环境：Ubuntu 16.04 (gnome桌面环境)\u003C\u002Fli\u003E\n\u003Cli\u003E需要ss出国，就需要有ss账号。有很多的出售账号的地方。当然也可以自己搭建个人ss服务器，这里就不再赘述。\u003C\u002Fli\u003E\n\u003Cli\u003E需要下载软件Shadowsocks-Qt5,具体下面会列出。\u003C\u002Fli\u003E\n\u003Cli\u003E提供SwitchyOmega配置文件，不需要自己配置。\u003C\u002Fli\u003E\n\u003Cli\u003E每次开机需要手动连接Qt5，除非设置自动连接。\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002FGzhiYi\u002Ffrontend-log\u002Freleases\u002Ftag\u002Fss\"\u003E文件\u003C\u002Fa\u003E\u003Ch2 id=\"步骤steps\"\u003E步骤(Steps):\u003C\u002Fh2\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cul\u003E\n\u003Cli\u003E下载Shadowsocks-Qt5：  \u003Cpre\u003E\u003Ccode\u003Esudo\u003Cspan class=\"hljs-built_in\"\u003E add-apt-repository \u003C\u002Fspan\u003Eppa:hzwhuang\u002Fss-qt5\nsudo apt-get update\nsudo apt-get install shadowsocks-qt5\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E打开Qt5，右键空白选择添加。对应填上自己的ss账号信息。\u003Cbr\u003E有多种添加账号的方式，哪种合适用哪种。账号信息填好就点击新建的账号连接。如果ip能连通一般有延迟显示。\u003C\u002Fli\u003E\n\u003Cli\u003E下载SwitchyOmega\u003Cbr\u003E可以提供gfw过滤等，在chrome下使用体验很不错。\u003Cbr\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fchrome.google.com\u002Fwebstore\u002Fdetail\u002Fproxy-switchyomega\u002Fpadekgcemlokbadohgkifijomclgjgif?utm_source=chrome-ntp-icon\"\u003Echrome上车\u003C\u002Fa\u003E\u003Cbr\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Faddons.mozilla.org\u002Fzh-CN\u002Ffirefox\u002Faddon\u002Fswitchyomega\u002F\"\u003EfireFox上车\u003C\u002Fa\u003E\u003Cbr\u003E文件在提示第六条有release下载。\u003C\u002Fli\u003E\n\u003Cli\u003E配置SwitchyOmega\u003Cbr\u003E点击选项--导入\u002F导出--从备份文件恢复。选择文件  \u003Cpre\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-module-access\"\u003E\u003Cspan class=\"hljs-module\"\u003E\u003Cspan class=\"hljs-identifier\"\u003EOmegaOptionsChrome\u003C\u002Fspan\u003E.\u003C\u002Fspan\u003E\u003C\u002Fspan\u003Ebak\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E开启switchyOmega\u003Cbr\u003E选择switchyOmega的自动切换\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"开机自启方法\"\u003E开机自启方法\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E选择Qt5添加的项目右键--编辑，勾选程序启动时自动连接\u003C\u002Fli\u003E\n\u003Cli\u003EQt5  设置--常规设置--登录时启动\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"}]}}("前端","工具","小程序","随笔","2018-10-15","vue","lodash","docker","npm","学习","vue源码","css揭秘的小笔记","用docker构建vue项目镜像，与buildkit体积对比","2021-07-29","2021-07-19","用firebase给静态博客页面增加点赞功能","日环食","Http缓存","项目突然跑不起来","2019-03-08","新的一年，加油","chrome出现Caution provisional headers are shown的问题","ES6 Module语法小结","不知不觉一个月了","每次重装Linux Mint减少90%时间","2017-11-09","如何在ubuntu下使用shadowsocks"))]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.e0961b94.js"}catch(e){main="/client/legacy/client.c8e72cd1.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 