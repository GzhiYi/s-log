<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=client/client-87ec37cb.css rel=stylesheet><link href=client/[slug]-2cfb82a0.css rel=stylesheet> <title>理解一下vue的render方法-GzhiYi's blog</title><meta content=vue的render方法 name=description data-svelte=svelte-2vncnt><meta content=前端开发者，web，vue，React，svelte，小程序，JavaScript，CSS，blog name=keywords data-svelte=svelte-2vncnt> <link href=/client/client.e0961b94.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-87ec37cb.css rel=preload as=style><link href=/client/[slug].13458e28.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/config.026ad977.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/[slug]-2cfb82a0.css rel=preload as=style></head> <body> <div id=sapper> <nav class=svelte-1vrbr95><ul class=svelte-1vrbr95><li class=svelte-1vrbr95><a href=blog aria-current=page class=svelte-1vrbr95 rel=prefetch>文章列表</a></ul></nav> <div style=width:100%;height:56px;background-color:#dee2e8></div> <main class=svelte-1ca6gui style=padding:1rem> <div class="svelte-vusc9 base"><div class="svelte-vusc9 title">理解一下vue的render方法</div> <span class="svelte-vusc9 author">GzhiYi · 2021-08-19</span> <div class=label>vue源码</div></div> <div class="svelte-vusc9 content"><p><div style=text-align:center><img align=center alt=属性未定义的错误提示 data-zoomable src=https://i.loli.net/2021/08/19/w6YcFmd1eJOA5oC.png style=width:-webkit-fill-available;margin-bottom:20px;border-radius:8px;background:#f8fdf3></div> <p></p> <p>上面提示会出现在我们没有在vue中定义该data却在模板中提到的时候。恰好是在render执行过程中出现的，所以可以借此理解一下vue的render函数。</p> <h3 id=render>render</h3> <p>render函数是vue实例中的一个私有方法，作用是通过<code>createElement</code>创建并返回虚拟dom(vnode)。翻看源码，该方法定义在<a href=https://github.com/vuejs/vue/blob/dev/src/core/instance/render.js target=_blank>src/core/instance/render.js</a>中。</p> <p>位于<code>initRender</code>函数。在这函数里面找到_render的定义：</p> <pre><code class=language-js>Vue.prototype._render = <span class=hljs-keyword>function</span> (){
  <span class=hljs-regexp>//</span> ...
  <span class=hljs-regexp>//</span> 从options中拿到render函数
  const { render } = vm.<span class=hljs-variable>$options</span>

  <span class=hljs-regexp>//</span> 通过call函数传入当前上下文
  vnode = render.call(vm._renderProxy, vm.<span class=hljs-variable>$createElement</span>)
  <span class=hljs-regexp>//</span> ...
}
</code></pre> <h3 id=createelement>createElement</h3> <p>vm中的createElement在该函数上方有定义。</p> <pre><code class=language-js>vm._c =<span class=hljs-function> (<span class=hljs-params>a</span>, <span class=hljs-params>b</span>, <span class=hljs-params>c</span>, <span class=hljs-params>d</span>) =></span> create<span class=hljs-constructor>Element(<span class=hljs-params>vm</span>, <span class=hljs-params>a</span>, <span class=hljs-params>b</span>, <span class=hljs-params>c</span>, <span class=hljs-params>d</span>, <span class=hljs-params>false</span>)</span>
vm.$createElement =<span class=hljs-function> (<span class=hljs-params>a</span>, <span class=hljs-params>b</span>, <span class=hljs-params>c</span>, <span class=hljs-params>d</span>) =></span> create<span class=hljs-constructor>Element(<span class=hljs-params>vm</span>, <span class=hljs-params>a</span>, <span class=hljs-params>b</span>, <span class=hljs-params>c</span>, <span class=hljs-params>d</span>, <span class=hljs-params>true</span>)</span>
</code></pre> <p>可以知道，第一个私有函数_c挂在vm上是提供给编译器编译模版生成render函数。</p> <p>第二个直接定义在实例上，提供用于手写render方法。</p> <p>我们在vue中render函数是这么写的：</p> <pre><code class=language-js><span class=hljs-keyword>new</span> Vue({
  <span class=hljs-function><span class=hljs-title>render</span>(<span class=hljs-params>createElement</span>)</span> {
    <span class=hljs-comment>// do sth</span>
    <span class=hljs-keyword>return</span> createElement(
      <span class=hljs-comment>// vnode stuff</span>
    )
  }
})
</code></pre> <p>这里的createElement就是在上方代码中定义的。 </p> <p><strong>vnode的生成会替换render目标元素dom，所以不能把vue实例render到有内容的dom上。</strong></p> <h3 id=renderproxy>renderProxy</h3> <p>render.call函数的第一个参数是<code>vm._renderProxy</code>，在<code>init.js</code>中，有这两行代码在初始化周期等前执行：</p> <pre><code class=language-js><span class=hljs-keyword>if</span> (undefined !== <span class=hljs-string>'production'</span>) {
  initProxy(<span class=hljs-keyword>vm</span>)
} <span class=hljs-keyword>else</span> {
  <span class=hljs-keyword>vm</span>._renderProxy = <span class=hljs-keyword>vm</span>
}
</code></pre> <p>表示如果当前是开发环境，就执行initProxy，来看看initProxy的代码。initProxy位于<code>src/core/instance/proxy.js</code>中。</p> <pre><code class=language-js>initProxy = <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>initProxy</span> <span class=hljs-params>(vm)</span> {</span>
  // hasProxy是用于判断当前环境是否支持proxy/
  // 支持的浏览器将直接调用<span class=hljs-keyword>new</span> Proxy进行数据劫持
  <span class=hljs-keyword>if</span> (hasProxy) {
    // determine which proxy handler <span class=hljs-keyword>to</span> use
    const <span class=hljs-keyword>options</span> = <span class=hljs-keyword>vm</span>.$<span class=hljs-keyword>options</span>
    const handlers = <span class=hljs-keyword>options</span>.render && <span class=hljs-keyword>options</span>.render._withStripped
      ? getHandler
      : hasHandler
    <span class=hljs-keyword>vm</span>._renderProxy = <span class=hljs-keyword>new</span> Proxy(<span class=hljs-keyword>vm</span>, handlers)
  } <span class=hljs-keyword>else</span> {
    <span class=hljs-keyword>vm</span>._renderProxy = <span class=hljs-keyword>vm</span>
  }
}
</code></pre> <p>如果在支持的浏览器中，<code>new Proxy</code>的第二个参数会传入<code>hasHandler</code>，查看hasHandler定义:</p> <pre><code class=language-js><span class=hljs-keyword>const</span> hasHandler = {
  has (target, <span class=hljs-built_in>key</span>) {
    <span class=hljs-keyword>const</span> has = <span class=hljs-built_in>key</span> in target
    <span class=hljs-keyword>const</span> isAllowed = allowedGlobals(<span class=hljs-built_in>key</span>) ||
      (typeof <span class=hljs-built_in>key</span> === <span class=hljs-string>'string'</span> && <span class=hljs-built_in>key</span>.charAt(<span class=hljs-number>0</span>) === <span class=hljs-string>'_'</span> && !(<span class=hljs-built_in>key</span> in target.$data))
    <span class=hljs-keyword>if</span> (!has && !isAllowed) {
      <span class=hljs-keyword>if</span> (<span class=hljs-built_in>key</span> in target.$data) warnReservedPrefix(target, <span class=hljs-built_in>key</span>)
      <span class=hljs-keyword>else</span> warnNonPresent(target, <span class=hljs-built_in>key</span>)
    }
    <span class=hljs-keyword>return</span> has || !isAllowed
  }
}
</code></pre> <p><a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy target=_blank>Proxy</a>，在这里就是对vm的data进行数据劫持，也就是代理。</p> <p>handler又一个has方法，这是针对 in 操作符的代理方法，has内部主要检查target中是否有key属性，如果有就继续执行，如果没有，就回到文章开头的那个错误提示啦。</p> <h3 id=总结>总结</h3> <p>在<code>init.js</code>中定义了<code>initRender</code>以及<code>_renderProxy</code>方法。在<code>render.js</code>找到render函数定义，主要描述了对用户手写的render函数进行处理生成vnode，中间将vnode设置到vm实例中(vm.$vnode)，最后返回并执行后续的操作。</p> <p><strong>Vue版本：<a href=https://github.com/vuejs/vue/archive/refs/tags/v2.6.14.zip target=_blank>2.6.14</a></strong></p> </div> <div class="svelte-vusc9 contact"><div style=line-height:20px>如果你对这页内容有疑问，欢迎联系我！</div> <a href="mailto:zhiyi.gong@outlook.com?subject=【重要】理解一下vue的render方法&body=gzhiyi.top/blog/2021_08_vue-render-source" target=_blank>邮箱 </a> <br> <a href=https://github.com/gzhiyi target=_blank>github </a> </div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"理解一下vue的render方法",description:"vue的render方法",keywords:null,labels:["vue源码"],date:"2021-08-19",path:"2021\u002F08\u002Fvue-render-source.md",slug:"2021_08_vue-render-source",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2021\u002F08\u002F19\u002Fw6YcFmd1eJOA5oC.png\" alt=\"属性未定义的错误提示\" \u003E\u003C\u002Fdiv\u003E \u003C\u002Fp\u003E\n\u003Cp\u003E上面提示会出现在我们没有在vue中定义该data却在模板中提到的时候。恰好是在render执行过程中出现的，所以可以借此理解一下vue的render函数。\u003C\u002Fp\u003E\n\u003Ch3 id=\"render\"\u003Erender\u003C\u002Fh3\u003E\n\u003Cp\u003Erender函数是vue实例中的一个私有方法，作用是通过\u003Ccode\u003EcreateElement\u003C\u002Fcode\u003E创建并返回虚拟dom(vnode)。翻看源码，该方法定义在\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fvuejs\u002Fvue\u002Fblob\u002Fdev\u002Fsrc\u002Fcore\u002Finstance\u002Frender.js\"\u003Esrc\u002Fcore\u002Finstance\u002Frender.js\u003C\u002Fa\u003E中。\u003C\u002Fp\u003E\n\u003Cp\u003E位于\u003Ccode\u003EinitRender\u003C\u002Fcode\u003E函数。在这函数里面找到_render的定义：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003EVue.prototype._render = \u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (){\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E ...\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 从options中拿到render函数\n  const { render } = vm.\u003Cspan class=\"hljs-variable\"\u003E$options\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 通过call函数传入当前上下文\n  vnode = render.call(vm._renderProxy, vm.\u003Cspan class=\"hljs-variable\"\u003E$createElement\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E ...\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"createelement\"\u003EcreateElement\u003C\u002Fh3\u003E\n\u003Cp\u003Evm中的createElement在该函数上方有定义。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003Evm._c =\u003Cspan class=\"hljs-function\"\u003E (\u003Cspan class=\"hljs-params\"\u003Ea\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Eb\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ec\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ed\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E create\u003Cspan class=\"hljs-constructor\"\u003EElement(\u003Cspan class=\"hljs-params\"\u003Evm\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ea\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Eb\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ec\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ed\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Efalse\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\nvm.$createElement =\u003Cspan class=\"hljs-function\"\u003E (\u003Cspan class=\"hljs-params\"\u003Ea\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Eb\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ec\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ed\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E create\u003Cspan class=\"hljs-constructor\"\u003EElement(\u003Cspan class=\"hljs-params\"\u003Evm\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ea\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Eb\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ec\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Ed\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Etrue\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E可以知道，第一个私有函数_c挂在vm上是提供给编译器编译模版生成render函数。\u003C\u002Fp\u003E\n\u003Cp\u003E第二个直接定义在实例上，提供用于手写render方法。\u003C\u002Fp\u003E\n\u003Cp\u003E我们在vue中render函数是这么写的：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Vue({\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003Erender\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003EcreateElement\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F do sth\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E createElement(\n      \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F vnode stuff\u003C\u002Fspan\u003E\n    )\n  }\n})\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里的createElement就是在上方代码中定义的。  \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003Evnode的生成会替换render目标元素dom，所以不能把vue实例render到有内容的dom上。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"renderproxy\"\u003ErenderProxy\u003C\u002Fh3\u003E\n\u003Cp\u003Erender.call函数的第一个参数是\u003Ccode\u003Evm._renderProxy\u003C\u002Fcode\u003E，在\u003Ccode\u003Einit.js\u003C\u002Fcode\u003E中，有这两行代码在初始化周期等前执行：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (undefined !== \u003Cspan class=\"hljs-string\"\u003E&#x27;production&#x27;\u003C\u002Fspan\u003E) {\n  initProxy(\u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E)\n} \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E._renderProxy = \u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E表示如果当前是开发环境，就执行initProxy，来看看initProxy的代码。initProxy位于\u003Ccode\u003Esrc\u002Fcore\u002Finstance\u002Fproxy.js\u003C\u002Fcode\u003E中。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003EinitProxy = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EinitProxy\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(vm)\u003C\u002Fspan\u003E {\u003C\u002Fspan\u003E\n  \u002F\u002F hasProxy是用于判断当前环境是否支持proxy\u002F\n  \u002F\u002F 支持的浏览器将直接调用\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Proxy进行数据劫持\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (hasProxy) {\n    \u002F\u002F determine which proxy handler \u003Cspan class=\"hljs-keyword\"\u003Eto\u003C\u002Fspan\u003E use\n    const \u003Cspan class=\"hljs-keyword\"\u003Eoptions\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E.$\u003Cspan class=\"hljs-keyword\"\u003Eoptions\u003C\u002Fspan\u003E\n    const handlers = \u003Cspan class=\"hljs-keyword\"\u003Eoptions\u003C\u002Fspan\u003E.render &amp;&amp; \u003Cspan class=\"hljs-keyword\"\u003Eoptions\u003C\u002Fspan\u003E.render._withStripped\n      ? getHandler\n      : hasHandler\n    \u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E._renderProxy = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Proxy(\u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E, handlers)\n  } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E._renderProxy = \u003Cspan class=\"hljs-keyword\"\u003Evm\u003C\u002Fspan\u003E\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E如果在支持的浏览器中，\u003Ccode\u003Enew Proxy\u003C\u002Fcode\u003E的第二个参数会传入\u003Ccode\u003EhasHandler\u003C\u002Fcode\u003E，查看hasHandler定义:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E hasHandler = {\n  has (target, \u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E) {\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E has = \u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E in target\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E isAllowed = allowedGlobals(\u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E) ||\n      (typeof \u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E === \u003Cspan class=\"hljs-string\"\u003E&#x27;string&#x27;\u003C\u002Fspan\u003E &amp;&amp; \u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E.charAt(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E) === \u003Cspan class=\"hljs-string\"\u003E&#x27;_&#x27;\u003C\u002Fspan\u003E &amp;&amp; !(\u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E in target.$data))\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!has &amp;&amp; !isAllowed) {\n      \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E in target.$data) warnReservedPrefix(target, \u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E)\n      \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E warnNonPresent(target, \u003Cspan class=\"hljs-built_in\"\u003Ekey\u003C\u002Fspan\u003E)\n    }\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E has || !isAllowed\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fzh-CN\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FProxy\"\u003EProxy\u003C\u002Fa\u003E，在这里就是对vm的data进行数据劫持，也就是代理。\u003C\u002Fp\u003E\n\u003Cp\u003Ehandler又一个has方法，这是针对 in 操作符的代理方法，has内部主要检查target中是否有key属性，如果有就继续执行，如果没有，就回到文章开头的那个错误提示啦。\u003C\u002Fp\u003E\n\u003Ch3 id=\"总结\"\u003E总结\u003C\u002Fh3\u003E\n\u003Cp\u003E在\u003Ccode\u003Einit.js\u003C\u002Fcode\u003E中定义了\u003Ccode\u003EinitRender\u003C\u002Fcode\u003E以及\u003Ccode\u003E_renderProxy\u003C\u002Fcode\u003E方法。在\u003Ccode\u003Erender.js\u003C\u002Fcode\u003E找到render函数定义，主要描述了对用户手写的render函数进行处理生成vnode，中间将vnode设置到vm实例中(vm.$vnode)，最后返回并执行后续的操作。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EVue版本：\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fvuejs\u002Fvue\u002Farchive\u002Frefs\u002Ftags\u002Fv2.6.14.zip\"\u003E2.6.14\u003C\u002Fa\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.e0961b94.js"}catch(e){main="/client/legacy/client.c8e72cd1.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 