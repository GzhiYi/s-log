<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=client/client-87ec37cb.css rel=stylesheet><link href=client/[slug]-2cfb82a0.css rel=stylesheet> <title>观后笔记-你不知道的JavasSript-上-01-GzhiYi's blog</title><meta content=你不知道的Javascri上册的一些内容记录，仅仅是记录自己所不是很明确但确实是有启发的内容点 name=description data-svelte=svelte-2vncnt><meta content="你不知道的Javscript，you don't know javascript，笔记，记录，读书感" name=keywords data-svelte=svelte-2vncnt> <link href=/client/client.e0961b94.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-87ec37cb.css rel=preload as=style><link href=/client/[slug].13458e28.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/config.026ad977.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/[slug]-2cfb82a0.css rel=preload as=style></head> <body> <div id=sapper> <nav class=svelte-1vrbr95><ul class=svelte-1vrbr95><li class=svelte-1vrbr95><a href=blog aria-current=page class=svelte-1vrbr95 rel=prefetch>文章列表</a></ul></nav> <div style=width:100%;height:56px;background-color:#dee2e8></div> <main class=svelte-1ca6gui style=padding:1rem> <div class="svelte-vusc9 base"><div class="svelte-vusc9 title">观后笔记-你不知道的JavasSript-上-01</div> <span class="svelte-vusc9 author">GzhiYi · 2021-09-16</span> <div class=label>前端</div></div> <div class="svelte-vusc9 content"><p>记录一些读书的小点，这些是在自己翻阅书本后觉得可能对自己有帮助的情况下所写下来的内容，并不适用于任何人理解和肯定。</p> <h3 id=自执行函数iife>自执行函数IIFE</h3> <pre><code class=language-js>(<span class=hljs-name>function</span> funName() {})()
</code></pre> <p>具备将变量包裹起来的能力。另外可以当作函数调用并传递参数进去。</p> <pre><code class=language-js><span class=hljs-keyword>const</span> name = <span class=hljs-string>'GzhiYi'</span>
(<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>IIFE</span>(<span class=hljs-params><span class=hljs-built_in>global</span></span>) </span>{
  <span class=hljs-keyword>const</span> name = <span class=hljs-string>'Not Me'</span>
  <span class=hljs-built_in>console</span>.log(name) <span class=hljs-comment>// Not me</span>
  <span class=hljs-built_in>console</span>.log(<span class=hljs-built_in>global</span>.name) <span class=hljs-comment>// GzhiYi</span>
})
<span class=hljs-built_in>console</span>.log(name) <span class=hljs-comment>// GzhiYi</span>
</code></pre> <h3 id=with和trycatch都可以创建一个块作用域>with和try/catch都可以创建一个块作用域</h3> <p>用with关键词从对象中跟创建出的作用域仅在with声明中而非外部作用域中有效。</p> <p>try/catch中的<code>catch</code>分句会创建一个块作用域，其中所声明的变量仅在catch内部有效。</p> <pre><code class=language-js><span class=hljs-keyword>try</span> {
  <span class=hljs-comment>// trigger error!</span>
} <span class=hljs-keyword>catch</span>(<span class=hljs-built_in>error</span>) {
  console.<span class=hljs-built_in>log</span>(<span class=hljs-built_in>error</span>) <span class=hljs-comment>// error info</span>
}
console.<span class=hljs-built_in>log</span>(<span class=hljs-built_in>error</span>) <span class=hljs-comment>// ReferenceError: err not found</span>
</code></pre> <h3 id=没定义的变量rhs查询一定错误吗？>没定义的变量RHS查询一定错误吗？</h3> <p>例子：</p> <pre><code class=language-js><span class=hljs-regexp>//</span> <span class=hljs-number>1</span>
a = <span class=hljs-number>2</span>;
var a;
console.log(a) <span class=hljs-regexp>//</span> <span class=hljs-number>2</span>

<span class=hljs-regexp>//</span> <span class=hljs-number>2</span>
console.log(b)
var b = <span class=hljs-number>2</span>
<span class=hljs-regexp>//</span> 你可能认为会输出<span class=hljs-number>2</span>或者ReferenceError，实际上输出undefined
</code></pre> <p><strong>包括变量和函数在内的所有生命都会在任何代码被执行前被处理。</strong></p> <p>需要理解的是，<code>var b = 2</code>实际上是两个声明：</p> <pre><code class=language-js>var b<span class=hljs-comment>;</span>
<span class=hljs-attribute>b</span> = <span class=hljs-number>2</span><span class=hljs-comment>;</span>
</code></pre> <p>所以，上面的两个代码片段会有以下处理：</p> <pre><code class=language-js><span class=hljs-regexp>//</span> <span class=hljs-number>1</span>
var a; <span class=hljs-regexp>//</span> 声明
a = <span class=hljs-number>2</span>; <span class=hljs-regexp>//</span> 代码执行
console.log(a) <span class=hljs-regexp>//</span> 代码执行

<span class=hljs-regexp>//</span> <span class=hljs-number>2</span>
var b; <span class=hljs-regexp>//</span> 声明
console.log(b) <span class=hljs-regexp>//</span> 代码执行
b = <span class=hljs-number>2</span> <span class=hljs-regexp>//</span> 代码执行
</code></pre> <p>解释的前提是必须要知道，声明都是需要在代码被执行前先被处理，这个过程就是<code>变量提升</code>。</p> <p>每一个作用域都被进行提升操作。</p> <pre><code class=language-js>console<span class=hljs-selector-class>.log</span>(foo) <span class=hljs-comment>// 报错误！！</span>
<span class=hljs-function><span class=hljs-title>foo</span><span class=hljs-params>()</span></span>
<span class=hljs-selector-tag>var</span> foo = function bar() {}
</code></pre> <p>以上片段报错不是ReferenceError，而是TypeError：</p> <ol> <li><p><code>Uncaught TypeError: foo is not a function</code> 类型错误，执行了不属于该类型的操作。</p> </li> <li><p>如果log的是bar，则<code>Uncaught ReferenceError: bar is not defined</code> 引用错误，在当前作用域中找不到该变量。</p> </li> </ol> <p>相当于被处理为：</p> <pre><code class=language-js><span class=hljs-keyword>var</span> foo;
foo()
foo = funciton (){
  <span class=hljs-keyword>var</span> bar = **<span class=hljs-literal>self</span>**
}
</code></pre> </div> <div class="svelte-vusc9 contact"><div style=line-height:20px>如果你对这页内容有疑问，欢迎联系我！</div> <a href="mailto:zhiyi.gong@outlook.com?subject=【重要】观后笔记-你不知道的JavasSript-上-01&body=gzhiyi.top/blog/2021_09_you_dont_know_js_1_01" target=_blank>邮箱 </a> <br> <a href=https://github.com/gzhiyi target=_blank>github </a> </div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"观后笔记-你不知道的JavasSript-上-01",description:"你不知道的Javascri上册的一些内容记录，仅仅是记录自己所不是很明确但确实是有启发的内容点",keywords:"你不知道的Javscript，you don't know javascript，笔记，记录，读书感",labels:["前端"],date:"2021-09-16",path:"2021\u002F09\u002Fyou_dont_know_js_1_01.md",slug:"2021_09_you_dont_know_js_1_01",html:"\u003Cp\u003E记录一些读书的小点，这些是在自己翻阅书本后觉得可能对自己有帮助的情况下所写下来的内容，并不适用于任何人理解和肯定。\u003C\u002Fp\u003E\n\u003Ch3 id=\"自执行函数iife\"\u003E自执行函数IIFE\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E(\u003Cspan class=\"hljs-name\"\u003Efunction\u003C\u002Fspan\u003E funName() {})()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E具备将变量包裹起来的能力。另外可以当作函数调用并传递参数进去。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E name = \u003Cspan class=\"hljs-string\"\u003E&#x27;GzhiYi&#x27;\u003C\u002Fspan\u003E\n(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EIIFE\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003Cspan class=\"hljs-built_in\"\u003Eglobal\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E name = \u003Cspan class=\"hljs-string\"\u003E&#x27;Not Me&#x27;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(name) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Not me\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\u003Cspan class=\"hljs-built_in\"\u003Eglobal\u003C\u002Fspan\u003E.name) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F GzhiYi\u003C\u002Fspan\u003E\n})\n\u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(name) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F GzhiYi\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"with和trycatch都可以创建一个块作用域\"\u003Ewith和try\u002Fcatch都可以创建一个块作用域\u003C\u002Fh3\u003E\n\u003Cp\u003E用with关键词从对象中跟创建出的作用域仅在with声明中而非外部作用域中有效。\u003C\u002Fp\u003E\n\u003Cp\u003Etry\u002Fcatch中的\u003Ccode\u003Ecatch\u003C\u002Fcode\u003E分句会创建一个块作用域，其中所声明的变量仅在catch内部有效。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Etry\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F trigger error!\u003C\u002Fspan\u003E\n} \u003Cspan class=\"hljs-keyword\"\u003Ecatch\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-built_in\"\u003Eerror\u003C\u002Fspan\u003E) {\n  console.\u003Cspan class=\"hljs-built_in\"\u003Elog\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-built_in\"\u003Eerror\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F error info\u003C\u002Fspan\u003E\n}\nconsole.\u003Cspan class=\"hljs-built_in\"\u003Elog\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-built_in\"\u003Eerror\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ReferenceError: err not found\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"没定义的变量rhs查询一定错误吗？\"\u003E没定义的变量RHS查询一定错误吗？\u003C\u002Fh3\u003E\n\u003Cp\u003E例子：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\na = \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E;\nvar a;\nconsole.log(a) \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E\nconsole.log(b)\nvar b = \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 你可能认为会输出\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E或者ReferenceError，实际上输出undefined\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E包括变量和函数在内的所有生命都会在任何代码被执行前被处理。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E需要理解的是，\u003Ccode\u003Evar b = 2\u003C\u002Fcode\u003E实际上是两个声明：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003Evar b\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-attribute\"\u003Eb\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-comment\"\u003E;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E所以，上面的两个代码片段会有以下处理：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\nvar a; \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 声明\na = \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E; \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 代码执行\nconsole.log(a) \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 代码执行\n\n\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E\nvar b; \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 声明\nconsole.log(b) \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 代码执行\nb = \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 代码执行\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E解释的前提是必须要知道，声明都是需要在代码被执行前先被处理，这个过程就是\u003Ccode\u003E变量提升\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E每一个作用域都被进行提升操作。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003Econsole\u003Cspan class=\"hljs-selector-class\"\u003E.log\u003C\u002Fspan\u003E(foo) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 报错误！！\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003Efoo\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-selector-tag\"\u003Evar\u003C\u002Fspan\u003E foo = function bar() {}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E以上片段报错不是ReferenceError，而是TypeError：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EUncaught TypeError: foo is not a function\u003C\u002Fcode\u003E\n类型错误，执行了不属于该类型的操作。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E如果log的是bar，则\u003Ccode\u003EUncaught ReferenceError: bar is not defined\u003C\u002Fcode\u003E\n引用错误，在当前作用域中找不到该变量。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E相当于被处理为：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E foo;\nfoo()\nfoo = funciton (){\n  \u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E bar = **\u003Cspan class=\"hljs-literal\"\u003Eself\u003C\u002Fspan\u003E**\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.e0961b94.js"}catch(e){main="/client/legacy/client.c8e72cd1.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 