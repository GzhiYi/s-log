{"title":"Docker的一些需记基础命令和用法","description":"docker的基础命令快速查询，方便记忆和翻阅使用。","keywords":"docker，基础命令，基本使用，容器，镜像","labels":["docker"],"date":"2021-07-29","path":"2021/07/docker-command.md","slug":"2021_07_docker-command","html":"<p>由于docker目前在项目中用的比较少，慢慢在写项目的过程中，有一些命令会被我遗忘掉。所以我把一些基础常用的docker命令列下来，方便自己在回顾docker或者重新使用的时候快速运用上。在后续的时间里，也会尽可能的将docker应用到能用上的项目中。</p>\n<h2 id=\"安装\">安装</h2>\n<p>我用linux比较多，所以只记录在linux下的安装步骤。</p>\n<ol>\n<li>如果有旧版本的docker，需要先卸载旧版本。旧版本为docker或者docker-engine。</li>\n</ol>\n<pre><code class=\"language-bash\">sudo apt-<span class=\"hljs-builtin-name\">get</span> <span class=\"hljs-builtin-name\">remove</span> docker docker-engine docker.io\n</code></pre>\n<ol start=\"2\">\n<li>用脚本安装。</li>\n</ol>\n<pre><code class=\"language-bash\"><span class=\"hljs-string\">curl</span> -<span class=\"hljs-string\">fsSL</span> <span class=\"hljs-string\">get</span>.<span class=\"hljs-string\">docker</span>.<span class=\"hljs-string\">com</span> -<span class=\"hljs-string\">o</span> <span class=\"hljs-built_in\">get-docker.sh</span>\n<span class=\"hljs-string\">sudo</span> <span class=\"hljs-string\">sh</span> <span class=\"hljs-built_in\">get-docker.sh</span> <span class=\"hljs-built_in\">--mirror</span> <span class=\"hljs-string\">Aliyun</span>\n</code></pre>\n<ol start=\"3\">\n<li>启动docker</li>\n</ol>\n<pre><code class=\"language-bash\">sudo systemctl <span class=\"hljs-keyword\">enable</span> docker\nsudo systemctl <span class=\"hljs-keyword\">start</span> docker\n</code></pre>\n<ol start=\"4\">\n<li>建立docker用户组</li>\n</ol>\n<pre><code class=\"language-bash\">sudo groupadd docker\nsudo usermod -aG docker $USER\n</code></pre>\n<ol start=\"5\">\n<li>测试是否安装好</li>\n</ol>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-built_in\">run</span> <span class=\"hljs-comment\">--rm hello-world</span>\n</code></pre>\n<h2 id=\"常用命令\">常用命令</h2>\n<p>注意-t之类的命令是用于修饰动作的，比如<code>run -t-d</code></p>\n<h3 id=\"镜像使用\">镜像使用</h3>\n<ul>\n<li>拉取</li>\n</ul>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">docker</span> pull ubuntu:<span class=\"hljs-number\">18</span>.<span class=\"hljs-number\">04</span> # 拉取ubuntu镜像，对应版本（tag）为<span class=\"hljs-number\">18</span>.<span class=\"hljs-number\">04</span>\n</code></pre>\n<ul>\n<li>运行（这个镜像为基础启动并运行一个容器）</li>\n</ul>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-built_in\">run</span> -<span class=\"hljs-keyword\">it</span> ubuntu:<span class=\"hljs-number\">18.04</span> bash <span class=\"hljs-comment\"># -ℹ交互式操作，-t终端</span>\n</code></pre>\n<ul>\n<li>列出</li>\n</ul>\n<pre><code class=\"language-bash\">docker image <span class=\"hljs-keyword\">ls</span> <span class=\"hljs-comment\"># ls后跟具名可以过滤该名的镜像； -a列出所有镜像</span>\n</code></pre>\n<ul>\n<li>删除</li>\n</ul>\n<pre><code class=\"language-bash\">docker image <span class=\"hljs-built_in\">rm</span> [<span class=\"hljs-type\">IMAGE</span> <span class=\"hljs-type\">ID</span> / 仓库名：标签] <span class=\"hljs-comment\"># id不需要全部打完，输入前3个就可以定位到</span>\n<span class=\"hljs-comment\"># 例如删除ubuntu</span>\ndocker image <span class=\"hljs-built_in\">rm</span> ubuntu:<span class=\"hljs-number\">18.04</span>\n</code></pre>\n<h3 id=\"容器使用\">容器使用</h3>\n<p>容器是独立运行的一个或一组应用，以及它们的运行态环境。</p>\n<ul>\n<li>列出</li>\n</ul>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-keyword\">container</span> <span class=\"hljs-keyword\">ls</span> # <span class=\"hljs-keyword\">ls</span>只列出当前运行的容器，<span class=\"hljs-keyword\">ls</span> -a列出所有容器，包含了已经停止运行的\n</code></pre>\n<ul>\n<li>启动（这个镜像为基础启动并运行一个容器）</li>\n</ul>\n<p>创建一个新的容器</p>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-built_in\">run</span> -<span class=\"hljs-keyword\">it</span> ubuntu:<span class=\"hljs-number\">18.04</span> bash <span class=\"hljs-comment\"># -ℹ交互式操作，-t终端</span>\n</code></pre>\n<p>启动一个已经停止的容器</p>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-built_in\">container</span> start [CONTAINER ID] <span class=\"hljs-meta\"># id不需要全部打完，输入前3个就可以定位到</span>\n</code></pre>\n<ul>\n<li>守护态运行</li>\n</ul>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-built_in\">run</span> -<span class=\"hljs-keyword\">it</span> -d ubuntu:<span class=\"hljs-number\">18.04</span> bash <span class=\"hljs-comment\"># -ℹ交互式操作，-t终端</span>\n</code></pre>\n<p>如果需要查看守护态容器的日志信息，可以使用：</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">docker</span> logs [CONTAINER ID] <span class=\"hljs-comment\"># id不需要全部打完，输入前3个就可以定位到</span>\n</code></pre>\n<ul>\n<li>停止</li>\n</ul>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-keyword\">container</span> stop <span class=\"hljs-comment\">[CONTAINER ID]</span> \n# 如果需要重新启动，可以restart\ndocker <span class=\"hljs-keyword\">container</span> restart <span class=\"hljs-comment\">[CONTAINER ID]</span>\n</code></pre>\n<ul>\n<li>进入容器</li>\n</ul>\n<p>一般来说，都是需要一个可交互的终端进入容器</p>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-keyword\">exec</span> -it [CONTAINER ID] bash # <span class=\"hljs-keyword\">exec</span>进入容器，使用<span class=\"hljs-keyword\">exit</span>并不会停止容器的运行，这和attach不一样\n</code></pre>\n<ul>\n<li>删除</li>\n</ul>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-built_in\">container</span> rm [CONTAINER ID]\n\n<span class=\"hljs-meta\"># 如果想清理所有停止运行的容器</span>\ndocker <span class=\"hljs-built_in\">container</span> prune\n</code></pre>\n<h2 id=\"docker-hub\">Docker Hub</h2>\n<h3 id=\"登陆和退出docker-hub\">登陆和退出docker hub</h3>\n<pre><code>docker login\ndocker logout\n``\n\n### 镜像的搜索\n\n```bash\ndocker search ubuntu # 可以看到搜索出来的镜像\n</code></pre>\n<h2 id=\"数据卷volume\">数据卷Volume</h2>\n<p>数据卷 可以在容器之间共享和重用\n对 数据卷 的修改会立马生效\n对 数据卷 的更新，不会影响镜像\n数据卷 默认会一直存在，即使容器被删除</p>\n<ul>\n<li>创建</li>\n</ul>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-built_in\">volume</span> <span class=\"hljs-keyword\">create</span> my-vol\n</code></pre>\n<ul>\n<li>查看</li>\n</ul>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-built_in\">volume</span> ls <span class=\"hljs-meta\"># 查看所有的数据卷</span>\ndocker <span class=\"hljs-built_in\">volume</span> inspect [<span class=\"hljs-built_in\">VOLUME</span> NAME] <span class=\"hljs-meta\"># 查看某个数据卷的信息</span>\n</code></pre>\n<ul>\n<li>启动</li>\n</ul>\n<p>在使用docker run命令的时候，带上<code>--mount</code>将数据卷挂载到容器中</p>\n<pre><code class=\"language-bash\">docker run -d -P --name web --mount source=my-vol,target=<span class=\"hljs-regexp\">/usr/</span>share<span class=\"hljs-regexp\">/nginx/</span>html nginx:alpine <span class=\"hljs-comment\"># --name 定义容器的名称</span>\n</code></pre>\n<p>以上命令。创建一个名为<code>web</code>的容器，家在一个数据卷到容器web的<code>/usr/share/nginx/html</code>目录。</p>\n<p>查看数据卷的具体信息</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">docker inspect web</span>\n</code></pre>\n<p>结果：</p>\n<pre><code class=\"language-json\"><span class=\"hljs-string\">&quot;Mounts&quot;</span>: [\n  {\n    <span class=\"hljs-string\">&quot;Type&quot;</span>: <span class=\"hljs-string\">&quot;volume&quot;</span>,\n    <span class=\"hljs-string\">&quot;Name&quot;</span>: <span class=\"hljs-string\">&quot;my-vol&quot;</span>,\n    <span class=\"hljs-string\">&quot;Source&quot;</span>: <span class=\"hljs-string\">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,\n    <span class=\"hljs-string\">&quot;Destination&quot;</span>: <span class=\"hljs-string\">&quot;/usr/share/nginx/html&quot;</span>,\n    <span class=\"hljs-string\">&quot;Driver&quot;</span>: <span class=\"hljs-string\">&quot;local&quot;</span>,\n    <span class=\"hljs-string\">&quot;Mode&quot;</span>: <span class=\"hljs-string\">&quot;&quot;</span>,\n    <span class=\"hljs-string\">&quot;RW&quot;</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-string\">&quot;Propagation&quot;</span>: <span class=\"hljs-string\">&quot;&quot;</span>\n  }\n],\n</code></pre>\n<ul>\n<li>删除</li>\n</ul>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-built_in\">volume</span> rm [<span class=\"hljs-built_in\">VOLUME</span> NAME] <span class=\"hljs-meta\"># 删除指定的数据卷</span>\ndocker <span class=\"hljs-built_in\">volume</span> prune <span class=\"hljs-meta\"># 删除无主的数据卷</span>\n</code></pre>\n<ul>\n<li>挂载目录</li>\n</ul>\n<pre><code class=\"language-bash\">$ docker run -d -P --name web --mount type=bind,<span class=\"hljs-keyword\">source</span>=<span class=\"hljs-regexp\">/src/</span>webapp,target=<span class=\"hljs-regexp\">/usr/</span>share<span class=\"hljs-regexp\">/nginx/</span>html nginx:alpine\n</code></pre>\n<p>如果source为绝对路径，则为挂载主机的目录。</p>\n<h2 id=\"网络\">网络</h2>\n<h3 id=\"外部访问容器\">外部访问容器</h3>\n<p>通过-P或-p参数指定或者不制定端口的方式让外部访问容器内部的网络应用。</p>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-built_in\">run</span> -d -P nginx:alpine <span class=\"hljs-comment\"># 启动一个容器</span>\ndocker container ls\n</code></pre>\n<p>在PORTS那一列，可以看到：</p>\n<pre><code><span class=\"hljs-number\">0.0.0.0:32768</span>-&gt;<span class=\"hljs-number\">80</span>/tcp\n</code></pre>\n<p>这里表示着本机的32768端口被映射到了容器的80端口，意味着在本机上访问32768端口就可以访问到容器的nginx默认页面。访问方式为本机ip + 端口（32768）。</p>\n<h3 id=\"容器互联\">容器互联</h3>\n<p>通过docker网络的方式让连接到创建的网络上实现容器之间的互联。</p>\n<ul>\n<li>创建网络</li>\n</ul>\n<pre><code class=\"language-bash\">docker network <span class=\"hljs-keyword\">create</span> -d bridge [NETWORK <span class=\"hljs-type\">NAME</span>]\n</code></pre>\n<p>运行第一个容器并连接到网络[NETWORK NAME]</p>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-built_in\">run</span> -<span class=\"hljs-keyword\">it</span> <span class=\"hljs-comment\">--rm --name busybox1 --network [NETWORK NAME] busybox sh</span>\n</code></pre>\n<p>运行第一个容器并连接到网络[NETWORK NAME]</p>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-built_in\">run</span> -<span class=\"hljs-keyword\">it</span> <span class=\"hljs-comment\">--rm --name busybox2 --network [NETWORK NAME] busybox sh</span>\n</code></pre>\n<p>以上两个容器连接到了同一个网络[NETWORK NAME]，某一个容器都可以ping通与之连载在同一个网络下的容器。</p>\n<pre><code class=\"language-bash\">/ #<span class=\"hljs-built_in\"> ping </span>busybox2<span class=\"hljs-built_in\">\nPING </span>busybox2 (172.19.0.3): 56 data bytes\n64 bytes <span class=\"hljs-keyword\">from</span> 172.19.0.3: <span class=\"hljs-attribute\">seq</span>=0 <span class=\"hljs-attribute\">ttl</span>=64 <span class=\"hljs-attribute\">time</span>=0.072 ms\n64 bytes <span class=\"hljs-keyword\">from</span> 172.19.0.3: <span class=\"hljs-attribute\">seq</span>=1 <span class=\"hljs-attribute\">ttl</span>=64 <span class=\"hljs-attribute\">time</span>=0.118 ms\n</code></pre>\n"}