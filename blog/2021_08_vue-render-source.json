{"title":"理解一下vue的render方法","description":"vue的render方法","keywords":null,"labels":["vue源码"],"date":"2021-08-19","path":"2021/08/vue-render-source.md","slug":"2021_08_vue-render-source","html":"<p><div style=\"text-align: center;\"><img align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://i.loli.net/2021/08/19/w6YcFmd1eJOA5oC.png\" alt=\"属性未定义的错误提示\" ></div> </p>\n<p>上面提示会出现在我们没有在vue中定义该data却在模板中提到的时候。恰好是在render执行过程中出现的，所以可以借此理解一下vue的render函数。</p>\n<h3 id=\"render\">render</h3>\n<p>render函数是vue实例中的一个私有方法，作用是通过<code>createElement</code>创建并返回虚拟dom(vnode)。翻看源码，该方法定义在<a target='_blank'  href=\"https://github.com/vuejs/vue/blob/dev/src/core/instance/render.js\">src/core/instance/render.js</a>中。</p>\n<p>位于<code>initRender</code>函数。在这函数里面找到_render的定义：</p>\n<pre><code class=\"language-js\">Vue.prototype._render = <span class=\"hljs-keyword\">function</span> (){\n  <span class=\"hljs-regexp\">//</span> ...\n  <span class=\"hljs-regexp\">//</span> 从options中拿到render函数\n  const { render } = vm.<span class=\"hljs-variable\">$options</span>\n\n  <span class=\"hljs-regexp\">//</span> 通过call函数传入当前上下文\n  vnode = render.call(vm._renderProxy, vm.<span class=\"hljs-variable\">$createElement</span>)\n  <span class=\"hljs-regexp\">//</span> ...\n}\n</code></pre>\n<h3 id=\"createelement\">createElement</h3>\n<p>vm中的createElement在该函数上方有定义。</p>\n<pre><code class=\"language-js\">vm._c =<span class=\"hljs-function\"> (<span class=\"hljs-params\">a</span>, <span class=\"hljs-params\">b</span>, <span class=\"hljs-params\">c</span>, <span class=\"hljs-params\">d</span>) =&gt;</span> create<span class=\"hljs-constructor\">Element(<span class=\"hljs-params\">vm</span>, <span class=\"hljs-params\">a</span>, <span class=\"hljs-params\">b</span>, <span class=\"hljs-params\">c</span>, <span class=\"hljs-params\">d</span>, <span class=\"hljs-params\">false</span>)</span>\nvm.$createElement =<span class=\"hljs-function\"> (<span class=\"hljs-params\">a</span>, <span class=\"hljs-params\">b</span>, <span class=\"hljs-params\">c</span>, <span class=\"hljs-params\">d</span>) =&gt;</span> create<span class=\"hljs-constructor\">Element(<span class=\"hljs-params\">vm</span>, <span class=\"hljs-params\">a</span>, <span class=\"hljs-params\">b</span>, <span class=\"hljs-params\">c</span>, <span class=\"hljs-params\">d</span>, <span class=\"hljs-params\">true</span>)</span>\n</code></pre>\n<p>可以知道，第一个私有函数_c挂在vm上是提供给编译器编译模版生成render函数。</p>\n<p>第二个直接定义在实例上，提供用于手写render方法。</p>\n<p>我们在vue中render函数是这么写的：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">new</span> Vue({\n  <span class=\"hljs-function\"><span class=\"hljs-title\">render</span>(<span class=\"hljs-params\">createElement</span>)</span> {\n    <span class=\"hljs-comment\">// do sth</span>\n    <span class=\"hljs-keyword\">return</span> createElement(\n      <span class=\"hljs-comment\">// vnode stuff</span>\n    )\n  }\n})\n</code></pre>\n<p>这里的createElement就是在上方代码中定义的。  </p>\n<p><strong>vnode的生成会替换render目标元素dom，所以不能把vue实例render到有内容的dom上。</strong></p>\n<h3 id=\"renderproxy\">renderProxy</h3>\n<p>render.call函数的第一个参数是<code>vm._renderProxy</code>，在<code>init.js</code>中，有这两行代码在初始化周期等前执行：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">if</span> (undefined !== <span class=\"hljs-string\">&#x27;production&#x27;</span>) {\n  initProxy(<span class=\"hljs-keyword\">vm</span>)\n} <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-keyword\">vm</span>._renderProxy = <span class=\"hljs-keyword\">vm</span>\n}\n</code></pre>\n<p>表示如果当前是开发环境，就执行initProxy，来看看initProxy的代码。initProxy位于<code>src/core/instance/proxy.js</code>中。</p>\n<pre><code class=\"language-js\">initProxy = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">initProxy</span> <span class=\"hljs-params\">(vm)</span> {</span>\n  // hasProxy是用于判断当前环境是否支持proxy/\n  // 支持的浏览器将直接调用<span class=\"hljs-keyword\">new</span> Proxy进行数据劫持\n  <span class=\"hljs-keyword\">if</span> (hasProxy) {\n    // determine which proxy handler <span class=\"hljs-keyword\">to</span> use\n    const <span class=\"hljs-keyword\">options</span> = <span class=\"hljs-keyword\">vm</span>.$<span class=\"hljs-keyword\">options</span>\n    const handlers = <span class=\"hljs-keyword\">options</span>.render &amp;&amp; <span class=\"hljs-keyword\">options</span>.render._withStripped\n      ? getHandler\n      : hasHandler\n    <span class=\"hljs-keyword\">vm</span>._renderProxy = <span class=\"hljs-keyword\">new</span> Proxy(<span class=\"hljs-keyword\">vm</span>, handlers)\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">vm</span>._renderProxy = <span class=\"hljs-keyword\">vm</span>\n  }\n}\n</code></pre>\n<p>如果在支持的浏览器中，<code>new Proxy</code>的第二个参数会传入<code>hasHandler</code>，查看hasHandler定义:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> hasHandler = {\n  has (target, <span class=\"hljs-built_in\">key</span>) {\n    <span class=\"hljs-keyword\">const</span> has = <span class=\"hljs-built_in\">key</span> in target\n    <span class=\"hljs-keyword\">const</span> isAllowed = allowedGlobals(<span class=\"hljs-built_in\">key</span>) ||\n      (typeof <span class=\"hljs-built_in\">key</span> === <span class=\"hljs-string\">&#x27;string&#x27;</span> &amp;&amp; <span class=\"hljs-built_in\">key</span>.charAt(<span class=\"hljs-number\">0</span>) === <span class=\"hljs-string\">&#x27;_&#x27;</span> &amp;&amp; !(<span class=\"hljs-built_in\">key</span> in target.$data))\n    <span class=\"hljs-keyword\">if</span> (!has &amp;&amp; !isAllowed) {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">key</span> in target.$data) warnReservedPrefix(target, <span class=\"hljs-built_in\">key</span>)\n      <span class=\"hljs-keyword\">else</span> warnNonPresent(target, <span class=\"hljs-built_in\">key</span>)\n    }\n    <span class=\"hljs-keyword\">return</span> has || !isAllowed\n  }\n}\n</code></pre>\n<p><a target='_blank'  href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a>，在这里就是对vm的data进行数据劫持，也就是代理。</p>\n<p>handler又一个has方法，这是针对 in 操作符的代理方法，has内部主要检查target中是否有key属性，如果有就继续执行，如果没有，就回到文章开头的那个错误提示啦。</p>\n<h3 id=\"总结\">总结</h3>\n<p>在<code>init.js</code>中定义了<code>initRender</code>以及<code>_renderProxy</code>方法。在<code>render.js</code>找到render函数定义，主要描述了对用户手写的render函数进行处理生成vnode，中间将vnode设置到vm实例中(vm.$vnode)，最后返回并执行后续的操作。</p>\n<p><strong>Vue版本：<a target='_blank'  href=\"https://github.com/vuejs/vue/archive/refs/tags/v2.6.14.zip\">2.6.14</a></strong></p>\n"}