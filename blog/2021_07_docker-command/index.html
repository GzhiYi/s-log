<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=client/client-87ec37cb.css rel=stylesheet><link href=client/[slug]-2cfb82a0.css rel=stylesheet> <title>Docker的一些需记基础命令和用法-GzhiYi's blog</title><meta content=docker的基础命令快速查询，方便记忆和翻阅使用。 name=description data-svelte=svelte-2vncnt><meta content=docker，基础命令，基本使用，容器，镜像 name=keywords data-svelte=svelte-2vncnt> <link href=/client/client.ea05aee9.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-87ec37cb.css rel=preload as=style><link href=/client/[slug].f6291aad.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/config.026ad977.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/[slug]-2cfb82a0.css rel=preload as=style></head> <body> <div id=sapper> <nav class=svelte-1vrbr95><ul class=svelte-1vrbr95><li class=svelte-1vrbr95><a href=blog aria-current=page class=svelte-1vrbr95 rel=prefetch>文章列表</a></ul></nav> <div style=width:100%;height:56px;background-color:#dee2e8></div> <main class=svelte-1ca6gui style=padding:1rem> <div class="svelte-vusc9 base"><div class="svelte-vusc9 title">Docker的一些需记基础命令和用法</div> <span class="svelte-vusc9 author">GzhiYi · 2021-07-29</span> <div class=label>docker</div></div> <div class="svelte-vusc9 content"><p>由于docker目前在项目中用的比较少，慢慢在写项目的过程中，有一些命令会被我遗忘掉。所以我把一些基础常用的docker命令列下来，方便自己在回顾docker或者重新使用的时候快速运用上。在后续的时间里，也会尽可能的将docker应用到能用上的项目中。</p> <h2 id=安装>安装</h2> <p>我用linux比较多，所以只记录在linux下的安装步骤。</p> <ol> <li>如果有旧版本的docker，需要先卸载旧版本。旧版本为docker或者docker-engine。</li> </ol> <pre><code class=language-bash>sudo apt-<span class=hljs-builtin-name>get</span> <span class=hljs-builtin-name>remove</span> docker docker-engine docker.io
</code></pre> <ol start=2> <li>用脚本安装。</li> </ol> <pre><code class=language-bash><span class=hljs-string>curl</span> -<span class=hljs-string>fsSL</span> <span class=hljs-string>get</span>.<span class=hljs-string>docker</span>.<span class=hljs-string>com</span> -<span class=hljs-string>o</span> <span class=hljs-built_in>get-docker.sh</span>
<span class=hljs-string>sudo</span> <span class=hljs-string>sh</span> <span class=hljs-built_in>get-docker.sh</span> <span class=hljs-built_in>--mirror</span> <span class=hljs-string>Aliyun</span>
</code></pre> <ol start=3> <li>启动docker</li> </ol> <pre><code class=language-bash>sudo systemctl <span class=hljs-keyword>enable</span> docker
sudo systemctl <span class=hljs-keyword>start</span> docker
</code></pre> <ol start=4> <li>建立docker用户组</li> </ol> <pre><code class=language-bash>sudo groupadd docker
sudo usermod -aG docker $USER
</code></pre> <ol start=5> <li>测试是否安装好</li> </ol> <pre><code class=language-bash>docker <span class=hljs-built_in>run</span> <span class=hljs-comment>--rm hello-world</span>
</code></pre> <h2 id=常用命令>常用命令</h2> <p>注意-t之类的命令是用于修饰动作的，比如<code>run -t-d</code></p> <h3 id=镜像使用>镜像使用</h3> <ul> <li>拉取</li> </ul> <pre><code class=language-bash><span class=hljs-attribute>docker</span> pull ubuntu:<span class=hljs-number>18</span>.<span class=hljs-number>04</span> # 拉取ubuntu镜像，对应版本（tag）为<span class=hljs-number>18</span>.<span class=hljs-number>04</span>
</code></pre> <ul> <li>运行（这个镜像为基础启动并运行一个容器）</li> </ul> <pre><code class=language-bash>docker <span class=hljs-built_in>run</span> -<span class=hljs-keyword>it</span> ubuntu:<span class=hljs-number>18.04</span> bash <span class=hljs-comment># -ℹ交互式操作，-t终端</span>
</code></pre> <ul> <li>列出</li> </ul> <pre><code class=language-bash>docker image <span class=hljs-keyword>ls</span> <span class=hljs-comment># ls后跟具名可以过滤该名的镜像； -a列出所有镜像</span>
</code></pre> <ul> <li>删除</li> </ul> <pre><code class=language-bash>docker image <span class=hljs-built_in>rm</span> [<span class=hljs-type>IMAGE</span> <span class=hljs-type>ID</span> / 仓库名：标签] <span class=hljs-comment># id不需要全部打完，输入前3个就可以定位到</span>
<span class=hljs-comment># 例如删除ubuntu</span>
docker image <span class=hljs-built_in>rm</span> ubuntu:<span class=hljs-number>18.04</span>
</code></pre> <h3 id=容器使用>容器使用</h3> <p>容器是独立运行的一个或一组应用，以及它们的运行态环境。</p> <ul> <li>列出</li> </ul> <pre><code class=language-bash>docker <span class=hljs-keyword>container</span> <span class=hljs-keyword>ls</span> # <span class=hljs-keyword>ls</span>只列出当前运行的容器，<span class=hljs-keyword>ls</span> -a列出所有容器，包含了已经停止运行的
</code></pre> <ul> <li>启动（这个镜像为基础启动并运行一个容器）</li> </ul> <p>创建一个新的容器</p> <pre><code class=language-bash>docker <span class=hljs-built_in>run</span> -<span class=hljs-keyword>it</span> ubuntu:<span class=hljs-number>18.04</span> bash <span class=hljs-comment># -ℹ交互式操作，-t终端</span>
</code></pre> <p>启动一个已经停止的容器</p> <pre><code class=language-bash>docker <span class=hljs-built_in>container</span> start [CONTAINER ID] <span class=hljs-meta># id不需要全部打完，输入前3个就可以定位到</span>
</code></pre> <ul> <li>守护态运行</li> </ul> <pre><code class=language-bash>docker <span class=hljs-built_in>run</span> -<span class=hljs-keyword>it</span> -d ubuntu:<span class=hljs-number>18.04</span> bash <span class=hljs-comment># -ℹ交互式操作，-t终端</span>
</code></pre> <p>如果需要查看守护态容器的日志信息，可以使用：</p> <pre><code class=language-bash><span class=hljs-attribute>docker</span> logs [CONTAINER ID] <span class=hljs-comment># id不需要全部打完，输入前3个就可以定位到</span>
</code></pre> <ul> <li>停止</li> </ul> <pre><code class=language-bash>docker <span class=hljs-keyword>container</span> stop <span class=hljs-comment>[CONTAINER ID]</span> 
# 如果需要重新启动，可以restart
docker <span class=hljs-keyword>container</span> restart <span class=hljs-comment>[CONTAINER ID]</span>
</code></pre> <ul> <li>进入容器</li> </ul> <p>一般来说，都是需要一个可交互的终端进入容器</p> <pre><code class=language-bash>docker <span class=hljs-keyword>exec</span> -it [CONTAINER ID] bash # <span class=hljs-keyword>exec</span>进入容器，使用<span class=hljs-keyword>exit</span>并不会停止容器的运行，这和attach不一样
</code></pre> <ul> <li>删除</li> </ul> <pre><code class=language-bash>docker <span class=hljs-built_in>container</span> rm [CONTAINER ID]

<span class=hljs-meta># 如果想清理所有停止运行的容器</span>
docker <span class=hljs-built_in>container</span> prune
</code></pre> <h2 id=docker-hub>Docker Hub</h2> <h3 id=登陆和退出docker-hub>登陆和退出docker hub</h3> <pre><code>docker login
docker logout
``

### 镜像的搜索

```bash
docker search ubuntu # 可以看到搜索出来的镜像
</code></pre> <h2 id=数据卷volume>数据卷Volume</h2> <p>数据卷 可以在容器之间共享和重用 对 数据卷 的修改会立马生效 对 数据卷 的更新，不会影响镜像 数据卷 默认会一直存在，即使容器被删除</p> <ul> <li>创建</li> </ul> <pre><code class=language-bash>docker <span class=hljs-built_in>volume</span> <span class=hljs-keyword>create</span> my-vol
</code></pre> <ul> <li>查看</li> </ul> <pre><code class=language-bash>docker <span class=hljs-built_in>volume</span> ls <span class=hljs-meta># 查看所有的数据卷</span>
docker <span class=hljs-built_in>volume</span> inspect [<span class=hljs-built_in>VOLUME</span> NAME] <span class=hljs-meta># 查看某个数据卷的信息</span>
</code></pre> <ul> <li>启动</li> </ul> <p>在使用docker run命令的时候，带上<code>--mount</code>将数据卷挂载到容器中</p> <pre><code class=language-bash>docker run -d -P --name web --mount source=my-vol,target=<span class=hljs-regexp>/usr/</span>share<span class=hljs-regexp>/nginx/</span>html nginx:alpine <span class=hljs-comment># --name 定义容器的名称</span>
</code></pre> <p>以上命令。创建一个名为<code>web</code>的容器，家在一个数据卷到容器web的<code>/usr/share/nginx/html</code>目录。</p> <p>查看数据卷的具体信息</p> <pre><code class=language-bash><span class=hljs-attribute>docker inspect web</span>
</code></pre> <p>结果：</p> <pre><code class=language-json><span class=hljs-string>"Mounts"</span>: [
  {
    <span class=hljs-string>"Type"</span>: <span class=hljs-string>"volume"</span>,
    <span class=hljs-string>"Name"</span>: <span class=hljs-string>"my-vol"</span>,
    <span class=hljs-string>"Source"</span>: <span class=hljs-string>"/var/lib/docker/volumes/my-vol/_data"</span>,
    <span class=hljs-string>"Destination"</span>: <span class=hljs-string>"/usr/share/nginx/html"</span>,
    <span class=hljs-string>"Driver"</span>: <span class=hljs-string>"local"</span>,
    <span class=hljs-string>"Mode"</span>: <span class=hljs-string>""</span>,
    <span class=hljs-string>"RW"</span>: <span class=hljs-literal>true</span>,
    <span class=hljs-string>"Propagation"</span>: <span class=hljs-string>""</span>
  }
],
</code></pre> <ul> <li>删除</li> </ul> <pre><code class=language-bash>docker <span class=hljs-built_in>volume</span> rm [<span class=hljs-built_in>VOLUME</span> NAME] <span class=hljs-meta># 删除指定的数据卷</span>
docker <span class=hljs-built_in>volume</span> prune <span class=hljs-meta># 删除无主的数据卷</span>
</code></pre> <ul> <li>挂载目录</li> </ul> <pre><code class=language-bash>$ docker run -d -P --name web --mount type=bind,<span class=hljs-keyword>source</span>=<span class=hljs-regexp>/src/</span>webapp,target=<span class=hljs-regexp>/usr/</span>share<span class=hljs-regexp>/nginx/</span>html nginx:alpine
</code></pre> <p>如果source为绝对路径，则为挂载主机的目录。</p> <h2 id=网络>网络</h2> <h3 id=外部访问容器>外部访问容器</h3> <p>通过-P或-p参数指定或者不制定端口的方式让外部访问容器内部的网络应用。</p> <pre><code class=language-bash>docker <span class=hljs-built_in>run</span> -d -P nginx:alpine <span class=hljs-comment># 启动一个容器</span>
docker container ls
</code></pre> <p>在PORTS那一列，可以看到：</p> <pre><code><span class=hljs-number>0.0.0.0:32768</span>-><span class=hljs-number>80</span>/tcp
</code></pre> <p>这里表示着本机的32768端口被映射到了容器的80端口，意味着在本机上访问32768端口就可以访问到容器的nginx默认页面。访问方式为本机ip + 端口（32768）。</p> <h3 id=容器互联>容器互联</h3> <p>通过docker网络的方式让连接到创建的网络上实现容器之间的互联。</p> <ul> <li>创建网络</li> </ul> <pre><code class=language-bash>docker network <span class=hljs-keyword>create</span> -d bridge [NETWORK <span class=hljs-type>NAME</span>]
</code></pre> <p>运行第一个容器并连接到网络[NETWORK NAME]</p> <pre><code class=language-bash>docker <span class=hljs-built_in>run</span> -<span class=hljs-keyword>it</span> <span class=hljs-comment>--rm --name busybox1 --network [NETWORK NAME] busybox sh</span>
</code></pre> <p>运行第一个容器并连接到网络[NETWORK NAME]</p> <pre><code class=language-bash>docker <span class=hljs-built_in>run</span> -<span class=hljs-keyword>it</span> <span class=hljs-comment>--rm --name busybox2 --network [NETWORK NAME] busybox sh</span>
</code></pre> <p>以上两个容器连接到了同一个网络[NETWORK NAME]，某一个容器都可以ping通与之连载在同一个网络下的容器。</p> <pre><code class=language-bash>/ #<span class=hljs-built_in> ping </span>busybox2<span class=hljs-built_in>
PING </span>busybox2 (172.19.0.3): 56 data bytes
64 bytes <span class=hljs-keyword>from</span> 172.19.0.3: <span class=hljs-attribute>seq</span>=0 <span class=hljs-attribute>ttl</span>=64 <span class=hljs-attribute>time</span>=0.072 ms
64 bytes <span class=hljs-keyword>from</span> 172.19.0.3: <span class=hljs-attribute>seq</span>=1 <span class=hljs-attribute>ttl</span>=64 <span class=hljs-attribute>time</span>=0.118 ms
</code></pre> </div> <div class="svelte-vusc9 contact"><div style=line-height:20px>如果你对这页内容有疑问，欢迎联系我！</div> <a href="mailto:zhiyi.gong@outlook.com?subject=【重要】Docker的一些需记基础命令和用法&body=gzhiyi.top/blog/2021_07_docker-command" target=_blank>邮箱 </a> <br> <a href=https://github.com/gzhiyi target=_blank>github </a> </div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"Docker的一些需记基础命令和用法",description:"docker的基础命令快速查询，方便记忆和翻阅使用。",keywords:"docker，基础命令，基本使用，容器，镜像",labels:["docker"],date:"2021-07-29",path:"2021\u002F07\u002Fdocker-command.md",slug:"2021_07_docker-command",html:"\u003Cp\u003E由于docker目前在项目中用的比较少，慢慢在写项目的过程中，有一些命令会被我遗忘掉。所以我把一些基础常用的docker命令列下来，方便自己在回顾docker或者重新使用的时候快速运用上。在后续的时间里，也会尽可能的将docker应用到能用上的项目中。\u003C\u002Fp\u003E\n\u003Ch2 id=\"安装\"\u003E安装\u003C\u002Fh2\u003E\n\u003Cp\u003E我用linux比较多，所以只记录在linux下的安装步骤。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E如果有旧版本的docker，需要先卸载旧版本。旧版本为docker或者docker-engine。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo apt-\u003Cspan class=\"hljs-builtin-name\"\u003Eget\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-builtin-name\"\u003Eremove\u003C\u002Fspan\u003E docker docker-engine docker.io\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E用脚本安装。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-string\"\u003Ecurl\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-string\"\u003EfsSL\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Eget\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-string\"\u003Edocker\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-string\"\u003Ecom\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-string\"\u003Eo\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eget-docker.sh\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-string\"\u003Esudo\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003Esh\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eget-docker.sh\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003E--mirror\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003EAliyun\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E启动docker\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo systemctl \u003Cspan class=\"hljs-keyword\"\u003Eenable\u003C\u002Fspan\u003E docker\nsudo systemctl \u003Cspan class=\"hljs-keyword\"\u003Estart\u003C\u002Fspan\u003E docker\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"4\"\u003E\n\u003Cli\u003E建立docker用户组\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo groupadd docker\nsudo usermod -aG docker $USER\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"5\"\u003E\n\u003Cli\u003E测试是否安装好\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E--rm hello-world\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"常用命令\"\u003E常用命令\u003C\u002Fh2\u003E\n\u003Cp\u003E注意-t之类的命令是用于修饰动作的，比如\u003Ccode\u003Erun -t-d\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Ch3 id=\"镜像使用\"\u003E镜像使用\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E拉取\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-attribute\"\u003Edocker\u003C\u002Fspan\u003E pull ubuntu:\u003Cspan class=\"hljs-number\"\u003E18\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-number\"\u003E04\u003C\u002Fspan\u003E # 拉取ubuntu镜像，对应版本（tag）为\u003Cspan class=\"hljs-number\"\u003E18\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-number\"\u003E04\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E运行（这个镜像为基础启动并运行一个容器）\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-keyword\"\u003Eit\u003C\u002Fspan\u003E ubuntu:\u003Cspan class=\"hljs-number\"\u003E18.04\u003C\u002Fspan\u003E bash \u003Cspan class=\"hljs-comment\"\u003E# -ℹ交互式操作，-t终端\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E列出\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker image \u003Cspan class=\"hljs-keyword\"\u003Els\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E# ls后跟具名可以过滤该名的镜像； -a列出所有镜像\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E删除\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker image \u003Cspan class=\"hljs-built_in\"\u003Erm\u003C\u002Fspan\u003E [\u003Cspan class=\"hljs-type\"\u003EIMAGE\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-type\"\u003EID\u003C\u002Fspan\u003E \u002F 仓库名：标签] \u003Cspan class=\"hljs-comment\"\u003E# id不需要全部打完，输入前3个就可以定位到\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# 例如删除ubuntu\u003C\u002Fspan\u003E\ndocker image \u003Cspan class=\"hljs-built_in\"\u003Erm\u003C\u002Fspan\u003E ubuntu:\u003Cspan class=\"hljs-number\"\u003E18.04\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"容器使用\"\u003E容器使用\u003C\u002Fh3\u003E\n\u003Cp\u003E容器是独立运行的一个或一组应用，以及它们的运行态环境。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E列出\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-keyword\"\u003Econtainer\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Els\u003C\u002Fspan\u003E # \u003Cspan class=\"hljs-keyword\"\u003Els\u003C\u002Fspan\u003E只列出当前运行的容器，\u003Cspan class=\"hljs-keyword\"\u003Els\u003C\u002Fspan\u003E -a列出所有容器，包含了已经停止运行的\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E启动（这个镜像为基础启动并运行一个容器）\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E创建一个新的容器\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-keyword\"\u003Eit\u003C\u002Fspan\u003E ubuntu:\u003Cspan class=\"hljs-number\"\u003E18.04\u003C\u002Fspan\u003E bash \u003Cspan class=\"hljs-comment\"\u003E# -ℹ交互式操作，-t终端\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E启动一个已经停止的容器\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Econtainer\u003C\u002Fspan\u003E start [CONTAINER ID] \u003Cspan class=\"hljs-meta\"\u003E# id不需要全部打完，输入前3个就可以定位到\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E守护态运行\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-keyword\"\u003Eit\u003C\u002Fspan\u003E -d ubuntu:\u003Cspan class=\"hljs-number\"\u003E18.04\u003C\u002Fspan\u003E bash \u003Cspan class=\"hljs-comment\"\u003E# -ℹ交互式操作，-t终端\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E如果需要查看守护态容器的日志信息，可以使用：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-attribute\"\u003Edocker\u003C\u002Fspan\u003E logs [CONTAINER ID] \u003Cspan class=\"hljs-comment\"\u003E# id不需要全部打完，输入前3个就可以定位到\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E停止\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-keyword\"\u003Econtainer\u003C\u002Fspan\u003E stop \u003Cspan class=\"hljs-comment\"\u003E[CONTAINER ID]\u003C\u002Fspan\u003E \n# 如果需要重新启动，可以restart\ndocker \u003Cspan class=\"hljs-keyword\"\u003Econtainer\u003C\u002Fspan\u003E restart \u003Cspan class=\"hljs-comment\"\u003E[CONTAINER ID]\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E进入容器\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E一般来说，都是需要一个可交互的终端进入容器\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-keyword\"\u003Eexec\u003C\u002Fspan\u003E -it [CONTAINER ID] bash # \u003Cspan class=\"hljs-keyword\"\u003Eexec\u003C\u002Fspan\u003E进入容器，使用\u003Cspan class=\"hljs-keyword\"\u003Eexit\u003C\u002Fspan\u003E并不会停止容器的运行，这和attach不一样\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E删除\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Econtainer\u003C\u002Fspan\u003E rm [CONTAINER ID]\n\n\u003Cspan class=\"hljs-meta\"\u003E# 如果想清理所有停止运行的容器\u003C\u002Fspan\u003E\ndocker \u003Cspan class=\"hljs-built_in\"\u003Econtainer\u003C\u002Fspan\u003E prune\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"docker-hub\"\u003EDocker Hub\u003C\u002Fh2\u003E\n\u003Ch3 id=\"登陆和退出docker-hub\"\u003E登陆和退出docker hub\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode\u003Edocker login\ndocker logout\n``\n\n### 镜像的搜索\n\n```bash\ndocker search ubuntu # 可以看到搜索出来的镜像\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"数据卷volume\"\u003E数据卷Volume\u003C\u002Fh2\u003E\n\u003Cp\u003E数据卷 可以在容器之间共享和重用\n对 数据卷 的修改会立马生效\n对 数据卷 的更新，不会影响镜像\n数据卷 默认会一直存在，即使容器被删除\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E创建\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Evolume\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ecreate\u003C\u002Fspan\u003E my-vol\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E查看\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Evolume\u003C\u002Fspan\u003E ls \u003Cspan class=\"hljs-meta\"\u003E# 查看所有的数据卷\u003C\u002Fspan\u003E\ndocker \u003Cspan class=\"hljs-built_in\"\u003Evolume\u003C\u002Fspan\u003E inspect [\u003Cspan class=\"hljs-built_in\"\u003EVOLUME\u003C\u002Fspan\u003E NAME] \u003Cspan class=\"hljs-meta\"\u003E# 查看某个数据卷的信息\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E启动\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E在使用docker run命令的时候，带上\u003Ccode\u003E--mount\u003C\u002Fcode\u003E将数据卷挂载到容器中\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker run -d -P --name web --mount source=my-vol,target=\u003Cspan class=\"hljs-regexp\"\u003E\u002Fusr\u002F\u003C\u002Fspan\u003Eshare\u003Cspan class=\"hljs-regexp\"\u003E\u002Fnginx\u002F\u003C\u002Fspan\u003Ehtml nginx:alpine \u003Cspan class=\"hljs-comment\"\u003E# --name 定义容器的名称\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E以上命令。创建一个名为\u003Ccode\u003Eweb\u003C\u002Fcode\u003E的容器，家在一个数据卷到容器web的\u003Ccode\u003E\u002Fusr\u002Fshare\u002Fnginx\u002Fhtml\u003C\u002Fcode\u003E目录。\u003C\u002Fp\u003E\n\u003Cp\u003E查看数据卷的具体信息\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-attribute\"\u003Edocker inspect web\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E结果：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-json\"\u003E\u003Cspan class=\"hljs-string\"\u003E&quot;Mounts&quot;\u003C\u002Fspan\u003E: [\n  {\n    \u003Cspan class=\"hljs-string\"\u003E&quot;Type&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;volume&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;Name&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;my-vol&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;Source&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;\u002Fvar\u002Flib\u002Fdocker\u002Fvolumes\u002Fmy-vol\u002F_data&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;Destination&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;\u002Fusr\u002Fshare\u002Fnginx\u002Fhtml&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;Driver&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;local&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;Mode&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;&quot;\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;RW&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-string\"\u003E&quot;Propagation&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;&quot;\u003C\u002Fspan\u003E\n  }\n],\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E删除\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Evolume\u003C\u002Fspan\u003E rm [\u003Cspan class=\"hljs-built_in\"\u003EVOLUME\u003C\u002Fspan\u003E NAME] \u003Cspan class=\"hljs-meta\"\u003E# 删除指定的数据卷\u003C\u002Fspan\u003E\ndocker \u003Cspan class=\"hljs-built_in\"\u003Evolume\u003C\u002Fspan\u003E prune \u003Cspan class=\"hljs-meta\"\u003E# 删除无主的数据卷\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E挂载目录\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E$ docker run -d -P --name web --mount type=bind,\u003Cspan class=\"hljs-keyword\"\u003Esource\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-regexp\"\u003E\u002Fsrc\u002F\u003C\u002Fspan\u003Ewebapp,target=\u003Cspan class=\"hljs-regexp\"\u003E\u002Fusr\u002F\u003C\u002Fspan\u003Eshare\u003Cspan class=\"hljs-regexp\"\u003E\u002Fnginx\u002F\u003C\u002Fspan\u003Ehtml nginx:alpine\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E如果source为绝对路径，则为挂载主机的目录。\u003C\u002Fp\u003E\n\u003Ch2 id=\"网络\"\u003E网络\u003C\u002Fh2\u003E\n\u003Ch3 id=\"外部访问容器\"\u003E外部访问容器\u003C\u002Fh3\u003E\n\u003Cp\u003E通过-P或-p参数指定或者不制定端口的方式让外部访问容器内部的网络应用。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E -d -P nginx:alpine \u003Cspan class=\"hljs-comment\"\u003E# 启动一个容器\u003C\u002Fspan\u003E\ndocker container ls\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在PORTS那一列，可以看到：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-number\"\u003E0.0.0.0:32768\u003C\u002Fspan\u003E-&gt;\u003Cspan class=\"hljs-number\"\u003E80\u003C\u002Fspan\u003E\u002Ftcp\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里表示着本机的32768端口被映射到了容器的80端口，意味着在本机上访问32768端口就可以访问到容器的nginx默认页面。访问方式为本机ip + 端口（32768）。\u003C\u002Fp\u003E\n\u003Ch3 id=\"容器互联\"\u003E容器互联\u003C\u002Fh3\u003E\n\u003Cp\u003E通过docker网络的方式让连接到创建的网络上实现容器之间的互联。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E创建网络\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker network \u003Cspan class=\"hljs-keyword\"\u003Ecreate\u003C\u002Fspan\u003E -d bridge [NETWORK \u003Cspan class=\"hljs-type\"\u003ENAME\u003C\u002Fspan\u003E]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E运行第一个容器并连接到网络[NETWORK NAME]\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-keyword\"\u003Eit\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E--rm --name busybox1 --network [NETWORK NAME] busybox sh\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E运行第一个容器并连接到网络[NETWORK NAME]\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-built_in\"\u003Erun\u003C\u002Fspan\u003E -\u003Cspan class=\"hljs-keyword\"\u003Eit\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E--rm --name busybox2 --network [NETWORK NAME] busybox sh\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E以上两个容器连接到了同一个网络[NETWORK NAME]，某一个容器都可以ping通与之连载在同一个网络下的容器。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u002F #\u003Cspan class=\"hljs-built_in\"\u003E ping \u003C\u002Fspan\u003Ebusybox2\u003Cspan class=\"hljs-built_in\"\u003E\nPING \u003C\u002Fspan\u003Ebusybox2 (172.19.0.3): 56 data bytes\n64 bytes \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E 172.19.0.3: \u003Cspan class=\"hljs-attribute\"\u003Eseq\u003C\u002Fspan\u003E=0 \u003Cspan class=\"hljs-attribute\"\u003Ettl\u003C\u002Fspan\u003E=64 \u003Cspan class=\"hljs-attribute\"\u003Etime\u003C\u002Fspan\u003E=0.072 ms\n64 bytes \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E 172.19.0.3: \u003Cspan class=\"hljs-attribute\"\u003Eseq\u003C\u002Fspan\u003E=1 \u003Cspan class=\"hljs-attribute\"\u003Ettl\u003C\u002Fspan\u003E=64 \u003Cspan class=\"hljs-attribute\"\u003Etime\u003C\u002Fspan\u003E=0.118 ms\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.ea05aee9.js"}catch(e){main="/client/legacy/client.ba8da692.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 