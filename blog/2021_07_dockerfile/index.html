<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=1280" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=client/client-8d9aba14.css rel=stylesheet><link href=client/[slug]-636f444e.css rel=stylesheet> <title>Dockerfile的一些用法记录-GzhiYi's blog</title><meta content=Dockerfile的作用，怎么用Dockerfile构建镜像，docker使用 name=description data-svelte=svelte-2vncnt><meta content=Dockerfile，FROM，RUN，COPY，ADD，CMD，ENTRYPOINT，ENV，ARG，VOLUME，EXPOSE，WORKDIR name=keywords data-svelte=svelte-2vncnt> <link href=/client/client.796a17e3.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-8d9aba14.css rel=preload as=style><link href=/client/[slug].9001d1d3.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/config.026ad977.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/[slug]-636f444e.css rel=preload as=style></head> <body> <div id=sapper> <nav class=svelte-1dbd5up><ul class=svelte-1dbd5up> <li class=svelte-1dbd5up><a href=blog aria-current=page class=svelte-1dbd5up rel=prefetch>blog</a></ul></nav> <main class=svelte-1y51i2> <div class="svelte-1cnt1lz base"><div class=label>docker</div> <div class="svelte-1cnt1lz title">Dockerfile的一些用法记录</div> <span class="svelte-1cnt1lz author">GzhiYi · 2021-07-29</span></div> <div class="svelte-1cnt1lz content"><p>对于docker镜像的制作和compose的使用等就在这进行记录，便于学习理解和记忆使用。</p> <h2 id=定制镜像>定制镜像</h2> <h2 id=dockerfile>Dockerfile</h2> <p>Dockerfile就当作是一个脚本文件，包含了一系列的指令用于构建每一层镜像。</p> <p>举例一个定制nginx镜像:</p> <p>新建一个Dockerfile文件，内容：</p> <pre><code class=language-bash><span class=hljs-keyword>FROM</span> nginx
RUN echo <span class=hljs-string>'&lt;h1>Hello, Docker!&lt;/h1>'</span> > <span class=hljs-regexp>/usr/</span>share<span class=hljs-regexp>/nginx/</span>html/index.html
</code></pre> <h3 id=from>FROM</h3> <p>指定基础镜像，在这个基础镜像的基础上进行定制。上面的基础镜像就是nginx。如果不以任何镜像为基础进行定制，则可以指定一个空白镜像<code>scratch</code>。</p> <pre><code class=language-bash><span class=hljs-selector-tag>FROM</span> scratch
</code></pre> <h3 id=run>RUN</h3> <ul> <li><p>shell格式，直接RUN + 命令的方式。</p> </li> <li><p>exec格式，RUN ["可执行文件", "参数1", "参数2"]</p> </li> </ul> <p>由于每一个RUN指令都会建立一层镜像，所以具有同一个目的的命令应该写在一个RUN里。不要用RUN当作shell命令去写。</p> <p>如：</p> <pre><code class=language-bash><span class=hljs-builtin-name>RUN</span> yarn install
<span class=hljs-builtin-name>RUN</span> yarn build
</code></pre> <p>可以修改为：</p> <pre><code class=language-bash><span class=hljs-builtin-name>RUN</span> yarn install && yarn build
<span class=hljs-comment># 如果指令长，可以换行和缩进</span>
<span class=hljs-builtin-name>RUN</span> yarn install \
    && yarn build
</code></pre> <p>最后也是需要记住的重要的事情是需要在每一层的构建后需要清理掉与镜像无关的文件内容。</p> <h3 id=构建镜像>构建镜像</h3> <pre><code class=language-bash>docker build -t nginx:v3 .

Sending build context <span class=hljs-keyword>to</span> Docker daemon  <span class=hljs-number>2.048</span>kB # 发送构建的上下文到docker引擎（上下文为命令中的 .）
Step <span class=hljs-number>1</span>/<span class=hljs-number>2</span> : FROM nginx
lates<span class=hljs-variable>t:</span> Pulling from library/nginx
<span class=hljs-number>33847</span>f680f63: Pull <span class=hljs-built_in>complete</span> 
dbb907d5159d: Pull <span class=hljs-built_in>complete</span> 
<span class=hljs-number>8</span>a268f30c42<span class=hljs-variable>a:</span> Pull <span class=hljs-built_in>complete</span> 
b10cf527a02d: Pull <span class=hljs-built_in>complete</span> 
c90b090c213<span class=hljs-variable>b:</span> Pull <span class=hljs-built_in>complete</span> 
<span class=hljs-number>1</span>f41b2f2bf94: Pull <span class=hljs-built_in>complete</span> 
Diges<span class=hljs-variable>t:</span> <span class=hljs-built_in>sha256</span>:<span class=hljs-number>8</span>f335768880da6baf72b70c701002b45f4932acae8d574dedfddaf967fc3ac90
Statu<span class=hljs-variable>s:</span> Downloaded newer image <span class=hljs-keyword>for</span> nginx:latest
 ---> <span class=hljs-number>08</span>b152afcfae
Step <span class=hljs-number>2</span>/<span class=hljs-number>2</span> : RUN <span class=hljs-keyword>echo</span> <span class=hljs-string>'&lt;h1>Hello, Docker!&lt;/h1>'</span> > /usr/share/nginx/html/<span class=hljs-built_in>index</span>.html
 ---> Running in <span class=hljs-number>24875</span>d44bcc4
Removing intermediate container <span class=hljs-number>24875</span>d44bcc4
 ---> a79570bc2fc7
Successfully built a79570bc2fc7
Successfully tagged nginx:v3
</code></pre> <p>构建完成之后，可以通过<code>docker image ls</code>查看构建好的镜像</p> <p>运行构建的镜像：</p> <pre><code class=language-bash>docker <span class=hljs-builtin-name>run</span> -d -P nginx:v3
<span class=hljs-comment># 查看ip+端口就可以看到Hello, Docker!</span>
</code></pre> <h3 id=镜像构建上下文（context）>镜像构建上下文（context）</h3> <p><code>docker build -t nginx:v3 .</code></p> <p>上面这条命令，最后的这个<code>.</code>就是构建此次镜像的上下文。指定这个上下文的作用是让其他的指令，如COPY、ADD等可以正确的处理文件内容。</p> <p>docker build命令执行时，会将这个上下文路径内的所有内容进行打包，上传到docker引擎中，docker引擎在后续就可以得到处理构建镜像过程的所有文件内容。</p> <pre><code class=language-bash><span class=hljs-keyword>COPY</span> .<span class=hljs-regexp>/package.json /</span>app/
</code></pre> <p>这个命令不是复制文件的命令，意在复制上下文（/APP/）目录下的package.json文件。</p> <ul> <li>.dockerignore</li> </ul> <p>如果在上下文中的一些文件不需要/不想被发送到docker引擎，可以使用<code>.dockerignore</code>忽略。</p> <h3 id=docker-build-使用>docker build 使用</h3> <ul> <li>从git仓库进行构建</li> </ul> <pre><code class=language-bash>docker build -t <span class=hljs-selector-attr>[IMAGE NAME]</span> <span class=hljs-selector-attr>[REPO URL]</span>
</code></pre> <h3 id=dockerfile-指令>Dockerfile 指令</h3> <ul> <li>COPY 文件复制</li> </ul> <p>COPY 指令将从构建上下文目录中 &lt;源路径> 的文件/目录复制到新的一层的镜像内的 &lt;目标路径> 位置。</p> <pre><code class=language-bash><span class=hljs-keyword>COPY</span> <span class=hljs-keyword>package</span>.json <span class=hljs-regexp>/usr/</span>src<span class=hljs-regexp>/app # 从构建上下文目录中的package.json复制到/u</span>sr<span class=hljs-regexp>/src/</span>app中
</code></pre> <ul> <li>ADD 高级的文件复制</li> </ul> <p>和COPY差不多的一致，在COPY的基础上增加了自动解压缩等的功能。</p> <ul> <li>CMD 容器启动命令，用于指定默认的容器主进程的启动命令的。</li> </ul> <p>一般推荐使用exec格式，注意要使用双引号。</p> <ul> <li><p>ENTRYPOINT 目的和CMD一样，都是在指定容器启动程序及参数。</p> </li> <li><p>ENV 用于设置环境变量。无论后面的其他指令还是运行时的应用，都可以直接使用这里定义的环境变量。</p> </li> </ul> <pre><code class=language-bash>ENV <span class=hljs-attribute>VERSION</span>=1.0
<span class=hljs-builtin-name>RUN</span> curl <span class=hljs-string>"https://<span class=hljs-variable>$VERSION</span>"</span>
</code></pre> <ul> <li>ARG 构建参数 = 默认值</li> </ul> <p>构建参数和ENV的效果是一样的，都是设置环境变量。不过ARG设置的构建环境变量在将来容器运行时是不会存在的。ARG指令有生效范围，在FORM指令前指定，只能用于FORM指令中。</p> <ul> <li>VOLUME 匿名卷</li> </ul> <pre><code class=language-bash><span class=hljs-type>VOLUME</span> /<span class=hljs-class><span class=hljs-keyword>data</span></span>
</code></pre> <p>在容器运行时自动挂载匿名卷，任何向/data中写入的信息都不会记录进容器的存储层，保证容器存储层无状态化。</p> <p>覆盖挂载：可以在运行容器时覆盖该挂载设置：</p> <pre><code class=language-bash><span class=hljs-title>docker</span> run -d -v mydata:/<span class=hljs-class><span class=hljs-keyword>data</span> xxxx</span>
</code></pre> <p>在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。</p> <ul> <li>EXPOSE 暴露端口</li> </ul> <p>只作端口声明。作用：</p> <ol> <li>帮助镜像使用者理解镜像所需要的配置端口。</li> <li>运行时会自动随机映射EXPOSE端口。</li> </ol> <pre><code class=language-bash>docker <span class=hljs-builtin-name>run</span> -P
</code></pre> <ul> <li>WORKDIR 指定工作目录</li> </ul> <p>在两条RUN指令中，都是完全不同的容器，如果第二条RUN指令用到第一条指令的内容，可能会出现错误。</p> <p>例如目录：</p> <pre><code class=language-bash>Dockerfile
app
  - <span class=hljs-keyword>package</span>.json
</code></pre> <p>在Dockerfile中</p> <pre><code class=language-bash><span class=hljs-builtin-name>RUN</span> cd app
<span class=hljs-builtin-name>RUN</span> yarn install
</code></pre> <p>以上指令会出现错误，因为第一条RUN和第二条RUN完全没有关联。如果需要关联，可能需要用到WORKDIR指令。</p> <pre><code class=language-bash><span class=hljs-keyword>WORKDIR</span><span class=bash> /app</span>
<span class=hljs-keyword>RUN</span><span class=bash> yarn install</span>
</code></pre> </div> <div class="svelte-1cnt1lz contact"><div>如果你对这页内容有疑问，欢迎联系我！</div> <a href="mailto:zhiyi.gong@outlook.com?subject=【重要】Dockerfile的一些用法记录&body=gzhiyi.top/blog/2021_07_dockerfile" target=_blank>邮箱 </a> <br> <a href=https://github.com/gzhiyi target=_blank>github </a> </div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"Dockerfile的一些用法记录",description:"Dockerfile的作用，怎么用Dockerfile构建镜像，docker使用",keywords:"Dockerfile，FROM，RUN，COPY，ADD，CMD，ENTRYPOINT，ENV，ARG，VOLUME，EXPOSE，WORKDIR",labels:["docker"],date:"2021-07-29",path:"2021\u002F07\u002Fdockerfile.md",slug:"2021_07_dockerfile",html:"\u003Cp\u003E对于docker镜像的制作和compose的使用等就在这进行记录，便于学习理解和记忆使用。\u003C\u002Fp\u003E\n\u003Ch2 id=\"定制镜像\"\u003E定制镜像\u003C\u002Fh2\u003E\n\u003Ch2 id=\"dockerfile\"\u003EDockerfile\u003C\u002Fh2\u003E\n\u003Cp\u003EDockerfile就当作是一个脚本文件，包含了一系列的指令用于构建每一层镜像。\u003C\u002Fp\u003E\n\u003Cp\u003E举例一个定制nginx镜像:\u003C\u002Fp\u003E\n\u003Cp\u003E新建一个Dockerfile文件，内容：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-keyword\"\u003EFROM\u003C\u002Fspan\u003E nginx\nRUN echo \u003Cspan class=\"hljs-string\"\u003E&#x27;&lt;h1&gt;Hello, Docker!&lt;\u002Fh1&gt;&#x27;\u003C\u002Fspan\u003E &gt; \u003Cspan class=\"hljs-regexp\"\u003E\u002Fusr\u002F\u003C\u002Fspan\u003Eshare\u003Cspan class=\"hljs-regexp\"\u003E\u002Fnginx\u002F\u003C\u002Fspan\u003Ehtml\u002Findex.html\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"from\"\u003EFROM\u003C\u002Fh3\u003E\n\u003Cp\u003E指定基础镜像，在这个基础镜像的基础上进行定制。上面的基础镜像就是nginx。如果不以任何镜像为基础进行定制，则可以指定一个空白镜像\u003Ccode\u003Escratch\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-selector-tag\"\u003EFROM\u003C\u002Fspan\u003E scratch\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"run\"\u003ERUN\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003Eshell格式，直接RUN + 命令的方式。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Eexec格式，RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E由于每一个RUN指令都会建立一层镜像，所以具有同一个目的的命令应该写在一个RUN里。不要用RUN当作shell命令去写。\u003C\u002Fp\u003E\n\u003Cp\u003E如：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E yarn install\n\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E yarn build\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E可以修改为：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E yarn install &amp;&amp; yarn build\n\u003Cspan class=\"hljs-comment\"\u003E# 如果指令长，可以换行和缩进\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E yarn install \\\n    &amp;&amp; yarn build\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E最后也是需要记住的重要的事情是需要在每一层的构建后需要清理掉与镜像无关的文件内容。\u003C\u002Fp\u003E\n\u003Ch3 id=\"构建镜像\"\u003E构建镜像\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker build -t nginx:v3 .\n\nSending build context \u003Cspan class=\"hljs-keyword\"\u003Eto\u003C\u002Fspan\u003E Docker daemon  \u003Cspan class=\"hljs-number\"\u003E2.048\u003C\u002Fspan\u003EkB # 发送构建的上下文到docker引擎（上下文为命令中的 .）\nStep \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\u002F\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E : FROM nginx\nlates\u003Cspan class=\"hljs-variable\"\u003Et:\u003C\u002Fspan\u003E Pulling from library\u002Fnginx\n\u003Cspan class=\"hljs-number\"\u003E33847\u003C\u002Fspan\u003Ef680f63: Pull \u003Cspan class=\"hljs-built_in\"\u003Ecomplete\u003C\u002Fspan\u003E \ndbb907d5159d: Pull \u003Cspan class=\"hljs-built_in\"\u003Ecomplete\u003C\u002Fspan\u003E \n\u003Cspan class=\"hljs-number\"\u003E8\u003C\u002Fspan\u003Ea268f30c42\u003Cspan class=\"hljs-variable\"\u003Ea:\u003C\u002Fspan\u003E Pull \u003Cspan class=\"hljs-built_in\"\u003Ecomplete\u003C\u002Fspan\u003E \nb10cf527a02d: Pull \u003Cspan class=\"hljs-built_in\"\u003Ecomplete\u003C\u002Fspan\u003E \nc90b090c213\u003Cspan class=\"hljs-variable\"\u003Eb:\u003C\u002Fspan\u003E Pull \u003Cspan class=\"hljs-built_in\"\u003Ecomplete\u003C\u002Fspan\u003E \n\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003Ef41b2f2bf94: Pull \u003Cspan class=\"hljs-built_in\"\u003Ecomplete\u003C\u002Fspan\u003E \nDiges\u003Cspan class=\"hljs-variable\"\u003Et:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Esha256\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-number\"\u003E8\u003C\u002Fspan\u003Ef335768880da6baf72b70c701002b45f4932acae8d574dedfddaf967fc3ac90\nStatu\u003Cspan class=\"hljs-variable\"\u003Es:\u003C\u002Fspan\u003E Downloaded newer image \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E nginx:latest\n ---&gt; \u003Cspan class=\"hljs-number\"\u003E08\u003C\u002Fspan\u003Eb152afcfae\nStep \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E\u002F\u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E : RUN \u003Cspan class=\"hljs-keyword\"\u003Eecho\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;&lt;h1&gt;Hello, Docker!&lt;\u002Fh1&gt;&#x27;\u003C\u002Fspan\u003E &gt; \u002Fusr\u002Fshare\u002Fnginx\u002Fhtml\u002F\u003Cspan class=\"hljs-built_in\"\u003Eindex\u003C\u002Fspan\u003E.html\n ---&gt; Running in \u003Cspan class=\"hljs-number\"\u003E24875\u003C\u002Fspan\u003Ed44bcc4\nRemoving intermediate container \u003Cspan class=\"hljs-number\"\u003E24875\u003C\u002Fspan\u003Ed44bcc4\n ---&gt; a79570bc2fc7\nSuccessfully built a79570bc2fc7\nSuccessfully tagged nginx:v3\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E构建完成之后，可以通过\u003Ccode\u003Edocker image ls\u003C\u002Fcode\u003E查看构建好的镜像\u003C\u002Fp\u003E\n\u003Cp\u003E运行构建的镜像：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-builtin-name\"\u003Erun\u003C\u002Fspan\u003E -d -P nginx:v3\n\u003Cspan class=\"hljs-comment\"\u003E# 查看ip+端口就可以看到Hello, Docker!\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"镜像构建上下文（context）\"\u003E镜像构建上下文（context）\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ccode\u003Edocker build -t nginx:v3 .\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E上面这条命令，最后的这个\u003Ccode\u003E.\u003C\u002Fcode\u003E就是构建此次镜像的上下文。指定这个上下文的作用是让其他的指令，如COPY、ADD等可以正确的处理文件内容。\u003C\u002Fp\u003E\n\u003Cp\u003Edocker build命令执行时，会将这个上下文路径内的所有内容进行打包，上传到docker引擎中，docker引擎在后续就可以得到处理构建镜像过程的所有文件内容。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-keyword\"\u003ECOPY\u003C\u002Fspan\u003E .\u003Cspan class=\"hljs-regexp\"\u003E\u002Fpackage.json \u002F\u003C\u002Fspan\u003Eapp\u002F\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这个命令不是复制文件的命令，意在复制上下文（\u002FAPP\u002F）目录下的package.json文件。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E.dockerignore\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E如果在上下文中的一些文件不需要\u002F不想被发送到docker引擎，可以使用\u003Ccode\u003E.dockerignore\u003C\u002Fcode\u003E忽略。\u003C\u002Fp\u003E\n\u003Ch3 id=\"docker-build-使用\"\u003Edocker build 使用\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E从git仓库进行构建\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker build -t \u003Cspan class=\"hljs-selector-attr\"\u003E[IMAGE NAME]\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-attr\"\u003E[REPO URL]\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"dockerfile-指令\"\u003EDockerfile 指令\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003ECOPY 文件复制\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003ECOPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件\u002F目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-keyword\"\u003ECOPY\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Epackage\u003C\u002Fspan\u003E.json \u003Cspan class=\"hljs-regexp\"\u003E\u002Fusr\u002F\u003C\u002Fspan\u003Esrc\u003Cspan class=\"hljs-regexp\"\u003E\u002Fapp # 从构建上下文目录中的package.json复制到\u002Fu\u003C\u002Fspan\u003Esr\u003Cspan class=\"hljs-regexp\"\u003E\u002Fsrc\u002F\u003C\u002Fspan\u003Eapp中\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003EADD 高级的文件复制\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E和COPY差不多的一致，在COPY的基础上增加了自动解压缩等的功能。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ECMD 容器启动命令，用于指定默认的容器主进程的启动命令的。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E一般推荐使用exec格式，注意要使用双引号。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003EENTRYPOINT 目的和CMD一样，都是在指定容器启动程序及参数。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003EENV 用于设置环境变量。无论后面的其他指令还是运行时的应用，都可以直接使用这里定义的环境变量。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003EENV \u003Cspan class=\"hljs-attribute\"\u003EVERSION\u003C\u002Fspan\u003E=1.0\n\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E curl \u003Cspan class=\"hljs-string\"\u003E&quot;https:\u002F\u002F\u003Cspan class=\"hljs-variable\"\u003E$VERSION\u003C\u002Fspan\u003E&quot;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003EARG 构建参数 = 默认值\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E构建参数和ENV的效果是一样的，都是设置环境变量。不过ARG设置的构建环境变量在将来容器运行时是不会存在的。ARG指令有生效范围，在FORM指令前指定，只能用于FORM指令中。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EVOLUME 匿名卷\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-type\"\u003EVOLUME\u003C\u002Fspan\u003E \u002F\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在容器运行时自动挂载匿名卷，任何向\u002Fdata中写入的信息都不会记录进容器的存储层，保证容器存储层无状态化。\u003C\u002Fp\u003E\n\u003Cp\u003E覆盖挂载：可以在运行容器时覆盖该挂载设置：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-title\"\u003Edocker\u003C\u002Fspan\u003E run -d -v mydata:\u002F\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E xxxx\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在这行命令中，就使用了 mydata 这个命名卷挂载到了 \u002Fdata 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EEXPOSE 暴露端口\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E只作端口声明。作用：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E帮助镜像使用者理解镜像所需要的配置端口。\u003C\u002Fli\u003E\n\u003Cli\u003E运行时会自动随机映射EXPOSE端口。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Edocker \u003Cspan class=\"hljs-builtin-name\"\u003Erun\u003C\u002Fspan\u003E -P\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003EWORKDIR 指定工作目录\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E在两条RUN指令中，都是完全不同的容器，如果第二条RUN指令用到第一条指令的内容，可能会出现错误。\u003C\u002Fp\u003E\n\u003Cp\u003E例如目录：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003EDockerfile\napp\n  - \u003Cspan class=\"hljs-keyword\"\u003Epackage\u003C\u002Fspan\u003E.json\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在Dockerfile中\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E cd app\n\u003Cspan class=\"hljs-builtin-name\"\u003ERUN\u003C\u002Fspan\u003E yarn install\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E以上指令会出现错误，因为第一条RUN和第二条RUN完全没有关联。如果需要关联，可能需要用到WORKDIR指令。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-keyword\"\u003EWORKDIR\u003C\u002Fspan\u003E\u003Cspan class=\"bash\"\u003E \u002Fapp\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003ERUN\u003C\u002Fspan\u003E\u003Cspan class=\"bash\"\u003E yarn install\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.796a17e3.js"}catch(e){main="/client/legacy/client.c6fed283.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 