{"title":"lodash数组中chunk、compact方法","description":"lodash concat, array method","keywords":"lodash,concat,array,arrayPush,copyArray,baseFlatten","labels":["lodash"],"date":"2021-07-19","path":"2021/07/lodash-concat.md","slug":"2021_07_lodash-concat","html":"<h2 id=\"concat\">Concat</h2>\n<p>创建一个用任何数组或值拼接的新数组。</p>\n<h3 id=\"使用\">使用</h3>\n<pre><code class=\"language-javascript\">var<span class=\"hljs-built_in\"> array </span>= [1]\nvar other = _.concat(array, 2, [3], [[4]])\n \nconsole.log(other)\n// =&gt; [1, 2, 3, [4]]\n \nconsole.log(array)\n// =&gt; [1]\n</code></pre>\n<p>返回的是一个全新的数组；调用并不会改变原本的数组。传入的拼接参数可以为数字、一维数组，甚至是二维数组，这有点意思了来看看源代码的实现。</p>\n<h3 id=\"源码\">源码</h3>\n<pre><code class=\"language-javascript\">/**\n* @static\n* @memberOf _\n* @since 4.0.0\n* @category Array\n* @param {Array}<span class=\"hljs-built_in\"> array </span>The<span class=\"hljs-built_in\"> array </span>to concatenate.\n* @param {...*} [values] The values to concatenate.\n* @returns {Array} Returns the<span class=\"hljs-built_in\"> new </span>concatenated array.\n* @example\n*\n*/\nfunction concat() {\n  // 在定义concat时就不需要指定传入的参数有什么，直接读argruments。\n  var length = arguments.length; // 传入参数的长度，用于创建包含length - 1长度的args数组\n <span class=\"hljs-built_in\"> if </span>(!length) {\n   <span class=\"hljs-built_in\"> return </span>[];\n  }\n  var args = Array(length - 1),\n     <span class=\"hljs-built_in\"> array </span>= arguments[0], // 这里默认了第一个参数就是要拼接的“原数组”\n      index = length;\n  // 这里使用while(index--)就是直接遍历index + 1次，index从index - 1开始，最后index = 0作为遍历的结束\n  // 如果while(--index)则只会遍历index次，index为0不会被执行\n  while (index--) {\n    args[index - 1] = arguments[index];\n  }\n <span class=\"hljs-built_in\"> return </span>arrayPush(isArray(array) ? copyArray(array)<span class=\"hljs-keyword\"> :</span> [array], baseFlatten(args, 1));\n}\n</code></pre>\n<p>由于lodash代码中会存在多处调用（套娃），所以copyArray和baseFlatten在这一页中只作一些使用上的解释，之后也会对代码进行解释理解。</p>\n<p>其余函数作用：</p>\n<ol>\n<li>copyArray(source, array)</li>\n</ol>\n<p>将source的值复制为array。结果是source和array在数值上是一样的，只是遍历了source，逐个下标赋值到array中。</p>\n<ol start=\"2\">\n<li>baseFlatten(array, depth, predicate, isStrict, result)</li>\n</ol>\n<p>将数组array铺平。depth为铺平的深度。该函数有递归，后续再详细了解。</p>\n<p>其中一个可以学习到的用法：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">-1</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">end</span> = <span class=\"hljs-number\">6</span>\n<span class=\"hljs-keyword\">while</span>(++index &lt; <span class=\"hljs-keyword\">end</span>){}\n\n<span class=\"hljs-comment\">// 这样的遍历等价于</span>\n\n<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-keyword\">end</span>; i++) {}\n</code></pre>\n<ol start=\"3\">\n<li>arrayPush(array, values)</li>\n</ol>\n<p>将两个数组合并。\n!!这个方法会修改原传入array的数组！！这和数组展开方式进行合并是有一些区别的。</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n<span class=\"hljs-keyword\">let</span> arr2 = [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>]\n[<span class=\"hljs-meta\">...arr, ...arr2</span>] <span class=\"hljs-comment\">// 这个结果并不会改变arr和arr2</span>\n</code></pre>\n<h3 id=\"总结\">总结</h3>\n<p>这个函数可以对数组进行拼接，即便后续的参数包含有数字，字符串或者数组，和一般的数组拼接有一些额外的不同，但开发中感觉用的比较少。</p>\n"}