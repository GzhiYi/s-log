{"title":"Dockerfile的一些用法记录","description":"Dockerfile的作用，怎么用Dockerfile构建镜像，docker使用","keywords":"Dockerfile，FROM，RUN，COPY，ADD，CMD，ENTRYPOINT，ENV，ARG，VOLUME，EXPOSE，WORKDIR","labels":["docker"],"date":"2021-07-29","path":"2021/07/dockerfile.md","slug":"2021_07_dockerfile","html":"<p>对于docker镜像的制作和compose的使用等就在这进行记录，便于学习理解和记忆使用。</p>\n<h2 id=\"定制镜像\">定制镜像</h2>\n<h2 id=\"dockerfile\">Dockerfile</h2>\n<p>Dockerfile就当作是一个脚本文件，包含了一系列的指令用于构建每一层镜像。</p>\n<p>举例一个定制nginx镜像:</p>\n<p>新建一个Dockerfile文件，内容：</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-keyword\">FROM</span> nginx\nRUN echo <span class=\"hljs-string\">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; <span class=\"hljs-regexp\">/usr/</span>share<span class=\"hljs-regexp\">/nginx/</span>html/index.html\n</code></pre>\n<h3 id=\"from\">FROM</h3>\n<p>指定基础镜像，在这个基础镜像的基础上进行定制。上面的基础镜像就是nginx。如果不以任何镜像为基础进行定制，则可以指定一个空白镜像<code>scratch</code>。</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-selector-tag\">FROM</span> scratch\n</code></pre>\n<h3 id=\"run\">RUN</h3>\n<ul>\n<li><p>shell格式，直接RUN + 命令的方式。</p>\n</li>\n<li><p>exec格式，RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</p>\n</li>\n</ul>\n<p>由于每一个RUN指令都会建立一层镜像，所以具有同一个目的的命令应该写在一个RUN里。不要用RUN当作shell命令去写。</p>\n<p>如：</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-builtin-name\">RUN</span> yarn install\n<span class=\"hljs-builtin-name\">RUN</span> yarn build\n</code></pre>\n<p>可以修改为：</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-builtin-name\">RUN</span> yarn install &amp;&amp; yarn build\n<span class=\"hljs-comment\"># 如果指令长，可以换行和缩进</span>\n<span class=\"hljs-builtin-name\">RUN</span> yarn install \\\n    &amp;&amp; yarn build\n</code></pre>\n<p>最后也是需要记住的重要的事情是需要在每一层的构建后需要清理掉与镜像无关的文件内容。</p>\n<h3 id=\"构建镜像\">构建镜像</h3>\n<pre><code class=\"language-bash\">docker build -t nginx:v3 .\n\nSending build context <span class=\"hljs-keyword\">to</span> Docker daemon  <span class=\"hljs-number\">2.048</span>kB # 发送构建的上下文到docker引擎（上下文为命令中的 .）\nStep <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">2</span> : FROM nginx\nlates<span class=\"hljs-variable\">t:</span> Pulling from library/nginx\n<span class=\"hljs-number\">33847</span>f680f63: Pull <span class=\"hljs-built_in\">complete</span> \ndbb907d5159d: Pull <span class=\"hljs-built_in\">complete</span> \n<span class=\"hljs-number\">8</span>a268f30c42<span class=\"hljs-variable\">a:</span> Pull <span class=\"hljs-built_in\">complete</span> \nb10cf527a02d: Pull <span class=\"hljs-built_in\">complete</span> \nc90b090c213<span class=\"hljs-variable\">b:</span> Pull <span class=\"hljs-built_in\">complete</span> \n<span class=\"hljs-number\">1</span>f41b2f2bf94: Pull <span class=\"hljs-built_in\">complete</span> \nDiges<span class=\"hljs-variable\">t:</span> <span class=\"hljs-built_in\">sha256</span>:<span class=\"hljs-number\">8</span>f335768880da6baf72b70c701002b45f4932acae8d574dedfddaf967fc3ac90\nStatu<span class=\"hljs-variable\">s:</span> Downloaded newer image <span class=\"hljs-keyword\">for</span> nginx:latest\n ---&gt; <span class=\"hljs-number\">08</span>b152afcfae\nStep <span class=\"hljs-number\">2</span>/<span class=\"hljs-number\">2</span> : RUN <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/<span class=\"hljs-built_in\">index</span>.html\n ---&gt; Running in <span class=\"hljs-number\">24875</span>d44bcc4\nRemoving intermediate container <span class=\"hljs-number\">24875</span>d44bcc4\n ---&gt; a79570bc2fc7\nSuccessfully built a79570bc2fc7\nSuccessfully tagged nginx:v3\n</code></pre>\n<p>构建完成之后，可以通过<code>docker image ls</code>查看构建好的镜像</p>\n<p>运行构建的镜像：</p>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-builtin-name\">run</span> -d -P nginx:v3\n<span class=\"hljs-comment\"># 查看ip+端口就可以看到Hello, Docker!</span>\n</code></pre>\n<h3 id=\"镜像构建上下文（context）\">镜像构建上下文（context）</h3>\n<p><code>docker build -t nginx:v3 .</code></p>\n<p>上面这条命令，最后的这个<code>.</code>就是构建此次镜像的上下文。指定这个上下文的作用是让其他的指令，如COPY、ADD等可以正确的处理文件内容。</p>\n<p>docker build命令执行时，会将这个上下文路径内的所有内容进行打包，上传到docker引擎中，docker引擎在后续就可以得到处理构建镜像过程的所有文件内容。</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-keyword\">COPY</span> .<span class=\"hljs-regexp\">/package.json /</span>app/\n</code></pre>\n<p>这个命令不是复制文件的命令，意在复制上下文（/APP/）目录下的package.json文件。</p>\n<ul>\n<li>.dockerignore</li>\n</ul>\n<p>如果在上下文中的一些文件不需要/不想被发送到docker引擎，可以使用<code>.dockerignore</code>忽略。</p>\n<h3 id=\"docker-build-使用\">docker build 使用</h3>\n<ul>\n<li>从git仓库进行构建</li>\n</ul>\n<pre><code class=\"language-bash\">docker build -t <span class=\"hljs-selector-attr\">[IMAGE NAME]</span> <span class=\"hljs-selector-attr\">[REPO URL]</span>\n</code></pre>\n<h3 id=\"dockerfile-指令\">Dockerfile 指令</h3>\n<ul>\n<li>COPY 文件复制</li>\n</ul>\n<p>COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-keyword\">COPY</span> <span class=\"hljs-keyword\">package</span>.json <span class=\"hljs-regexp\">/usr/</span>src<span class=\"hljs-regexp\">/app # 从构建上下文目录中的package.json复制到/u</span>sr<span class=\"hljs-regexp\">/src/</span>app中\n</code></pre>\n<ul>\n<li>ADD 高级的文件复制</li>\n</ul>\n<p>和COPY差不多的一致，在COPY的基础上增加了自动解压缩等的功能。</p>\n<ul>\n<li>CMD 容器启动命令，用于指定默认的容器主进程的启动命令的。</li>\n</ul>\n<p>一般推荐使用exec格式，注意要使用双引号。</p>\n<ul>\n<li><p>ENTRYPOINT 目的和CMD一样，都是在指定容器启动程序及参数。</p>\n</li>\n<li><p>ENV 用于设置环境变量。无论后面的其他指令还是运行时的应用，都可以直接使用这里定义的环境变量。</p>\n</li>\n</ul>\n<pre><code class=\"language-bash\">ENV <span class=\"hljs-attribute\">VERSION</span>=1.0\n<span class=\"hljs-builtin-name\">RUN</span> curl <span class=\"hljs-string\">&quot;https://<span class=\"hljs-variable\">$VERSION</span>&quot;</span>\n</code></pre>\n<ul>\n<li>ARG 构建参数 = 默认值</li>\n</ul>\n<p>构建参数和ENV的效果是一样的，都是设置环境变量。不过ARG设置的构建环境变量在将来容器运行时是不会存在的。ARG指令有生效范围，在FORM指令前指定，只能用于FORM指令中。</p>\n<ul>\n<li>VOLUME 匿名卷</li>\n</ul>\n<pre><code class=\"language-bash\"><span class=\"hljs-type\">VOLUME</span> /<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span></span>\n</code></pre>\n<p>在容器运行时自动挂载匿名卷，任何向/data中写入的信息都不会记录进容器的存储层，保证容器存储层无状态化。</p>\n<p>覆盖挂载：可以在运行容器时覆盖该挂载设置：</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-title\">docker</span> run -d -v mydata:/<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> xxxx</span>\n</code></pre>\n<p>在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。</p>\n<ul>\n<li>EXPOSE 暴露端口</li>\n</ul>\n<p>只作端口声明。作用：</p>\n<ol>\n<li>帮助镜像使用者理解镜像所需要的配置端口。</li>\n<li>运行时会自动随机映射EXPOSE端口。</li>\n</ol>\n<pre><code class=\"language-bash\">docker <span class=\"hljs-builtin-name\">run</span> -P\n</code></pre>\n<ul>\n<li>WORKDIR 指定工作目录</li>\n</ul>\n<p>在两条RUN指令中，都是完全不同的容器，如果第二条RUN指令用到第一条指令的内容，可能会出现错误。</p>\n<p>例如目录：</p>\n<pre><code class=\"language-bash\">Dockerfile\napp\n  - <span class=\"hljs-keyword\">package</span>.json\n</code></pre>\n<p>在Dockerfile中</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-builtin-name\">RUN</span> cd app\n<span class=\"hljs-builtin-name\">RUN</span> yarn install\n</code></pre>\n<p>以上指令会出现错误，因为第一条RUN和第二条RUN完全没有关联。如果需要关联，可能需要用到WORKDIR指令。</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-keyword\">WORKDIR</span><span class=\"bash\"> /app</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> yarn install</span>\n</code></pre>\n"}