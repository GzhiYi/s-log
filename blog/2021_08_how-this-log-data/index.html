<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=client/client-87ec37cb.css rel=stylesheet><link href=client/[slug]-2cfb82a0.css rel=stylesheet> <title>vue是怎么在mounted、created等中访问到data数据的？-GzhiYi's blog</title><meta content=vue源码分析，为什么可以在created、mounted中通过this[key]访问vue中的data name=description data-svelte=svelte-2vncnt><meta content=vue，源码，this，data，created，mounted，生命周期 name=keywords data-svelte=svelte-2vncnt> <link href=/client/client.e0961b94.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-87ec37cb.css rel=preload as=style><link href=/client/[slug].13458e28.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/config.026ad977.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/[slug]-2cfb82a0.css rel=preload as=style></head> <body> <div id=sapper> <nav class=svelte-1vrbr95><ul class=svelte-1vrbr95><li class=svelte-1vrbr95><a href=blog aria-current=page class=svelte-1vrbr95 rel=prefetch>文章列表</a></ul></nav> <div style=width:100%;height:56px;background-color:#dee2e8></div> <main class=svelte-1ca6gui style=padding:1rem> <div class="svelte-vusc9 base"><div class="svelte-vusc9 title">vue是怎么在mounted、created等中访问到data数据的？</div> <span class="svelte-vusc9 author">GzhiYi · 2021-08-16</span> <div class=label>vue源码</div></div> <div class="svelte-vusc9 content"><p><div style=text-align:center><img align=center alt=defineProperty data-zoomable src=https://i.loli.net/2021/08/16/9wQxRlcUEeNstY8.png style=width:-webkit-fill-available;margin-bottom:20px;border-radius:8px;background:#f8fdf3></div> <p></p> <pre><code class=language-javascript>{
  <span class=hljs-function><span class=hljs-title>mounted</span>(<span class=hljs-params></span>)</span> {
    <span class=hljs-built_in>console</span>.log(<span class=hljs-built_in>this</span>.name) <span class=hljs-comment>// GzhiYi</span>
  },
  <span class=hljs-function><span class=hljs-title>data</span>(<span class=hljs-params></span>)</span> {
    <span class=hljs-keyword>return</span> {
      <span class=hljs-attr>name</span>: <span class=hljs-string>'GzhiYi'</span>
    }
  }
}
</code></pre> <p>如上代码，我们可以在<code>mounted</code>的周期钩子中访问到在data中定义到name属性。为什么可以访问到呢，可以通过vue源码中找到原因。</p> <p>这涉及到了vue在new实例后处理的事情。</p> <h3 id=涉及源码及相关文件>涉及源码及相关文件</h3> <p><code>src/core/instance/index.js</code>，这个文件中找到vue构造函数。其中<code>initMixin(Vue)</code>对Vue实例进行初始化操作。该方法在<code>src/core/instance/init.js</code>中进行定义。由于是查看data相关的数据处理动向，我们可以定位到<code>State</code>的初始化方法<code>initState(vm)</code>。</p> <p>继续定位到state的初始化方法。</p> <pre><code class=language-javascript>// 这里表示opts中如果opts.<span class=hljs-class><span class=hljs-keyword>data</span>有值则初始化<span class=hljs-keyword>data</span>值。</span>
<span class=hljs-title>if</span> (opts.<span class=hljs-class><span class=hljs-keyword>data</span>) {
  <span class=hljs-title>initData</span>(<span class=hljs-title>vm</span>)
} else {
  <span class=hljs-title>observe</span>(<span class=hljs-title>vm</span>.<span class=hljs-title>_data</span> = {}, true /* asRootData */)</span>
}
</code></pre> <p>在initData中，可以看到：</p> <pre><code class=language-js>// 这里连续赋值。如果<span class=hljs-class><span class=hljs-keyword>data</span>是一个函数，则走getData</span>
<span class=hljs-class><span class=hljs-keyword>data</span> = vm._data = typeof <span class=hljs-keyword>data</span> === 'function'</span>
  ? getData(<span class=hljs-class><span class=hljs-keyword>data</span>, vm)</span>
  : <span class=hljs-class><span class=hljs-keyword>data</span> || {}</span>

// 在getData中，是这样对<span class=hljs-class><span class=hljs-keyword>data</span>进行处理的</span>
<span class=hljs-class><span class=hljs-keyword>data</span>.call(<span class=hljs-title>vm</span>, <span class=hljs-title>vm</span>)</span>
</code></pre> <p>最后这里调用函数原型的<a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call target=_blank>call</a>方法，实际等同于<code>vm.data(vm)</code>。由于data是一个函数，那在本例中<code>getData</code>返回的就是：</p> <pre><code class=language-json>{
  <span class=hljs-built_in>name</span>: <span class=hljs-string>"GzhiYi"</span>
}
</code></pre> <p>额外增加一个预告，我们在vue中，一般定义data都是<code>function</code>的形式，这是建议的，但其实也可以定义为<code>object</code>的方式，从源码中可以看到<code>getData</code>这个函数存在着<code>pushTarget</code>等函数的处理，这是后续我要去看源码理解的。暂时不牵挂。</p> <h3 id=在实例中对data进行代理proxy>在实例中对data进行代理(proxy)</h3> <p>符合本内容的主要数据操作其实在这里。</p> <pre><code class=language-js>proxy(vm, <span class=hljs-string>`_data`</span>, key)
<span class=hljs-comment>// 追到proxy函数中，核心的就是对象的defineProperty方法。</span>
<span class=hljs-comment>// defineProperty方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。</span>

<span class=hljs-keyword>export</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>proxy</span> (<span class=hljs-params>target: <span class=hljs-built_in>Object</span>, sourceKey: <span class=hljs-built_in>string</span>, key: <span class=hljs-built_in>string</span></span>) </span>{
  sharedPropertyDefinition.get = <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>proxyGetter</span> (<span class=hljs-params></span>) </span>{
    <span class=hljs-keyword>return</span> <span class=hljs-built_in>this</span>[sourceKey][key]
  }
  sharedPropertyDefinition.set = <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>proxySetter</span> (<span class=hljs-params>val</span>) </span>{
    <span class=hljs-built_in>this</span>[sourceKey][key] = val
  }
  <span class=hljs-built_in>Object</span>.defineProperty(target, key, sharedPropertyDefinition)
}
<span class=hljs-comment>// 就是要把vm实例化时通过遍历data的值并把data的key-value定义到vm中。</span>
</code></pre> <p>由于要把data的每一项定义到vm上，所以vue在初始化state的时候，需要检测vm对象中是否已经有了data中定义的key。如果定义重复，也就是大概使用vue的人都会遇到以下的提醒：</p> <pre><code class=language-js>warn(
  `<span class=hljs-function><span class=hljs-keyword>Method</span> "$<span class=hljs-comment>{key}</span>" <span class=hljs-title>has</span> <span class=hljs-title>already</span> <span class=hljs-title>been</span> <span class=hljs-title>defined</span> <span class=hljs-title>as</span> <span class=hljs-title>a</span> <span class=hljs-title>data</span> <span class=hljs-title>property</span>.`,
  <span class=hljs-title>vm</span>
)</span>
</code></pre> <p>所以，在vm中，也就是vue实例中，created和mounted都是vue实例的key，就可以通过<code>this[key]</code>去访问data中的值了。</p> <p>当然，要注意，<code>initState(vm)</code>是在<code>beforeCreate</code>这个钩子之后执行，所以beforeCreate是不能通过上面的方式进行访问的。</p> <p><div style=text-align:center><img align=center alt=hooks data-zoomable src=https://i.loli.net/2021/08/16/twNof3mjWJT7A2r.png style=width:-webkit-fill-available;margin-bottom:20px;border-radius:8px;background:#f8fdf3></div> <p></p> <p><strong>Vue版本：<a href=https://github.com/vuejs/vue/archive/refs/tags/v2.6.14.zip target=_blank>2.6.14</a></strong></p> </div> <div class="svelte-vusc9 contact"><div style=line-height:20px>如果你对这页内容有疑问，欢迎联系我！</div> <a href="mailto:zhiyi.gong@outlook.com?subject=【重要】vue是怎么在mounted、created等中访问到data数据的？&body=gzhiyi.top/blog/2021_08_how-this-log-data" target=_blank>邮箱 </a> <br> <a href=https://github.com/gzhiyi target=_blank>github </a> </div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"vue是怎么在mounted、created等中访问到data数据的？",description:"vue源码分析，为什么可以在created、mounted中通过this[key]访问vue中的data",keywords:"vue，源码，this，data，created，mounted，生命周期",labels:["vue源码"],date:"2021-08-16",path:"2021\u002F08\u002Fhow-this-log-data.md",slug:"2021_08_how-this-log-data",html:"\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2021\u002F08\u002F16\u002F9wQxRlcUEeNstY8.png\" alt=\"defineProperty\" \u003E\u003C\u002Fdiv\u003E  \u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E{\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003Emounted\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E.name) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F GzhiYi\u003C\u002Fspan\u003E\n  },\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003Edata\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E {\n      \u003Cspan class=\"hljs-attr\"\u003Ename\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;GzhiYi&#x27;\u003C\u002Fspan\u003E\n    }\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E如上代码，我们可以在\u003Ccode\u003Emounted\u003C\u002Fcode\u003E的周期钩子中访问到在data中定义到name属性。为什么可以访问到呢，可以通过vue源码中找到原因。\u003C\u002Fp\u003E\n\u003Cp\u003E这涉及到了vue在new实例后处理的事情。\u003C\u002Fp\u003E\n\u003Ch3 id=\"涉及源码及相关文件\"\u003E涉及源码及相关文件\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ccode\u003Esrc\u002Fcore\u002Finstance\u002Findex.js\u003C\u002Fcode\u003E，这个文件中找到vue构造函数。其中\u003Ccode\u003EinitMixin(Vue)\u003C\u002Fcode\u003E对Vue实例进行初始化操作。该方法在\u003Ccode\u003Esrc\u002Fcore\u002Finstance\u002Finit.js\u003C\u002Fcode\u003E中进行定义。由于是查看data相关的数据处理动向，我们可以定位到\u003Ccode\u003EState\u003C\u002Fcode\u003E的初始化方法\u003Ccode\u003EinitState(vm)\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E继续定位到state的初始化方法。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F 这里表示opts中如果opts.\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E有值则初始化\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E值。\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-title\"\u003Eif\u003C\u002Fspan\u003E (opts.\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E) {\n  \u003Cspan class=\"hljs-title\"\u003EinitData\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-title\"\u003Evm\u003C\u002Fspan\u003E)\n} else {\n  \u003Cspan class=\"hljs-title\"\u003Eobserve\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-title\"\u003Evm\u003C\u002Fspan\u003E.\u003Cspan class=\"hljs-title\"\u003E_data\u003C\u002Fspan\u003E = {}, true \u002F* asRootData *\u002F)\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在initData中，可以看到：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003E\u002F\u002F 这里连续赋值。如果\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E是一个函数，则走getData\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E = vm._data = typeof \u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E === &#x27;function&#x27;\u003C\u002Fspan\u003E\n  ? getData(\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E, vm)\u003C\u002Fspan\u003E\n  : \u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E || {}\u003C\u002Fspan\u003E\n\n\u002F\u002F 在getData中，是这样对\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E进行处理的\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-class\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E.call(\u003Cspan class=\"hljs-title\"\u003Evm\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-title\"\u003Evm\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E最后这里调用函数原型的\u003Ca target='_blank'  href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fzh-CN\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FFunction\u002Fcall\"\u003Ecall\u003C\u002Fa\u003E方法，实际等同于\u003Ccode\u003Evm.data(vm)\u003C\u002Fcode\u003E。由于data是一个函数，那在本例中\u003Ccode\u003EgetData\u003C\u002Fcode\u003E返回的就是：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-json\"\u003E{\n  \u003Cspan class=\"hljs-built_in\"\u003Ename\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;GzhiYi&quot;\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E额外增加一个预告，我们在vue中，一般定义data都是\u003Ccode\u003Efunction\u003C\u002Fcode\u003E的形式，这是建议的，但其实也可以定义为\u003Ccode\u003Eobject\u003C\u002Fcode\u003E的方式，从源码中可以看到\u003Ccode\u003EgetData\u003C\u002Fcode\u003E这个函数存在着\u003Ccode\u003EpushTarget\u003C\u002Fcode\u003E等函数的处理，这是后续我要去看源码理解的。暂时不牵挂。\u003C\u002Fp\u003E\n\u003Ch3 id=\"在实例中对data进行代理proxy\"\u003E在实例中对data进行代理(proxy)\u003C\u002Fh3\u003E\n\u003Cp\u003E符合本内容的主要数据操作其实在这里。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003Eproxy(vm, \u003Cspan class=\"hljs-string\"\u003E`_data`\u003C\u002Fspan\u003E, key)\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 追到proxy函数中，核心的就是对象的defineProperty方法。\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F defineProperty方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eproxy\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Etarget: \u003Cspan class=\"hljs-built_in\"\u003EObject\u003C\u002Fspan\u003E, sourceKey: \u003Cspan class=\"hljs-built_in\"\u003Estring\u003C\u002Fspan\u003E, key: \u003Cspan class=\"hljs-built_in\"\u003Estring\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  sharedPropertyDefinition.get = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EproxyGetter\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EproxySetter\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Eval\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E[sourceKey][key] = val\n  }\n  \u003Cspan class=\"hljs-built_in\"\u003EObject\u003C\u002Fspan\u003E.defineProperty(target, key, sharedPropertyDefinition)\n}\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 就是要把vm实例化时通过遍历data的值并把data的key-value定义到vm中。\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E由于要把data的每一项定义到vm上，所以vue在初始化state的时候，需要检测vm对象中是否已经有了data中定义的key。如果定义重复，也就是大概使用vue的人都会遇到以下的提醒：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003Ewarn(\n  `\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003EMethod\u003C\u002Fspan\u003E &quot;$\u003Cspan class=\"hljs-comment\"\u003E{key}\u003C\u002Fspan\u003E&quot; \u003Cspan class=\"hljs-title\"\u003Ehas\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ealready\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ebeen\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Edefined\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eas\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Ea\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Edata\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eproperty\u003C\u002Fspan\u003E.`,\n  \u003Cspan class=\"hljs-title\"\u003Evm\u003C\u002Fspan\u003E\n)\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E所以，在vm中，也就是vue实例中，created和mounted都是vue实例的key，就可以通过\u003Ccode\u003Ethis[key]\u003C\u002Fcode\u003E去访问data中的值了。\u003C\u002Fp\u003E\n\u003Cp\u003E当然，要注意，\u003Ccode\u003EinitState(vm)\u003C\u002Fcode\u003E是在\u003Ccode\u003EbeforeCreate\u003C\u002Fcode\u003E这个钩子之后执行，所以beforeCreate是不能通过上面的方式进行访问的。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cdiv style=\"text-align: center;\"\u003E\u003Cimg align=\"center\" style=\"width: -webkit-fill-available;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2021\u002F08\u002F16\u002FtwNof3mjWJT7A2r.png\" alt=\"hooks\" \u003E\u003C\u002Fdiv\u003E  \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EVue版本：\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fvuejs\u002Fvue\u002Farchive\u002Frefs\u002Ftags\u002Fv2.6.14.zip\"\u003E2.6.14\u003C\u002Fa\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.e0961b94.js"}catch(e){main="/client/legacy/client.c8e72cd1.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 